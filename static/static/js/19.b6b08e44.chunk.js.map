{"version":3,"sources":["../../src/data/OperationData.ts","../../src/data/QueryData.ts","../../src/utils/useBaseQuery.ts","../../src/utils/useDeepMemo.ts","../../src/useQuery.ts","../../src/data/MutationData.ts","../../src/useMutation.ts","../../src/data/SubscriptionData.ts","../../src/ssr/RenderPromises.ts","components/blocks/index.tsx","data/StatusCode.ts","pages/QuickScanProfile/styled.ts","pages/QuickScanProfile/profiles.ts","pages/QuickScanProfile/QuickScanProfile.tsx","pages/QuickScanProfile/index.ts"],"names":["options","context","isMounted","previousOptions","this","getOptions","setOptions","newOptions","storePrevious","isEqual","unmount","refreshClient","client","isNew","cleanup","verifyDocumentType","document","type","operation","forceUpdate","previousData","currentObservable","runLazy","runLazyQuery","lazyOptions","getExecuteResult","result","getQueryResult","startQuerySubscription","obsRefetch","variables","query","refetch","obsFetchMore","fetchMoreOptions","fetchMore","obsUpdateQuery","mapFn","updateQuery","obsStartPolling","pollInterval","startPolling","obsStopPolling","stopPolling","obsSubscribeToMore","subscribeToMore","execute","skip","removeQuerySubscription","updateObservableQuery","getExecuteSsrResult","executeLazy","loading","networkStatus","ready","called","data","undefined","fetchData","ssr","obs","getCurrentResult","afterExecute","lazy","handleErrorOrCompleted","setTimeout","resetQueryStoreErrors","bind","treeRenderingInitiated","renderPromises","ssrDisabled","fetchDisabled","disableNetworkFetches","ssrLoading","addQueryPromise","prepareObservableQueryOptions","Query","displayName","fetchPolicy","metadata","reactComponent","initializeObservableQuery","getSSRObservable","observableQueryOptions","children","watchQuery","registerSSRObservable","newObservableQueryOptions","catch","subscription","obsQuery","subscribe","next","previousResult","error","resubscribeToQuery","hasOwnProperty","lastError","getLastError","lastResult","getLastResult","resetLastResults","Object","assign","observableQueryFields","currentResult","partial","errors","length","graphQLErrors","partialRefetch","onCompleted","onError","unsubscribe","OperationData","useBaseQuery","tick","updatedOptions","queryDataRef","current","QueryData","queryData","memoFn","key","ref","value","useDeepMemo","queryResult","useQuery","setResult","runMutation","mutationFunctionOptions","onMutationStart","mutationId","generateNewMutationId","mutate","then","response","onMutationCompleted","onMutationError","mutation","Mutation","mostRecentMutationId","optimisticResponse","update","awaitRefetchQueries","mutateOptions","mutateVariables","refetchQueries","mutationContext","ignoreResults","updateResult","isMostRecentMutation","useMutation","mutationDataRef","mutationData","MutationData","initialize","getLoadingResult","shouldResubscribe","keys","startSubscription","endSubscription","updateCurrentData","updateError","complete","completeSubscription","onSubscriptionData","subscriptionData","onSubscriptionComplete","queryPromises","Map","queryInfoTrie","observable","props","lookupQueryInfo","queryInstance","finish","seen","set","Promise","resolve","hasPromises","size","consumeAndAwaitPromises","promises","forEach","promise","push","clear","all","varMap","get","has","variablesString","JSON","stringify","info","blocksMap","React","BlockRenderer","blocks","map","block","Component","Error","StatusCode","styled","div","footer","socialNetworks","uuid","image","src","alt","fallbackColor","link","href","title","target","sitemap","tag","links","disclaimer","scoreRange","eyebrow","subtitle","body","quickscanProfileQuery","QuickScanProfile","storage","useContext","StorageContext","useParams","profile","useMemo","score","quickScanResult","answers","reduce","accumulator","profiles","sort","a","b","find","some","extensions","code","NotFound","removeValue","StorageKey","QuickScanResultUuid","to","RoutePath","QuickScan","SplashScreen"],"mappings":"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","file":"static/js/19.b6b08e44.chunk.js","sourcesContent":["import { ApolloClient } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport { invariant } from 'ts-invariant';\nimport {\n  ApolloContextValue,\n  parser,\n  DocumentType,\n  operationName\n} from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { CommonOptions } from '../types';\n\nexport abstract class OperationData<TOptions = any> {\n  public isMounted: boolean = false;\n  public previousOptions: CommonOptions<TOptions> = {} as CommonOptions<\n    TOptions\n  >;\n  public context: ApolloContextValue = {};\n  public client: ApolloClient<object> | undefined;\n\n  private options: CommonOptions<TOptions> = {} as CommonOptions<TOptions>;\n\n  constructor(options?: CommonOptions<TOptions>, context?: ApolloContextValue) {\n    this.options = options || ({} as CommonOptions<TOptions>);\n    this.context = context || {};\n  }\n\n  public getOptions(): CommonOptions<TOptions> {\n    return this.options;\n  }\n\n  public setOptions(\n    newOptions: CommonOptions<TOptions>,\n    storePrevious: boolean = false\n  ) {\n    if (storePrevious && !isEqual(this.options, newOptions)) {\n      this.previousOptions = this.options;\n    }\n    this.options = newOptions;\n  }\n\n  public abstract execute(...args: any): any;\n  public abstract afterExecute(...args: any): void | (() => void);\n  public abstract cleanup(): void;\n\n  protected unmount() {\n    this.isMounted = false;\n  }\n\n  protected refreshClient() {\n    const client =\n      (this.options && this.options.client) ||\n      (this.context && this.context.client);\n\n    invariant(\n      !!client,\n      'Could not find \"client\" in the context or passed in as an option. ' +\n        'Wrap the root component in an <ApolloProvider>, or pass an ' +\n        'ApolloClient instance in via options.'\n    );\n\n    let isNew = false;\n    if (client !== this.client) {\n      isNew = true;\n      this.client = client;\n      this.cleanup();\n    }\n    return {\n      client: this.client as ApolloClient<object>,\n      isNew\n    };\n  }\n\n  protected verifyDocumentType(document: DocumentNode, type: DocumentType) {\n    const operation = parser(document);\n    const requiredOperationName = operationName(type);\n    const usedOperationName = operationName(operation.type);\n    invariant(\n      operation.type === type,\n      `Running a ${requiredOperationName} requires a graphql ` +\n        `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n    );\n  }\n}\n","import {\n  ApolloQueryResult,\n  ApolloError,\n  NetworkStatus,\n  FetchMoreOptions,\n  FetchMoreQueryOptions,\n  UpdateQueryOptions,\n  SubscribeToMoreOptions\n} from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  QueryResult,\n  ObservableQueryFields\n} from '@apollo/react-common';\n\nimport {\n  QueryPreviousData,\n  QueryOptions,\n  QueryCurrentObservable,\n  QueryTuple,\n  QueryLazyOptions\n} from '../types';\nimport { OperationData } from './OperationData';\n\nexport class QueryData<TData, TVariables> extends OperationData {\n  private previousData: QueryPreviousData<TData, TVariables> = {};\n  private currentObservable: QueryCurrentObservable<TData, TVariables> = {};\n  private forceUpdate: any;\n\n  private runLazy: boolean = false;\n  private lazyOptions?: QueryLazyOptions<TVariables>;\n\n  constructor({\n    options,\n    context,\n    forceUpdate\n  }: {\n    options: QueryOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    forceUpdate: any;\n  }) {\n    super(options, context);\n    this.forceUpdate = forceUpdate;\n  }\n\n  public execute(): QueryResult<TData, TVariables> {\n    this.refreshClient();\n\n    const { skip, query } = this.getOptions();\n    if (skip || query !== this.previousData.query) {\n      this.removeQuerySubscription();\n      this.previousData.query = query;\n    }\n\n    this.updateObservableQuery();\n\n    if (this.isMounted) this.startQuerySubscription();\n\n    return this.getExecuteSsrResult() || this.getExecuteResult();\n  }\n\n  public executeLazy(): QueryTuple<TData, TVariables> {\n    return !this.runLazy\n      ? [\n          this.runLazyQuery,\n          {\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            called: false,\n            data: undefined\n          } as QueryResult<TData, TVariables>\n        ]\n      : [this.runLazyQuery, this.execute()];\n  }\n\n  // For server-side rendering\n  public fetchData(): Promise<ApolloQueryResult<any>> | boolean {\n    const options = this.getOptions();\n    if (options.skip || options.ssr === false) return false;\n\n    // currentObservable.query is already assigned the registered SSR observable in initializeObservableQuery.\n    const obs = this.currentObservable.query!;\n    const currentResult = obs.getCurrentResult();\n    return currentResult.loading ? obs.result() : false;\n  }\n\n  public afterExecute({ lazy = false }: { lazy?: boolean } = {}) {\n    this.isMounted = true;\n\n    if (!lazy || this.runLazy) {\n      this.handleErrorOrCompleted();\n\n      // When the component is done rendering stored query errors, we'll\n      // remove those errors from the `ObservableQuery` query store, so they\n      // aren't re-displayed on subsequent (potentially error free)\n      // requests/responses.\n      setTimeout(() => {\n        this.currentObservable.query &&\n          this.currentObservable.query.resetQueryStoreErrors();\n      });\n    }\n\n    this.previousOptions = this.getOptions();\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    this.removeQuerySubscription();\n    delete this.currentObservable.query;\n    delete this.previousData.result;\n  }\n\n  public getOptions() {\n    const options = super.getOptions();\n\n    if (this.lazyOptions) {\n      options.variables = {\n        ...options.variables,\n        ...this.lazyOptions.variables\n      };\n      options.context = {\n        ...options.context,\n        ...this.lazyOptions.context\n      };\n    }\n\n    // skip is not supported when using lazy query execution.\n    if (this.runLazy) {\n      delete options.skip;\n    }\n\n    return options;\n  }\n\n  private runLazyQuery = (options?: QueryLazyOptions<TVariables>) => {\n    this.cleanup();\n\n    this.runLazy = true;\n    this.lazyOptions = options;\n    this.forceUpdate();\n  };\n\n  private getExecuteResult = (): QueryResult<TData, TVariables> => {\n    const result = this.getQueryResult();\n    this.startQuerySubscription();\n    return result;\n  };\n\n  private getExecuteSsrResult() {\n    const treeRenderingInitiated = this.context && this.context.renderPromises;\n    const ssrDisabled = this.getOptions().ssr === false;\n    const fetchDisabled = this.refreshClient().client.disableNetworkFetches;\n\n    const ssrLoading = {\n      loading: true,\n      networkStatus: NetworkStatus.loading,\n      called: true,\n      data: undefined\n    } as QueryResult<TData, TVariables>;\n\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    if (ssrDisabled && (treeRenderingInitiated || fetchDisabled)) {\n      return ssrLoading;\n    }\n\n    let result;\n    if (treeRenderingInitiated) {\n      result =\n        this.context.renderPromises!.addQueryPromise(\n          this,\n          this.getExecuteResult\n        ) || ssrLoading;\n    }\n\n    return result;\n  }\n\n  private prepareObservableQueryOptions() {\n    const options = this.getOptions();\n    this.verifyDocumentType(options.query, DocumentType.Query);\n    const displayName = options.displayName || 'Query';\n\n    // Set the fetchPolicy to cache-first for network-only and cache-and-network\n    // fetches for server side renders.\n    if (\n      this.context &&\n      this.context.renderPromises &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options.fetchPolicy = 'cache-first';\n    }\n\n    return {\n      ...options,\n      displayName,\n      context: options.context,\n      metadata: { reactComponent: { displayName } }\n    };\n  }\n\n  private initializeObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    if (this.context && this.context.renderPromises) {\n      this.currentObservable.query = this.context.renderPromises.getSSRObservable(\n        this.getOptions()\n      );\n    }\n\n    if (!this.currentObservable.query) {\n      const observableQueryOptions = this.prepareObservableQueryOptions();\n\n      this.previousData.observableQueryOptions = {\n        ...observableQueryOptions,\n        children: null\n      };\n      this.currentObservable.query = this.refreshClient().client.watchQuery({\n        ...observableQueryOptions\n      });\n\n      if (this.context && this.context.renderPromises) {\n        this.context.renderPromises.registerSSRObservable(\n          this.currentObservable.query,\n          observableQueryOptions\n        );\n      }\n    }\n  }\n\n  private updateObservableQuery() {\n    // If we skipped initially, we may not have yet created the observable\n    if (!this.currentObservable.query) {\n      this.initializeObservableQuery();\n      return;\n    }\n\n    const newObservableQueryOptions = {\n      ...this.prepareObservableQueryOptions(),\n      children: null\n    };\n\n    if (\n      !isEqual(\n        newObservableQueryOptions,\n        this.previousData.observableQueryOptions\n      )\n    ) {\n      this.previousData.observableQueryOptions = newObservableQueryOptions;\n      this.currentObservable\n        .query!.setOptions(newObservableQueryOptions)\n        // The error will be passed to the child container, so we don't\n        // need to log it here. We could conceivably log something if\n        // an option was set. OTOH we don't log errors w/ the original\n        // query. See https://github.com/apollostack/react-apollo/issues/404\n        .catch(() => {});\n    }\n  }\n\n  private startQuerySubscription() {\n    if (this.currentObservable.subscription || this.getOptions().skip) return;\n\n    const obsQuery = this.currentObservable.query!;\n    this.currentObservable.subscription = obsQuery.subscribe({\n      next: ({ loading, networkStatus, data }) => {\n        const previousResult = this.previousData.result;\n\n        // Make sure we're not attempting to re-render similar results\n        if (\n          previousResult &&\n          previousResult.loading === loading &&\n          previousResult.networkStatus === networkStatus &&\n          isEqual(previousResult.data, data)\n        ) {\n          return;\n        }\n\n        this.forceUpdate();\n      },\n      error: error => {\n        this.resubscribeToQuery();\n        if (!error.hasOwnProperty('graphQLErrors')) throw error;\n\n        const previousResult = this.previousData.result;\n        if (\n          (previousResult && previousResult.loading) ||\n          !isEqual(error, this.previousData.error)\n        ) {\n          this.previousData.error = error;\n          this.forceUpdate();\n        }\n      }\n    });\n  }\n\n  private resubscribeToQuery() {\n    this.removeQuerySubscription();\n\n    // Unfortunately, if `lastError` is set in the current\n    // `observableQuery` when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `observableQuery` before re-starting\n    // the subscription, and restore it afterwards (so the subscription\n    // has a chance to stay open).\n    const lastError = this.currentObservable.query!.getLastError();\n    const lastResult = this.currentObservable.query!.getLastResult();\n    this.currentObservable.query!.resetLastResults();\n    this.startQuerySubscription();\n    Object.assign(this.currentObservable.query!, {\n      lastError,\n      lastResult\n    });\n  }\n\n  private getQueryResult(): QueryResult<TData, TVariables> {\n    let result: any = this.observableQueryFields();\n    const options = this.getOptions();\n\n    // When skipping a query (ie. we're not querying for data but still want\n    // to render children), make sure the `data` is cleared out and\n    // `loading` is set to `false` (since we aren't loading anything).\n    if (options.skip) {\n      result = {\n        ...result,\n        data: undefined,\n        error: undefined,\n        loading: false,\n        called: true\n      };\n    } else {\n      // Fetch the current result (if any) from the store.\n      const currentResult = this.currentObservable.query!.getCurrentResult();\n      const { loading, partial, networkStatus, errors } = currentResult;\n      let { error, data } = currentResult;\n\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      if (errors && errors.length > 0) {\n        error = new ApolloError({ graphQLErrors: errors });\n      }\n\n      result = {\n        ...result,\n        loading,\n        networkStatus,\n        error,\n        called: true\n      };\n\n      if (loading) {\n        const previousData =\n          this.previousData.result && this.previousData.result.data;\n        result.data =\n          previousData && data\n            ? {\n                ...previousData,\n                ...data\n              }\n            : previousData || data;\n      } else if (error) {\n        Object.assign(result, {\n          data: (this.currentObservable.query!.getLastResult() || ({} as any))\n            .data\n        });\n      } else {\n        const { fetchPolicy } = this.currentObservable.query!.options;\n        const { partialRefetch } = options;\n        if (\n          partialRefetch &&\n          !data &&\n          partial &&\n          fetchPolicy !== 'cache-only'\n        ) {\n          // When a `Query` component is mounted, and a mutation is executed\n          // that returns the same ID as the mounted `Query`, but has less\n          // fields in its result, Apollo Client's `QueryManager` returns the\n          // data as `undefined` since a hit can't be found in the cache.\n          // This can lead to application errors when the UI elements rendered by\n          // the original `Query` component are expecting certain data values to\n          // exist, and they're all of a sudden stripped away. To help avoid\n          // this we'll attempt to refetch the `Query` data.\n          Object.assign(result, {\n            loading: true,\n            networkStatus: NetworkStatus.loading\n          });\n          result.refetch();\n          return result;\n        }\n\n        result.data = data;\n      }\n    }\n\n    result.client = this.client;\n    this.previousData.loading =\n      (this.previousData.result && this.previousData.result.loading) || false;\n    this.previousData.result = result;\n    return result;\n  }\n\n  private handleErrorOrCompleted() {\n    const obsQuery = this.currentObservable.query;\n    if (!obsQuery) return;\n\n    const { data, loading, error } = obsQuery.getCurrentResult();\n\n    if (!loading) {\n      const { query, variables, onCompleted, onError } = this.getOptions();\n\n      // No changes, so we won't call onError/onCompleted.\n      if (\n        this.previousOptions &&\n        !this.previousData.loading &&\n        isEqual(this.previousOptions.query, query) &&\n        isEqual(this.previousOptions.variables, variables)\n      ) {\n        return;\n      }\n\n      if (onCompleted && !error) {\n        onCompleted(data);\n      } else if (onError && error) {\n        onError(error);\n      }\n    }\n  }\n\n  private removeQuerySubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n\n  private obsRefetch = (variables?: TVariables) =>\n    this.currentObservable.query!.refetch(variables);\n\n  private obsFetchMore = <K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>\n  ) => this.currentObservable.query!.fetchMore(fetchMoreOptions);\n\n  private obsUpdateQuery = <TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>\n    ) => TData\n  ) => this.currentObservable.query!.updateQuery(mapFn);\n\n  private obsStartPolling = (pollInterval: number) => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.startPolling(pollInterval);\n  };\n\n  private obsStopPolling = () => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.stopPolling();\n  };\n\n  private obsSubscribeToMore = <\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >\n  ) => this.currentObservable.query!.subscribeToMore(options);\n\n  private observableQueryFields() {\n    const observable = this.currentObservable.query!;\n    return {\n      variables: observable.variables,\n      refetch: this.obsRefetch,\n      fetchMore: this.obsFetchMore,\n      updateQuery: this.obsUpdateQuery,\n      startPolling: this.obsStartPolling,\n      stopPolling: this.obsStopPolling,\n      subscribeToMore: this.obsSubscribeToMore\n    } as ObservableQueryFields<TData, TVariables>;\n  }\n}\n","import { useContext, useEffect, useReducer, useRef } from 'react';\nimport {\n  getApolloContext,\n  OperationVariables,\n  QueryResult\n} from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { QueryHookOptions, QueryOptions, QueryTuple } from '../types';\nimport { QueryData } from '../data/QueryData';\nimport { useDeepMemo } from './useDeepMemo';\n\nexport function useBaseQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode,\n  options?: QueryHookOptions<TData, TVariables>,\n  lazy = false\n) {\n  const context = useContext(getApolloContext());\n  const [tick, forceUpdate] = useReducer(x => x + 1, 0);\n  const updatedOptions = options ? { ...options, query } : { query };\n\n  const queryDataRef = useRef<QueryData<TData, TVariables>>();\n\n  if (!queryDataRef.current) {\n    queryDataRef.current = new QueryData<TData, TVariables>({\n      options: updatedOptions as QueryOptions<TData, TVariables>,\n      context,\n      forceUpdate\n    });\n  }\n\n  const queryData = queryDataRef.current;\n  queryData.setOptions(updatedOptions);\n  queryData.context = context;\n\n  // `onError` and `onCompleted` callback functions will not always have a\n  // stable identity, so we'll exclude them from the memoization key to\n  // prevent `afterExecute` from being triggered un-necessarily.\n  const memo = {\n    options: { ...updatedOptions, onError: undefined, onCompleted: undefined },\n    context,\n    tick\n  };\n\n  const result = useDeepMemo(\n    () => (lazy ? queryData.executeLazy() : queryData.execute()),\n    memo\n  );\n\n  const queryResult = lazy\n    ? (result as QueryTuple<TData, TVariables>)[1]\n    : (result as QueryResult<TData, TVariables>);\n\n  useEffect(() => queryData.afterExecute({ lazy }), [\n    queryResult.loading,\n    queryResult.networkStatus,\n    queryResult.error,\n    queryResult.data\n  ]);\n\n  useEffect(() => {\n    return () => queryData.cleanup();\n  }, []);\n\n  return result;\n}\n","import { useRef } from 'react';\nimport { equal as isEqual } from '@wry/equality';\n\n/**\n * Memoize a result using deep equality. This hook has two advantages over\n * React.useMemo: it uses deep equality to compare memo keys, and it guarantees\n * that the memo function will only be called if the keys are unequal.\n * React.useMemo cannot be relied on to do this, since it is only a performance\n * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).\n */\nexport function useDeepMemo<TKey, TValue>(\n  memoFn: () => TValue,\n  key: TKey\n): TValue {\n  const ref = useRef<{ key: TKey; value: TValue }>();\n\n  if (!ref.current || !isEqual(key, ref.current.key)) {\n    ref.current = { key, value: memoFn() };\n  }\n\n  return ref.current.value;\n}\n","import { OperationVariables, QueryResult } from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { QueryHookOptions } from './types';\nimport { useBaseQuery } from './utils/useBaseQuery';\n\nexport function useQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode,\n  options?: QueryHookOptions<TData, TVariables>\n) {\n  return useBaseQuery<TData, TVariables>(query, options, false) as QueryResult<\n    TData,\n    TVariables\n  >;\n}\n","import { ApolloError } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  OperationVariables,\n  ExecutionResult,\n  MutationFunctionOptions,\n  MutationResult\n} from '@apollo/react-common';\n\nimport { MutationOptions, MutationTuple } from '../types';\nimport { OperationData } from './OperationData';\n\nexport class MutationData<\n  TData = any,\n  TVariables = OperationVariables\n> extends OperationData {\n  private mostRecentMutationId: number;\n  private result: MutationResult<TData>;\n  private previousResult?: MutationResult<TData>;\n  private setResult: (result: MutationResult<TData>) => any;\n\n  constructor({\n    options,\n    context,\n    result,\n    setResult\n  }: {\n    options: MutationOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    result: MutationResult<TData>;\n    setResult: (result: MutationResult<TData>) => any;\n  }) {\n    super(options, context);\n    this.verifyDocumentType(options.mutation, DocumentType.Mutation);\n    this.result = result;\n    this.setResult = setResult;\n    this.mostRecentMutationId = 0;\n  }\n\n  public execute(result: MutationResult<TData>) {\n    this.isMounted = true;\n    this.verifyDocumentType(this.getOptions().mutation, DocumentType.Mutation);\n    result.client = this.refreshClient().client;\n    return [this.runMutation, result] as MutationTuple<TData, TVariables>;\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    // No cleanup required.\n  }\n\n  private runMutation = (\n    mutationFunctionOptions: MutationFunctionOptions<\n      TData,\n      TVariables\n    > = {} as MutationFunctionOptions<TData, TVariables>\n  ) => {\n    this.onMutationStart();\n    const mutationId = this.generateNewMutationId();\n\n    return this.mutate(mutationFunctionOptions)\n      .then((response: ExecutionResult<TData>) => {\n        this.onMutationCompleted(response, mutationId);\n        return response;\n      })\n      .catch((error: ApolloError) => {\n        this.onMutationError(error, mutationId);\n        if (!this.getOptions().onError) throw error;\n      });\n  };\n\n  private mutate(\n    mutationFunctionOptions: MutationFunctionOptions<TData, TVariables>\n  ) {\n    const {\n      mutation,\n      variables,\n      optimisticResponse,\n      update,\n      context: mutationContext = {},\n      awaitRefetchQueries = false,\n      fetchPolicy\n    } = this.getOptions();\n    const mutateOptions = { ...mutationFunctionOptions };\n\n    const mutateVariables = Object.assign(\n      {},\n      variables,\n      mutateOptions.variables\n    );\n    delete mutateOptions.variables;\n\n    return this.refreshClient().client.mutate({\n      mutation,\n      optimisticResponse,\n      refetchQueries:\n        mutateOptions.refetchQueries || this.getOptions().refetchQueries,\n      awaitRefetchQueries,\n      update,\n      context: mutationContext,\n      fetchPolicy,\n      variables: mutateVariables,\n      ...mutateOptions\n    });\n  }\n\n  private onMutationStart() {\n    if (!this.result.loading && !this.getOptions().ignoreResults) {\n      this.updateResult({\n        loading: true,\n        error: undefined,\n        data: undefined,\n        called: true\n      });\n    }\n  }\n\n  private onMutationCompleted(\n    response: ExecutionResult<TData>,\n    mutationId: number\n  ) {\n    const { onCompleted, ignoreResults } = this.getOptions();\n\n    const { data, errors } = response;\n    const error =\n      errors && errors.length > 0\n        ? new ApolloError({ graphQLErrors: errors })\n        : undefined;\n\n    const callOncomplete = () =>\n      onCompleted ? onCompleted(data as TData) : null;\n\n    if (this.isMostRecentMutation(mutationId) && !ignoreResults) {\n      this.updateResult({\n        called: true,\n        loading: false,\n        data,\n        error\n      });\n    }\n    callOncomplete();\n  }\n\n  private onMutationError(error: ApolloError, mutationId: number) {\n    const { onError } = this.getOptions();\n\n    if (this.isMostRecentMutation(mutationId)) {\n      this.updateResult({\n        loading: false,\n        error,\n        data: undefined,\n        called: true\n      });\n    }\n\n    if (onError) {\n      onError(error);\n    }\n  }\n\n  private generateNewMutationId(): number {\n    return ++this.mostRecentMutationId;\n  }\n\n  private isMostRecentMutation(mutationId: number) {\n    return this.mostRecentMutationId === mutationId;\n  }\n\n  private updateResult(result: MutationResult<TData>) {\n    if (\n      this.isMounted &&\n      (!this.previousResult || !isEqual(this.previousResult, result))\n    ) {\n      this.setResult(result);\n      this.previousResult = result;\n    }\n  }\n}\n","import { useContext, useState, useRef, useEffect } from 'react';\nimport { getApolloContext, OperationVariables } from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { MutationHookOptions, MutationTuple } from './types';\nimport { MutationData } from './data/MutationData';\n\nexport function useMutation<TData = any, TVariables = OperationVariables>(\n  mutation: DocumentNode,\n  options?: MutationHookOptions<TData, TVariables>\n): MutationTuple<TData, TVariables> {\n  const context = useContext(getApolloContext());\n  const [result, setResult] = useState({ called: false, loading: false });\n  const updatedOptions = options ? { ...options, mutation } : { mutation };\n\n  const mutationDataRef = useRef<MutationData<TData, TVariables>>();\n  function getMutationDataRef() {\n    if (!mutationDataRef.current) {\n      mutationDataRef.current = new MutationData<TData, TVariables>({\n        options: updatedOptions,\n        context,\n        result,\n        setResult\n      });\n    }\n    return mutationDataRef.current;\n  }\n\n  const mutationData = getMutationDataRef();\n  mutationData.setOptions(updatedOptions);\n  mutationData.context = context;\n\n  useEffect(() => mutationData.afterExecute());\n\n  return mutationData.execute(result);\n}\n","import { equal as isEqual } from '@wry/equality';\nimport { ApolloContextValue, SubscriptionResult } from '@apollo/react-common';\n\nimport { OperationData } from './OperationData';\nimport { SubscriptionCurrentObservable, SubscriptionOptions } from '../types';\n\nexport class SubscriptionData<\n  TData = any,\n  TVariables = any\n> extends OperationData<SubscriptionOptions<TData, TVariables>> {\n  private setResult: any;\n  private currentObservable: SubscriptionCurrentObservable = {};\n\n  constructor({\n    options,\n    context,\n    setResult\n  }: {\n    options: SubscriptionOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    setResult: any;\n  }) {\n    super(options, context);\n    this.setResult = setResult;\n    this.initialize(options);\n  }\n\n  public execute(result: SubscriptionResult<TData>) {\n    if (this.getOptions().skip === true) {\n      this.cleanup();\n      return {\n        loading: false,\n        error: undefined,\n        data: undefined,\n        variables: this.getOptions().variables\n      };\n    }\n\n    let currentResult = result;\n    if (this.refreshClient().isNew) {\n      currentResult = this.getLoadingResult();\n    }\n\n    let { shouldResubscribe } = this.getOptions();\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(this.getOptions());\n    }\n\n    if (\n      shouldResubscribe !== false &&\n      this.previousOptions &&\n      Object.keys(this.previousOptions).length > 0 &&\n      (this.previousOptions.subscription !== this.getOptions().subscription ||\n        !isEqual(this.previousOptions.variables, this.getOptions().variables) ||\n        this.previousOptions.skip !== this.getOptions().skip)\n    ) {\n      this.cleanup();\n      currentResult = this.getLoadingResult();\n    }\n\n    this.initialize(this.getOptions());\n    this.startSubscription();\n\n    this.previousOptions = this.getOptions();\n    return { ...currentResult, variables: this.getOptions().variables };\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n  }\n\n  public cleanup() {\n    this.endSubscription();\n    delete this.currentObservable.query;\n  }\n\n  private initialize(options: SubscriptionOptions<TData, TVariables>) {\n    if (this.currentObservable.query || this.getOptions().skip === true) return;\n    this.currentObservable.query = this.refreshClient().client.subscribe({\n      query: options.subscription,\n      variables: options.variables,\n      fetchPolicy: options.fetchPolicy\n    });\n  }\n\n  private startSubscription() {\n    if (this.currentObservable.subscription) return;\n    this.currentObservable.subscription = this.currentObservable.query!.subscribe(\n      {\n        next: this.updateCurrentData.bind(this),\n        error: this.updateError.bind(this),\n        complete: this.completeSubscription.bind(this)\n      }\n    );\n  }\n\n  private getLoadingResult() {\n    return {\n      loading: true,\n      error: undefined,\n      data: undefined\n    };\n  }\n\n  private updateResult(result: SubscriptionResult) {\n    if (this.isMounted) {\n      this.setResult(result);\n    }\n  }\n\n  private updateCurrentData(result: SubscriptionResult<TData>) {\n    const { onSubscriptionData } = this.getOptions();\n\n    this.updateResult({\n      data: result.data,\n      loading: false,\n      error: undefined\n    });\n\n    if (onSubscriptionData) {\n      onSubscriptionData({\n        client: this.refreshClient().client,\n        subscriptionData: result\n      });\n    }\n  }\n\n  private updateError(error: any) {\n    this.updateResult({\n      error,\n      loading: false\n    });\n  }\n\n  private completeSubscription() {\n    const { onSubscriptionComplete } = this.getOptions();\n    if (onSubscriptionComplete) onSubscriptionComplete();\n    this.endSubscription();\n  }\n\n  private endSubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n}\n","import { ObservableQuery } from 'apollo-client';\nimport { QueryOptions } from '../types';\nimport { DocumentNode } from 'graphql';\nimport { QueryData } from '../data/QueryData';\n\ntype QueryInfo = {\n  seen: boolean;\n  observable: ObservableQuery<any, any> | null;\n};\n\nfunction makeDefaultQueryInfo(): QueryInfo {\n  return {\n    seen: false,\n    observable: null\n  };\n}\n\nexport class RenderPromises {\n  // Map from Query component instances to pending fetchData promises.\n  private queryPromises = new Map<QueryOptions<any, any>, Promise<any>>();\n\n  // Two-layered map from (query document, stringified variables) to QueryInfo\n  // objects. These QueryInfo objects are intended to survive through the whole\n  // getMarkupFromTree process, whereas specific Query instances do not survive\n  // beyond a single call to renderToStaticMarkup.\n  private queryInfoTrie = new Map<DocumentNode, Map<string, QueryInfo>>();\n\n  // Registers the server side rendered observable.\n  public registerSSRObservable<TData, TVariables>(\n    observable: ObservableQuery<any, TVariables>,\n    props: QueryOptions<TData, TVariables>\n  ) {\n    this.lookupQueryInfo(props).observable = observable;\n  }\n\n  // Get's the cached observable that matches the SSR Query instances query and variables.\n  public getSSRObservable<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ) {\n    return this.lookupQueryInfo(props).observable;\n  }\n\n  public addQueryPromise<TData, TVariables>(\n    queryInstance: QueryData<TData, TVariables>,\n    finish: () => React.ReactNode\n  ): React.ReactNode {\n    const info = this.lookupQueryInfo(queryInstance.getOptions());\n    if (!info.seen) {\n      this.queryPromises.set(\n        queryInstance.getOptions(),\n        new Promise(resolve => {\n          resolve(queryInstance.fetchData());\n        })\n      );\n      // Render null to abandon this subtree for this rendering, so that we\n      // can wait for the data to arrive.\n      return null;\n    }\n    return finish();\n  }\n\n  public hasPromises() {\n    return this.queryPromises.size > 0;\n  }\n\n  public consumeAndAwaitPromises() {\n    const promises: Promise<any>[] = [];\n    this.queryPromises.forEach((promise, queryInstance) => {\n      // Make sure we never try to call fetchData for this query document and\n      // these variables again. Since the queryInstance objects change with\n      // every rendering, deduplicating them by query and variables is the\n      // best we can do. If a different Query component happens to have the\n      // same query document and variables, it will be immediately rendered\n      // by calling finish() in addQueryPromise, which could result in the\n      // rendering of an unwanted loading state, but that's not nearly as bad\n      // as getting stuck in an infinite rendering loop because we kept calling\n      // queryInstance.fetchData for the same Query component indefinitely.\n      this.lookupQueryInfo(queryInstance).seen = true;\n      promises.push(promise);\n    });\n    this.queryPromises.clear();\n    return Promise.all(promises);\n  }\n\n  private lookupQueryInfo<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ): QueryInfo {\n    const { queryInfoTrie } = this;\n    const { query, variables } = props;\n    const varMap = queryInfoTrie.get(query) || new Map<string, QueryInfo>();\n    if (!queryInfoTrie.has(query)) queryInfoTrie.set(query, varMap);\n    const variablesString = JSON.stringify(variables);\n    const info = varMap.get(variablesString) || makeDefaultQueryInfo();\n    if (!varMap.has(variablesString)) varMap.set(variablesString, info);\n    return info;\n  }\n}\n","import React, { Fragment } from \"react\";\r\n\r\nconst blocksMap: Record<\r\n  string,\r\n  React.LazyExoticComponent<React.FunctionComponent<any>>\r\n> = {\r\n  \"c1-footer\": React.lazy(() => import(\"./Footer\")),\r\n  \"c2-hero\": React.lazy(() => import(\"./Hero\")),\r\n  \"c3-articles-list\": React.lazy(() => import(\"./ArticlesList\")),\r\n  \"c4-call-to-action\": React.lazy(() => import(\"./CallToAction\")),\r\n  \"c5-featured-events\": React.lazy(() => import(\"./FeaturedEvents\")),\r\n  \"c6-partners\": React.lazy(() => import(\"./Partners\")),\r\n  \"c7-header\": React.lazy(() => import(\"./Header\")),\r\n  \"c8-quickscan-profile-hero\": React.lazy(() =>\r\n    import(\"./QuickscanProfileHero\")\r\n  ),\r\n  \"c9-quickscan-profile-sidebar\": React.lazy(() =>\r\n    import(\"./QuickscanProfileSidebar\")\r\n  ),\r\n  \"c10-quickscan-profile-body\": React.lazy(() =>\r\n    import(\"./QuickscanProfileBody\")\r\n  ),\r\n  \"c11-rich-text\": React.lazy(() => import(\"./RichText\"))\r\n};\r\n\r\ntype BlockRendererProps = {\r\n  blocks: { type: string; data: any }[];\r\n  context?: any;\r\n};\r\n\r\nconst BlockRenderer: React.FC<BlockRendererProps> = ({ blocks, context }) => (\r\n  <Fragment>\r\n    {blocks.map(block => {\r\n      const Component = blocksMap[block.type];\r\n\r\n      if (!Component) {\r\n        throw new Error(`Block ${block.type} does not exist`);\r\n      }\r\n\r\n      return <Component {...context} {...block.data} key={block.type} />;\r\n    })}\r\n  </Fragment>\r\n);\r\n\r\nexport default BlockRenderer;\r\n","enum StatusCode {\r\n  NotFound = \"NOT_FOUND\"\r\n}\r\n\r\nexport default StatusCode;\r\n","import styled from \"styled-components\";\r\n\r\nexport { default as BlockRenderer } from \"../../components/blocks\";\r\nexport { default as SplashScreen } from \"../../components/general/SplashScreen\";\r\nexport { Circle } from \"../../util/layout\";\r\n\r\nexport const ContactCta = styled.div``;\r\n","const footer = {\r\n  type: \"c1-footer\",\r\n  data: {\r\n    socialNetworks: [\r\n      {\r\n        uuid: \"1\",\r\n        image: {\r\n          src: \"/socialNetworks/linkedIn.svg\",\r\n          alt: \"LinkedIn logo\",\r\n          fallbackColor: \"transparent\"\r\n        },\r\n        link: {\r\n          href: \"https://www.linkedin.com/company/studata/\",\r\n          children: \"LinkedIn\",\r\n          title: \"LinkedIn\",\r\n          target: \"_blank\"\r\n        }\r\n      }\r\n    ],\r\n    sitemap: [\r\n      {\r\n        uuid: \"2\",\r\n        tag: \"Blog\",\r\n        links: [\r\n          {\r\n            uuid: \"1\",\r\n            href: \"/article\",\r\n            children: \"Blog\",\r\n            title: \"Blog\",\r\n            target: \"_self\"\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        uuid: \"3\",\r\n        tag: \"Algemeen\",\r\n        links: [\r\n          {\r\n            uuid: \"1\",\r\n            href: \"/algemene-voorwaarden\",\r\n            children: \"Algemene voorwaarden\",\r\n            title: \"Algemene voorwaarden\",\r\n            target: \"_self\"\r\n          },\r\n          {\r\n            uuid: \"2\",\r\n            href: \"/privacy-policy\",\r\n            children: \"Privacy policy\",\r\n            title: \"Privacy policy\",\r\n            target: \"_self\"\r\n          }\r\n        ]\r\n      }\r\n    ],\r\n    disclaimer: \"Data Science Platform - Copyright 2019\"\r\n  }\r\n};\r\n\r\nexport default [\r\n  {\r\n    scoreRange: [0, 14.4],\r\n    blocks: [\r\n      {\r\n        type: \"c8-quickscan-profile-hero\",\r\n        data: {\r\n          eyebrow: \"Fase 1\",\r\n          title: \"Prerequisites to analytical competition\",\r\n          subtitle:\r\n            \"18 tot 36 maanden voordat er relevante inzichten uit de data worden gehaald en de organisatie in fase 1 zit.\"\r\n        }\r\n      },\r\n      {\r\n        type: \"c9-quickscan-profile-sidebar\",\r\n        data: {\r\n          title: \"Uw bedrijf\"\r\n        }\r\n      },\r\n      {\r\n        type: \"c10-quickscan-profile-body\",\r\n        data: {\r\n          body: [\r\n            {\r\n              uuid: \"1\",\r\n              type: \"rt-bold\",\r\n              children:\r\n                \"De organisatie beschikt over relevante data en het management heeft enige interesse in data analytics. Organisaties in deze fase zijn opzoek naar verklaringen voor behaalde resultaten door maken gebruik van standaard rapportages. Data analyse initiatieven vinden in deze fase op tactisch niveau plaats en hebben weinig impact op de organisatie of resultaten.\\n\\n\"\r\n            },\r\n            {\r\n              uuid: \"2\",\r\n              type: \"rt-regular\",\r\n              children:\r\n                \"Beslissingen worden genomen door te kijken naar het verleden. Het gaat hier over de vraag wat er in het verleden is voorgevallen, waarbij gebruik gemaakt wordt van een selectie aan data dat beschikbaar en relevant is. Hierin speelt data kwaliteit vaak nog een belangrijke rol, data zou niet alleen relevant maar ook betrouwbaar (volledig, accuraat en consistent) moeten zijn.\\n\\nVoor deze organisaties is het belangrijk om eerst de relevante, transactionele data (omgeving) op orde te krijgen. Betrouwbare data is nodig om beslissingen te kunnen nemen. Daarnaast is de steun van het management nodig om datagedreven beslissingen te nemen en dit ook te stimuleren.\\n\\nVoorbeelden zijn financiele rapportages met daarin omzetcijfers, of overzichten van de beschikbare capaciteit dat in het verleden ingezet is voor productie.\"\r\n            }\r\n          ]\r\n        }\r\n      },\r\n      footer\r\n    ]\r\n  },\r\n  {\r\n    scoreRange: [14.4, 20.8],\r\n    blocks: [\r\n      {\r\n        type: \"c8-quickscan-profile-hero\",\r\n        data: {\r\n          eyebrow: \"Fase 2\",\r\n          title: \"Prove it\",\r\n          subtitle:\r\n            \"1 tot 3 jaar voordat data analytics zich binnen de organisatie bewezen heeft, middels kleinschalig opgezette analyse projecten.\"\r\n        }\r\n      },\r\n      {\r\n        type: \"c9-quickscan-profile-sidebar\",\r\n        data: {\r\n          title: \"Uw bedrijf\"\r\n        }\r\n      },\r\n      {\r\n        type: \"c10-quickscan-profile-body\",\r\n        data: {\r\n          body: [\r\n            {\r\n              uuid: \"1\",\r\n              type: \"rt-bold\",\r\n              children:\r\n                \"In fase 2 wordt analytics door individuelen of bepaalde afdelingen uitgevoerd op verzoek van het management. Beslissingen worden genomen door te kijken naar het verleden, aan de hand van historische data dat intern beschikbaar, relevant en betrouwbaar is. Fase 1 en 2 worden daarom wel de 'eerste stappen in analytics' genoemd.  Er is nog geen organisatie brede aanpak op gebied van data analytics geformuleerd.  In deze fase wordt besloten of een organisatie verder gaat op gebied van data analyse of dat het niet meer ondersteunt wordt door het management. De uitkomsten van de projecten leiden of tot een bredere aanpak op management level voor de inzetbaarheid van data analyses, of er is geen management support en wordt er besloten het niet breder op te pakken binnen de organisatie.\\n\\n\"\r\n            },\r\n            {\r\n              uuid: \"2\",\r\n              type: \"rt-regular\",\r\n              children:\r\n                \"Er worden vragen gesteld waarom bepaalde voorvallen hebben plaatsgevonden, waarop een data analyse wordt uitgevoerd. Deze data wordt handmatig geselecteerd, verzameld en gestructureerd. De analyse projecten zijn relatief kleinschalig/korte termijn, gebaseerd op een test-en-leer aanpak. Daarbij is analytics nog een experimenteel project. Expertise op het gebied van data science is er/ontwikkeld en er worden data science tools toegepast.\\n\\nEen voorbeeld van fase 2 is een analyse waarbij er gekeken is naar de factoren die een rol hebben gespeeld in de verlaging van de productiviteit. De data voor dit verkennend onderzoek zijn handmatig verzameld, gestructureerd en middels tools geanalyseerd.\"\r\n            }\r\n          ]\r\n        }\r\n      },\r\n      footer\r\n    ]\r\n  },\r\n  {\r\n    scoreRange: [20.8, 27.2],\r\n    blocks: [\r\n      {\r\n        type: \"c8-quickscan-profile-hero\",\r\n        data: {\r\n          eyebrow: \"Fase 3\",\r\n          title: \"Analytical aspirations\",\r\n          subtitle:\r\n            \"Het kan een paar maanden tot twee jaar duren voordat de organisatie zich in fase 3 bevindt.\"\r\n        }\r\n      },\r\n      {\r\n        type: \"c9-quickscan-profile-sidebar\",\r\n        data: {\r\n          title: \"Uw bedrijf\"\r\n        }\r\n      },\r\n      {\r\n        type: \"c10-quickscan-profile-body\",\r\n        data: {\r\n          body: [\r\n            {\r\n              uuid: \"1\",\r\n              type: \"rt-bold\",\r\n              children:\r\n                \"Binnen deze fase wordt er met een bredere, strategische kijk gekeken naar de toepassing van data analytics. Beslisnemers binnen de organisatie zijn overtuigd van data analytics en een datagedreven cultuur, er wordt tijd en middelen aan besteedt en er is een planning opgezet voor het uitvoeren van data analyse projecten. De organisatie heeft haar eerste grote data analyse project opgezet en gefaciliteerd. Het (technisch) integreren en standaardiseren van organisatie data is een belangrijk onderdeel van deze fase.\\n\\n\"\r\n            },\r\n            {\r\n              uuid: \"2\",\r\n              type: \"rt-regular\",\r\n              children:\r\n                \"In fase 3 weet men aan de hand van data analyses wat er is voorgevallen, waarom het is voorgevallen en wat er op het moment (live) gebeurt. Tijdige, onderbouwde beslissingen kunnen worden genomen gebaseerd op actuele en beschikbare data.\\n\\nOrganisaties kijken in fase 3 naast historische data ook naar live rapportages. Relevante data is bedrijfsbreed vastgesteld, wordt automatisch verzameld en gestructureerd (buiten afdelingsgrenzen, middels bijvoorbeeld een datawarehouse), waarop vervolgens er automatisch dashboards gegenereerd worden. De data wordt dus niet meer, zoals in vorige fasen wel het geval is, handmatig verzameld en gestructureerd.\\n\\nEen voorbeeld van fase 3 kan zijn dat er een set aan automatisch gegenereerde dashboards zijn die voor verschillende afdelingen inzichten geven. Hieronder vallen financiele dashboards maar ook operationele dashboards van zowel interne als externe (Google Analytics) data.\"\r\n            }\r\n          ]\r\n        }\r\n      },\r\n      footer\r\n    ]\r\n  },\r\n  {\r\n    scoreRange: [27.2, 33.6],\r\n    blocks: [\r\n      {\r\n        type: \"c8-quickscan-profile-hero\",\r\n        data: {\r\n          eyebrow: \"Fase 4\",\r\n          title: \"Analytical companies\"\r\n        }\r\n      },\r\n      {\r\n        type: \"c9-quickscan-profile-sidebar\",\r\n        data: {\r\n          title: \"Uw bedrijf\"\r\n        }\r\n      },\r\n      {\r\n        type: \"c10-quickscan-profile-body\",\r\n        data: {\r\n          body: [\r\n            {\r\n              uuid: \"1\",\r\n              type: \"rt-bold\",\r\n              children:\r\n                \"Data analytics krijgt vanuit het management prioriteit en de organisatie implementeert een breed opgezet plan op gebied van data analyse projecten. Daarnaast is de organisatie beter ingesteld op data analytics, zijn er meer ambassadeurs die het ondersteunen/stimuleren, en is datagedreven werken opgenomen in de cultuur. Analisten en data scientists worden effectief ingezet op hun specifieke kennis en kunde. Men focust zich op het continue verbeteren van de analyses, het uitbreiden van data science binnen de organisatie, en wil graag haar concurrentievoordeel er mee behalen.\\n\\n\"\r\n            },\r\n            {\r\n              uuid: \"2\",\r\n              type: \"rt-regular\",\r\n              children:\r\n                \"Fase 4 gebruikt historische, beschrijvende data van de fasen ervoor om te komen tot voorspellende waarde. Het gaat 1 stap verder door de historische data te gebruiken, en daarnaast te komen tot een voorspelling voor de toekomst. Hierdoor kan er accurater worden ingespeeld op bijvoorbeeld voorraadbeheer, planningsvraagstukken, budgettering en risico analyses.\\n\\nVoorspellende waarde geeft inzicht in de relevante knoppen waaraan gedraaid kan worden om invloed uit te oefenen op een bepaald onderdeel. Bijvoorbeeld hoeveel voorraad er besteld moet worden voor de top 10 klanten of voor bepaalde klantsegmenten, of wanneer medewerkers naar een klant toe moeten voor het repareren van een bepaald onderdeel.\"\r\n            }\r\n          ]\r\n        }\r\n      },\r\n      footer\r\n    ]\r\n  },\r\n  {\r\n    scoreRange: [33.6, 40],\r\n    blocks: [\r\n      {\r\n        type: \"c8-quickscan-profile-hero\",\r\n        data: {\r\n          eyebrow: \"Fase 5\",\r\n          title: \"Analytical competitors\"\r\n        }\r\n      },\r\n      {\r\n        type: \"c9-quickscan-profile-sidebar\",\r\n        data: {\r\n          title: \"Uw bedrijf\"\r\n        }\r\n      },\r\n      {\r\n        type: \"c10-quickscan-profile-body\",\r\n        data: {\r\n          body: [\r\n            {\r\n              uuid: \"1\",\r\n              type: \"rt-bold\",\r\n              children:\r\n                \"Data analytics wordt gezien als cruciaal voor de strategie van de organisatie en het behalen van concurrentievoordeel. Data projecten hebben geresulteerd in het verbeteren van de organisatie en data is een cruciaal onderdeel in het behalen van concurrentievoordeel.\\n\\n\"\r\n            },\r\n            {\r\n              uuid: \"2\",\r\n              type: \"rt-regular\",\r\n              children:\r\n                \"Een kleine greep van de organisaties (Google, Amazon, LinkedIn) zit in de laatste fase op gebied van data analytics. Deze fase gebruikt historische data en voorspellende waarde om te komen tot voorschrijvende inzichten (wat is de 'next practise'?). Hierin is data onderdeel van het management, het geeft richting in wat er moet gebeuren om strategische doelstellingen te behalen.\\n\\nIn fase 5 wordt er structureel (middels bijvoorbeeld machine learning) gezocht naar nieuwe relevante data en inzichten. Er is dus niet eenmalig gekeken naar voorspellende waarden, maar er is een model opgezet dat zichzelf blijft vernieuwen/verbeteren, om zo bijvoorbeeld de klantbehoeften steeds beter te kunnen voorspellen.\"\r\n            }\r\n          ]\r\n        }\r\n      },\r\n      footer\r\n    ]\r\n  }\r\n];\r\n","import React, { useContext, useMemo } from \"react\";\r\nimport { Redirect, useParams } from \"react-router\";\r\nimport { useQuery } from \"@apollo/react-hooks\";\r\nimport { loader } from \"graphql.macro\";\r\nimport {\r\n  Context as StorageContext,\r\n  StorageKey\r\n} from \"../../components/context/StorageManager\";\r\nimport StatusCode from \"../../data/StatusCode\";\r\nimport RoutePath from \"../../data/RoutePath\";\r\nimport { SplashScreen, BlockRenderer } from \"./styled\";\r\n\r\n// Static data\r\nimport profiles from \"./profiles\";\r\n\r\nconst quickscanProfileQuery = loader(\"./quickscanProfile.graphql\");\r\n\r\ntype GraphQLResponse = {\r\n  quickScanResult: IQuickScanResult;\r\n};\r\n\r\nconst QuickScanProfile = () => {\r\n  const storage = useContext(StorageContext);\r\n\r\n  // Create variables for graphql query\r\n  const { uuid } = useParams();\r\n\r\n  // Process query\r\n  const { data, error } = useQuery<GraphQLResponse>(quickscanProfileQuery, {\r\n    variables: { uuid }\r\n  });\r\n\r\n  const profile = useMemo(() => {\r\n    if (!data) {\r\n      return undefined;\r\n    }\r\n\r\n    const score = data.quickScanResult.answers.reduce(\r\n      (accumulator, current) => accumulator + current.value,\r\n      0\r\n    );\r\n\r\n    return profiles\r\n      .sort((a, b) => a.scoreRange[1] - b.scoreRange[1])\r\n      .find(profile => profile.scoreRange[1] > score);\r\n  }, [data]);\r\n\r\n  if (error) {\r\n    const notFound = error.graphQLErrors.some(error => error.extensions!.code === StatusCode.NotFound);\r\n\r\n    // Clear key and redirect to quick scan if profile does not exist\r\n    if (notFound) {\r\n      storage.removeValue(StorageKey.QuickScanResultUuid);\r\n\r\n      return <Redirect to={RoutePath.QuickScan} />;\r\n    }\r\n\r\n    throw error;\r\n  }\r\n\r\n  if (!profile) {\r\n    return <SplashScreen />;\r\n  }\r\n\r\n  return <BlockRenderer {...profile} context={profile} />;\r\n};\r\n\r\nexport default QuickScanProfile;\r\n","export { default } from \"./QuickScanProfile\";\r\n"],"sourceRoot":""}