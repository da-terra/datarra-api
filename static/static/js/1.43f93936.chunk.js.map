{"version":3,"sources":["../node_modules/tiny-warning/dist/tiny-warning.esm.js","../node_modules/slate/node_modules/is-plain-object/index.js","../node_modules/slate/node_modules/isobject/index.js","../node_modules/slate/dist/index.es.js","../node_modules/compute-scroll-into-view/es/index.js","../node_modules/scroll-into-view-if-needed/es/index.js","../node_modules/slate-react/node_modules/is-plain-object/index.js","../node_modules/slate-react/node_modules/isobject/index.js","../node_modules/slate-react/dist/index.es.js","../node_modules/slate-history/node_modules/is-plain-object/index.js","../node_modules/slate-history/node_modules/isobject/index.js","../node_modules/slate-history/dist/index.es.js","../node_modules/debounce/index.js","../node_modules/direction/index.js","../node_modules/is-hotkey/lib/index.js","../node_modules/slate/node_modules/immer/dist/immer.module.js","../node_modules/esrever/esrever.js","../node_modules/webpack/buildin/module.js"],"names":["isProduction","condition","message","text","console","warn","Error","x","isObjectObject","o","val","Array","isArray","Object","prototype","toString","call","isPlainObject","ctor","prot","constructor","hasOwnProperty","arrayWithoutHoles","arr","i","arr2","length","iterableToArray","iter","Symbol","iterator","from","nonIterableSpread","TypeError","toConsumableArray","arrayWithHoles","iterableToArrayLimit","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","value","err","nonIterableRest","slicedToArray","defineProperty","obj","key","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","apply","_objectSpread","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","DIRTY_PATHS","WeakMap","GeneralTransforms","normalize","editor","options","_options$force","force","Editor","isNormalizing","allPaths","Node","nodes","_ref","set","getDirtyPaths","withoutNormalizing","max","m","concat","path","pop","entry","node","normalizeNode","transform","op","children","selection","type","mark","leaf","Mark","exists","marks","_path","_node","parent","index","splice","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Range","points","_step$value","point","Point","_path2","offset","_node2","before","slice","after","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_step2$value","_point","_path3","_node3","get","prevPath","Path","previous","prev","_parent","_index","Text","isText","_prev$children","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_step3$value","_point2","_path4","newPath","isAncestor","_node4","_parent2","_index2","truePath","newParent","newIndex","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_step4$value","_point3","_path5","_mark","_node5","matches","_path6","_index3","_parent3","_Node$texts","texts","reverse","_prev","_Node$texts3","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_step5$value","_point4","_key4","result","_prev2","prevNode","_prevPath","nextPath","newNextPath","_path7","_offset","_text","_node6","_before","_after","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","_step6$value","_point5","_path8","properties","newProperties","_node7","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","_mark2","assign","_path9","_newProperties","_node8","_newProperties2","isRange","JSON","stringify","_path10","position","_properties","newNode","_node9","_parent4","_index4","_before2","_after2","_before3","_after3","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","_step8$value","_point6","FLUSHING","createEditor","operations","isInline","isVoid","onChange","pathRefs","ref","PathRef","pointRefs","PointRef","rangeRefs","_ref2","RangeRef","Set","dirtyPaths","add","join","has","oldDirtyPaths","newDirtyPaths","getDirtyPaths$1","Promise","resolve","then","exec","command","Command","isCoreCommand","addMarks","isCollapsed","unit","isExpanded","splitNodes","always","insertFragment","fragment","insertNodes","insertText","removeMarks","_entry","Element","isElement","at","shouldHaveInlines","isEditor","n","_child","isLast","mergeNodes","removeNodes","levels","descendants","_ref3","p","ancestors","previousPath","equals","oldAncestors","newAncestors","ancestor","_ancestor","_p","_ancestors","_levels","isCommand","isAddMarkCommand","isMark","isDeleteBackwardCommand","isDeleteForwardCommand","isDeleteFragmentCommand","isInsertTextCommand","isInsertFragmentCommand","isInsertBreakCommand","isRemoveMarkCommand","isNodeList","isInsertNodeCommand","isNode","ElementQueries","hasBlocks","element","some","hasInlines","hasTexts","every","isEmpty","first","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","GeneralQueries","Operation","isOperationList","pathRef","_options$affinity","affinity","current","unref","refs","pointRef","_options$affinity2","rangeRef","range","_options$affinity3","fn","createCommonjsModule","module","exports","_typeof_1","_typeof2","_typeof","regenerator","runtime","undefined$1","Op","hasOwn","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","GenStateSuspendedYield","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","previousPromise","callInvokeWithMethodAndArg","reject","invoke","__await","unwrapped","error","info","resultName","nextLoc","pushTryEntry","locs","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","name","setPrototypeOf","__proto__","awrap","async","skipTempReset","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","ownKeys$1","_objectSpread$1","LocationQueries","activeMarks","mode","union","continuing","anchor","edge","focus","end","_options$distance","distance","d","positions","isPath","isPoint","ancestorPath","start","_options$distance2","edges","elements","_args","_context","t0","isStart","isEnd","isEdge","last","_options$at","_options$reverse","_args2","_context2","match","_options$mode","_options$reverse2","_options$continuing","_options$at2","universalMarks","distinctMarks","universalEntries","_loop","_ret","_args4","_context4","isSibling","isMatch","existing","markEntry","_context3","map","v","t1","t2","_match","_options$at3","_options$reverse3","_step7$value","_context5","compare","_Editor$last","_Editor$last3","span","_options$at4","_options$mode2","_options$reverse4","to","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_iterator9","_step9","_prev3","_entry2","_args6","_context6","Span","isSpan","pass","_ref5","parentPath","depth","_Node$first","_Node$first2","firstPath","_Node$last","_Node$last2","lastPath","common","_options$edge","_Node$last3","_Node$last4","_Node$first3","_Node$first4","_Range$edges","_Range$edges2","_options$at5","_options$unit","_options$reverse5","reverse$1","_Range$edges3","_Range$edges4","string","available","isNewBlock","advance","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_iterator10","_step10","_step10$value","e","s","isFirst","_args7","_context7","getCharacterDistance","getWordDistance","_Editor$first","_Editor$first3","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_step11","_iterator11","_Range$edges5","_Range$edges6","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_step12","_iterator12","_step12$value","t","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_iterator13","_step13","_step13$value","_args8","_context8","SPACE","PUNCTUATION","CHAMELEON","isWordCharacter","_char","remaining","test","code","charCodeAt","_char2","started","l","rest","MarkTransforms","splitLocation","_m","setMarks","props","newProps","k","_options$hanging","hanging","unhangRange","select","objectWithoutPropertiesLoose","excluded","sourceKeys","indexOf","objectWithoutProperties","sourceSymbolKeys","propertyIsEnumerable","ownKeys$2","_objectSpread$2","NodeTransforms","atMatch","matchPath","isAtEnd","liftNodes","_pathRefs","_Editor$node","_Editor$node2","moveNodes","_options$hanging2","_ref7","prevMatch","_current","commonPath","isPreviousSibling","emptyAncestor","furthest","_ref9","_ref10","isDescendant","emptyRef","_rest","_ref11","toRef","targets","_i2","_pathRefs2","_ref13","_options$hanging3","_ref15","depths","_i3","_pathRefs3","_ref17","_Editor$node3","setNodes","_options$hanging4","_ref19","_options$at6","_options$height","height","_options$always","deleteRange","_ref21","beforeRef","highest","voidMatch","_voidMatch","voidNode","voidPath","afterPath","afterRef","highestPath","lowestPath","split","unwrapNodes","_options$at7","_options$split","_ref23","_ref25","_pathRefs4","_i4","intersection","_ref27","wrapNodes","_options$split2","_options$at8","_ref29","roots","rootPath","a","wrapperPath","wrapper","_ref31","_Range$edges7","ownKeys$3","_objectSpread$3","closestBlock","blockPath","skip","isBefore","collapse","deselect","move","_options$edge2","isBackward","opts","setSelection","setPoint","_options$edge3","newPoint","oldProps","furthestVoid","_Editor$ancestor","isSingleText","startVoid","endVoid","block","_block","isCommon","startRef","endRef","_Editor$leaf","_Editor$leaf3","isBlockAncestor","inlineElementMatch","_inlinePath","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","matcher","_ref6","starts","middles","ends","starting","_matches","inlineMatch","inlinePath","isInlineStart","isInlineEnd","middleRef","_end","_at","isElementList","find","f","isMarkSet","root","child","c","closest","predicate","another","descendant","_args3","r","includes","_leaf","_args5","_options$from","visited","nextIndex","_newPath","isAfter","_step9$value","ownKeys$4","_objectSpread$4","isNodeOperation","isOperation","endsWith","isMarkOperation","isSelectionOperation","isTextOperation","inverse","paths","av","min","Math","endsAfter","as","bs","bv","endsAt","endsBefore","isChild","isParent","list","relative","operation","_op","_op2","_op3","_position","_op4","onp","copy","ownKeys$5","_objectSpread$5","ownKeys$6","isRangeList","isRangeMap","rs","re","ts","te","_Range$edges8","isAfterStart","isBeforeEnd","_Range$edges9","_Range$edges10","s1","e1","_Range$edges11","_Range$edges12","s2","e2","_objectSpread$6","isForward","_Range$edges13","affinityAnchor","affinityFocus","isTextList","el","nodeType","canOverflow","overflow","skipOverflowHiddenElements","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","style","getComputedStyle","overflowY","overflowX","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","scrollMode","inline","boundary","checkBoundary","scrollingElement","document","documentElement","frames","cursor","parentNode","body","viewportWidth","window","visualViewport","width","innerWidth","viewportHeight","innerHeight","viewportX","scrollX","pageXOffset","viewportY","scrollY","pageYOffset","_target$getBoundingCl","getBoundingClientRect","targetHeight","targetWidth","targetTop","top","targetRight","right","targetBottom","bottom","targetLeft","left","targetBlock","targetInline","computations","frame","_frame$getBoundingCli","_height","_width","_top","_left","frameStyle","borderLeft","parseInt","borderLeftWidth","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","blockScroll","inlineScroll","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","scrollLeft","scrollTop","isOptionsObject","targetIsDetached","ownerDocument","contains","behavior","computeOptions","getOptions","actions","canSmoothScroll","scroll","defaultBehavior","ReactEditor","findPath","createElement","isTrailing","isLineBreak","_props$isTrailing","_props$length","_props$isLineBreak","Leaf","decorations","isLeaf","other","NODE_TO_INDEX","NODE_TO_PARENT","EDITOR_TO_ELEMENT","NODE_TO_ELEMENT","ELEMENT_TO_NODE","NODE_TO_KEY","KEY_TO_ELEMENT","IS_READ_ONLY","IS_FOCUSED","PLACEHOLDER_SYMBOL","MemoizedLeaf","memo","_props$renderDecorati","renderDecoration","_props$renderMark","renderMark","ret","attributes","return","decoration","placeholder","contentEditable","pointerEvents","display","verticalAlign","maxWidth","whiteSpace","opacity","leaves","compile","middle","_Leaf$split","_Leaf$split2","_Leaf$split3","_Leaf$split4","MemoizedText","findKey","id","delete","SelectedContext","MemoizedElement","decorate","_props$renderElement","renderElement","readOnly","dir","Tag","_Node$1$texts","_Node$1$texts2","color","outline","Provider","EditorContext","isLeafBlock","_n2","sel","ds","dec","Fragment","IS_APPLE","navigator","userAgent","MSStream","IS_FIREFOX","IS_SAFARI","HOTKEYS","bold","compose","moveBackward","moveForward","moveWordBackward","moveWordForward","deleteBackward","deleteForward","extendBackward","extendForward","italic","splitBlock","undo","APPLE_HOTKEYS","moveLineBackward","moveLineForward","deleteLineBackward","deleteLineForward","deleteWordBackward","deleteWordForward","extendLineBackward","extendLineForward","redo","transposeCharacter","WINDOWS_HOTKEYS","generic","apple","windows","isGeneric","isApple","isWindows","event","Hotkeys","isBold","isCompose","isMoveBackward","isMoveForward","isDeleteBackward","isDeleteForward","isDeleteLineBackward","isDeleteLineForward","isDeleteWordBackward","isDeleteWordForward","isExtendBackward","isExtendForward","isExtendLineBackward","isExtendLineForward","isItalic","isMoveLineBackward","isMoveLineForward","isMoveWordBackward","isMoveWordForward","isRedo","isSplitBlock","isTransposeCharacter","isUndo","ReadOnlyContext","classCallCheck","instance","Constructor","Key","isDOMElement","isDOMNode","isDOMText","getEditableChild","direction","childNodes","triedForward","triedBackward","getAttribute","unshift","isFocused","isReadOnly","blur","toDOMNode","activeElement","preventScroll","domSelection","getSelection","rangeCount","removeAllRanges","hasDOMNode","_options$editable","editable","parentElement","isContentEditable","domNode","toDOMPoint","domPoint","_texts","querySelectorAll","textContent","attr","toDOMRange","domAnchor","domFocus","domRange","createRange","setStart","setEnd","toSlateNode","domEl","hasAttribute","findEventRange","nativeEvent","_event","clientX","y","clientY","rect","isPrev","caretRangeFromPoint","caretPositionFromPoint","offsetNode","toSlateRange","toSlatePoint","_normalizeDOMPoint","_domPoint","normalizeDOMPoint","_normalizeDOMPoint2","nearestNode","nearestOffset","textNode","leafNode","contents","cloneContents","removeChild","querySelector","slateNode","anchorNode","anchorOffset","focusNode","focusOffset","Selection","startContainer","startOffset","endContainer","endOffset","collapsed","FocusedContext","EDITOR_TO_CONTEXT_LISTENER","SlateContext","_props$defaultValue","defaultValue","_props$onChange","_useState","_useState2","setContext","listener","_props$decorate","defaultDecorate","_props$readOnly","_props$style","propsOnDOMBeforeInput","onDOMBeforeInput","isComposing","isUpdatingSelection","latestElement","addEventListener","onDOMSelectionChange","removeEventListener","hasDomSelection","newDomRange","isRangeEqual","getRangeAt","addRange","leafEl","setTimeout","hasEditableTarget","isDOMEventHandled","inputType","data","dataTransfer","preventDefault","startsWith","_event$getTargetRange","getTargetRanges","targetRange","DataTransfer","_decorations$push","role","spellCheck","autoCorrect","autoCapitalize","suppressContentEditableWarning","wordWrap","onBeforeInput","onBlur","isEventHandled","relatedTarget","onClick","hasTarget","_start","onCompositionEnd","onCompositionStart","onCopy","clipboardData","onCut","onDragOver","onDragStart","onDrop","files","onFocus","onKeyDown","onPaste","b","handler","isDefaultPrevented","isPropagationStopped","defaultPrevented","attach","trim","cloneRange","setEndAfter","zw","isNewline","appendChild","encoded","btoa","encodeURIComponent","setAttribute","setData","div","innerHTML","getPlainText","nodeValue","_Array$from","getPropertyValue","tagName","ReactCommand","isInsertDataCommand","isReactCommand","_key","_matches$_i","_key2","getData","decoded","decodeURIComponent","atob","parsed","parse","lines","line","contextOnChange","History","redos","undos","HistoryCommand","isHistoryCommand","isRedoCommand","isUndoCommand","SAVING","MERGING","HistoryEditor","isHistoryEditor","history","isMerging","isSaving","withoutMerging","withoutSaving","batch","_batch","inverseOps","lastBatch","lastOp","overwrite","shouldOverwrite","save","merge","shouldSave","shift","shouldClear","debounce","func","wait","immediate","timeout","args","timestamp","later","Date","now","debounced","callNow","clear","clearTimeout","flush","String","rtl","ltr","LTR","RegExp","IS_MAC","platform","MODIFIERS","alt","control","meta","ALIASES","break","cmd","ctl","ctrl","del","down","esc","ins","mod","opt","option","space","spacebar","up","win","CODES","backspace","tab","enter","pause","capslock","escape","pageup","pagedown","home","arrowleft","arrowup","arrowright","arrowdown","insert","numlock","scrolllock","'","isHotkey","hotkey","array","parseHotkey","check","compareHotkey","byKey","replace","optional","toKeyName","modifier","which","toKeyCode","expected","actual","toLowerCase","toUpperCase","default","isCodeHotkey","isKeyHotkey","NOTHING","DRAFTABLE","for","DRAFT_STATE","isDraft","isDraftable","proto","isMap","isSet","original","base","overrides","len","override","Reflect","getOwnPropertyNames","shallowCopy","invokeGetters","Map","clone","desc","each","isEnumerable","prop","thing","is","hasSymbol","hasMap","hasSet","makeIterable","iterateMapValues","receiver","isEntries","latest","makeIterateSetValues","createProxy","draft","drafts","finalized","finalizing","modified","wrapSetValue","cloned","freeze","deep","isFrozen","dontMutateFrozenCollections","_","ImmerScope","canAutoFreeze","patches","revoke","clonePotentialDraft","mapTraps","proxyMethod","setTraps","iterateSetValues","proxySet","descriptors","assertUnrevoked","peek","latest$1","prepareCopy","get$1","assigned","markChanged","proxyProperty","scope","revoke$1","revoked","createHiddenProperty","usePatches","patchListener","inversePatches","leave","finalizeTraps","size","reciever","cb","entries","thisArg","traps","reduce","acc","builder","proxyAttr","trap","markChangesSweep","hasArrayChanges","hasMapChanges","hasSetChanges","hasObjectChanges","baseValue","state$1","descriptor","hasChanges","obj$1","obj$1$1","legacyProxy","willFinalize","isReplaced","markChangesRecursively","i$1","i$2","createProxy$1","objectTraps","arrayTraps","mapTraps$1","setTraps$1","Proxy","revocable","proxy","latest$2","peek$1","markChanged$1","deleteProperty","owner","reflectTraps","makeTrapsForGetters","iterateSetValues$1","assignMap","getters","modernProxy","generateArrayPatches","basePath","assign$1","delta","replaceCount","path$1","generatePatchesFromAssigned","assignedValue","origValue","generateSetPatches","list$1","value$1","applyPatches","patch","configDefaults","useProxies","autoFreeze","process","onAssign","onDelete","Immer","config","setUseProxies","produce","bind","produceWithPatches","recipe","this$1","defaultBase","hasError","processResult","maybeFreeze","arg1","arg2","arg3","ip","createDraft","isManual","finishDraft","setAutoFreeze","baseDraft","finalize","finalizeTree","generatePatches","needPatches","finalizeProperty","isDraftProp","isSetMember","immer","freeExports","freeGlobal","global","regexSymbolWithCombiningMarks","regexSurrogatePair","esrever","$0","$1","$2","webpackPolyfill","deprecate"],"mappings":"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","file":"static/js/1.43f93936.chunk.js","sourcesContent":["var isProduction = process.env.NODE_ENV === 'production';\n\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\nimport isObject from 'isobject';\n\nfunction isObjectObject(o) {\n  return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport default function isPlainObject(o) {\n  var ctor, prot;\n  if (isObjectObject(o) === false) return false; // If has modified constructor\n\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false; // If has modified prototype\n\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false; // If constructor does not have an Object-specific method\n\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n;","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\nexport default function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n}\n;","import { createDraft, finishDraft, isDraft, produce } from 'immer';\nimport isPlainObject from 'is-plain-object';\nimport warning from 'tiny-warning';\nimport { reverse } from 'esrever';\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nvar arrayWithoutHoles = _arrayWithoutHoles;\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nvar iterableToArray = _iterableToArray;\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar nonIterableSpread = _nonIterableSpread;\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nvar toConsumableArray = _toConsumableArray;\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar arrayWithHoles = _arrayWithHoles;\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nvar iterableToArrayLimit = _iterableToArrayLimit;\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar nonIterableRest = _nonIterableRest;\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nvar slicedToArray = _slicedToArray;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defineProperty = _defineProperty;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar DIRTY_PATHS = new WeakMap();\nvar GeneralTransforms = {\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\n  normalize: function normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$force = options.force,\n        force = _options$force === void 0 ? false : _options$force;\n\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n\n    if (force) {\n      var allPaths = Array.from(Node.nodes(editor), function (_ref) {\n        var _ref2 = slicedToArray(_ref, 2),\n            p = _ref2[1];\n\n        return p;\n      });\n      DIRTY_PATHS.set(editor, allPaths);\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return;\n    }\n\n    Editor.withoutNormalizing(editor, function () {\n      var max = getDirtyPaths(editor).length * 42; // HACK: better way to do editor?\n\n      var m = 0;\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(\"\\n            Could not completely normalize the editor after \".concat(max, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\\n          \"));\n        }\n\n        var path = getDirtyPaths(editor).pop();\n        var entry = Editor.node(editor, path);\n        editor.normalizeNode(entry);\n        m++;\n      }\n    });\n  },\n\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform: function transform(editor, op) {\n    editor.children = createDraft(editor.children);\n    var selection = editor.selection && createDraft(editor.selection);\n\n    switch (op.type) {\n      case 'add_mark':\n        {\n          var path = op.path,\n              mark = op.mark;\n          var node = Node.leaf(editor, path);\n\n          if (!Mark.exists(mark, node.marks)) {\n            node.marks.push(mark);\n          }\n\n          break;\n        }\n\n      case 'insert_node':\n        {\n          var _path = op.path,\n              _node = op.node;\n          var parent = Node.parent(editor, _path);\n          var index = _path[_path.length - 1];\n          parent.children.splice(index, 0, _node);\n\n          if (selection) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = Range.points(selection)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var _step$value = slicedToArray(_step.value, 2),\n                    point = _step$value[0],\n                    key = _step$value[1];\n\n                selection[key] = Point.transform(point, op);\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                  _iterator[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'insert_text':\n        {\n          var _path2 = op.path,\n              offset = op.offset,\n              text = op.text;\n\n          var _node2 = Node.leaf(editor, _path2);\n\n          var before = _node2.text.slice(0, offset);\n\n          var after = _node2.text.slice(offset);\n\n          _node2.text = before + text + after;\n\n          if (selection) {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = Range.points(selection)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var _step2$value = slicedToArray(_step2.value, 2),\n                    _point = _step2$value[0],\n                    _key = _step2$value[1];\n\n                selection[_key] = Point.transform(_point, op);\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                  _iterator2[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var _path3 = op.path;\n\n          var _node3 = Node.get(editor, _path3);\n\n          var prevPath = Path.previous(_path3);\n          var prev = Node.get(editor, prevPath);\n\n          var _parent = Node.parent(editor, _path3);\n\n          var _index = _path3[_path3.length - 1];\n\n          if (Text.isText(_node3) && Text.isText(prev)) {\n            prev.text += _node3.text;\n          } else if (!Text.isText(_node3) && !Text.isText(prev)) {\n            var _prev$children;\n\n            (_prev$children = prev.children).push.apply(_prev$children, toConsumableArray(_node3.children));\n          } else {\n            throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path3, \"] to nodes of different interaces: \").concat(_node3, \" \").concat(prev));\n          }\n\n          _parent.children.splice(_index, 1);\n\n          if (selection) {\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n              for (var _iterator3 = Range.points(selection)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var _step3$value = slicedToArray(_step3.value, 2),\n                    _point2 = _step3$value[0],\n                    _key2 = _step3$value[1];\n\n                selection[_key2] = Point.transform(_point2, op);\n              }\n            } catch (err) {\n              _didIteratorError3 = true;\n              _iteratorError3 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n                  _iterator3[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError3) {\n                  throw _iteratorError3;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          var _path4 = op.path,\n              newPath = op.newPath;\n\n          if (Path.isAncestor(_path4, newPath)) {\n            throw new Error(\"Cannot move a path [\".concat(_path4, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n          }\n\n          var _node4 = Node.get(editor, _path4);\n\n          var _parent2 = Node.parent(editor, _path4);\n\n          var _index2 = _path4[_path4.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n          // the same snapshot in time, there's a mismatch. After either\n          // removing the original position, the second step's path can be out\n          // of date. So instead of using the `op.newPath` directly, we\n          // transform `op.path` to ascertain what the `newPath` would be after\n          // the operation was applied.\n\n          _parent2.children.splice(_index2, 1);\n\n          var truePath = Path.transform(_path4, op);\n          var newParent = Node.get(editor, Path.parent(truePath));\n          var newIndex = truePath[truePath.length - 1];\n          newParent.children.splice(newIndex, 0, _node4);\n\n          if (selection) {\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n              for (var _iterator4 = Range.points(selection)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                var _step4$value = slicedToArray(_step4.value, 2),\n                    _point3 = _step4$value[0],\n                    _key3 = _step4$value[1];\n\n                selection[_key3] = Point.transform(_point3, op);\n              }\n            } catch (err) {\n              _didIteratorError4 = true;\n              _iteratorError4 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n                  _iterator4[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError4) {\n                  throw _iteratorError4;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_mark':\n        {\n          var _path5 = op.path,\n              _mark = op.mark;\n\n          var _node5 = Node.leaf(editor, _path5);\n\n          for (var i = 0; i < _node5.marks.length; i++) {\n            if (Mark.matches(_node5.marks[i], _mark)) {\n              _node5.marks.splice(i, 1);\n\n              break;\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_node':\n        {\n          var _path6 = op.path;\n          var _index3 = _path6[_path6.length - 1];\n\n          var _parent3 = Node.parent(editor, _path6);\n\n          var _Node$texts = Node.texts(editor, {\n            from: _path6,\n            reverse: true\n          }),\n              _Node$texts2 = slicedToArray(_Node$texts, 2),\n              _prev = _Node$texts2[1];\n\n          var _Node$texts3 = Node.texts(editor, {\n            from: _path6\n          }),\n              _Node$texts4 = slicedToArray(_Node$texts3, 2),\n              next = _Node$texts4[1];\n\n          _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n          // node that was removed we need to update the range or remove it.\n\n\n          if (selection) {\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n              for (var _iterator5 = Range.points(selection)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var _step5$value = slicedToArray(_step5.value, 2),\n                    _point4 = _step5$value[0],\n                    _key4 = _step5$value[1];\n\n                var result = Point.transform(_point4, op);\n\n                if (selection != null && result != null) {\n                  selection[_key4] = result;\n                } else if (_prev) {\n                  var _prev2 = slicedToArray(_prev, 2),\n                      prevNode = _prev2[0],\n                      _prevPath = _prev2[1];\n\n                  _point4.path = _prevPath;\n                  _point4.offset = prevNode.text.length;\n                } else if (next) {\n                  var _next = slicedToArray(next, 2),\n                      nextPath = _next[1];\n\n                  var newNextPath = Path.transform(nextPath, op);\n                  _point4.path = newNextPath;\n                  _point4.offset = 0;\n                } else {\n                  selection = null;\n                }\n              }\n            } catch (err) {\n              _didIteratorError5 = true;\n              _iteratorError5 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n                  _iterator5[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError5) {\n                  throw _iteratorError5;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_text':\n        {\n          var _path7 = op.path,\n              _offset = op.offset,\n              _text = op.text;\n\n          var _node6 = Node.leaf(editor, _path7);\n\n          var _before = _node6.text.slice(0, _offset);\n\n          var _after = _node6.text.slice(_offset + _text.length);\n\n          _node6.text = _before + _after;\n\n          if (selection) {\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n              for (var _iterator6 = Range.points(selection)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                var _step6$value = slicedToArray(_step6.value, 2),\n                    _point5 = _step6$value[0],\n                    _key5 = _step6$value[1];\n\n                selection[_key5] = Point.transform(_point5, op);\n              }\n            } catch (err) {\n              _didIteratorError6 = true;\n              _iteratorError6 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n                  _iterator6[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError6) {\n                  throw _iteratorError6;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'set_mark':\n        {\n          var _path8 = op.path,\n              properties = op.properties,\n              newProperties = op.newProperties;\n\n          var _node7 = Node.leaf(editor, _path8);\n\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = _node7.marks[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var _mark2 = _step7.value;\n\n              if (Mark.matches(_mark2, properties)) {\n                Object.assign(_mark2, newProperties);\n                break;\n              }\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n                _iterator7[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'set_node':\n        {\n          var _path9 = op.path,\n              _newProperties = op.newProperties;\n\n          if (_path9.length === 0) {\n            throw new Error(\"Cannot set properties on the root node!\");\n          }\n\n          var _node8 = Node.get(editor, _path9);\n\n          Object.assign(_node8, _newProperties);\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var _newProperties2 = op.newProperties;\n\n          if (_newProperties2 == null) {\n            selection = _newProperties2;\n          } else if (selection == null) {\n            if (!Range.isRange(_newProperties2)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(JSON.stringify(_newProperties2), \" when there is no current selection.\"));\n            }\n\n            selection = _newProperties2;\n          } else {\n            Object.assign(selection, _newProperties2);\n          }\n\n          break;\n        }\n\n      case 'split_node':\n        {\n          var _path10 = op.path,\n              position = op.position,\n              _properties = op.properties;\n\n          if (_path10.length === 0) {\n            throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path10, \"] because the root node cannot be split.\"));\n          }\n\n          var _node9 = Node.get(editor, _path10);\n\n          var _parent4 = Node.parent(editor, _path10);\n\n          var _index4 = _path10[_path10.length - 1];\n          var newNode;\n\n          if (Text.isText(_node9)) {\n            var _before2 = _node9.text.slice(0, position);\n\n            var _after2 = _node9.text.slice(position);\n\n            _node9.text = _before2;\n            newNode = _objectSpread({}, _node9, {}, _properties, {\n              text: _after2\n            });\n          } else {\n            var _before3 = _node9.children.slice(0, position);\n\n            var _after3 = _node9.children.slice(position);\n\n            _node9.children = _before3;\n            newNode = _objectSpread({}, _node9, {}, _properties, {\n              children: _after3\n            });\n          }\n\n          _parent4.children.splice(_index4 + 1, 0, newNode);\n\n          if (selection) {\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n            var _iteratorError8 = undefined;\n\n            try {\n              for (var _iterator8 = Range.points(selection)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                var _step8$value = slicedToArray(_step8.value, 2),\n                    _point6 = _step8$value[0],\n                    _key6 = _step8$value[1];\n\n                selection[_key6] = Point.transform(_point6, op);\n              }\n            } catch (err) {\n              _didIteratorError8 = true;\n              _iteratorError8 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion8 && _iterator8[\"return\"] != null) {\n                  _iterator8[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError8) {\n                  throw _iteratorError8;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n    }\n\n    editor.children = finishDraft(editor.children);\n\n    if (selection) {\n      editor.selection = isDraft(selection) ? finishDraft(selection) : selection;\n    }\n  }\n};\n\nvar getDirtyPaths = function getDirtyPaths(editor) {\n  return DIRTY_PATHS.get(editor) || [];\n};\n\nvar FLUSHING = new WeakMap();\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\nvar createEditor = function createEditor() {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    isInline: function isInline() {\n      return false;\n    },\n    isVoid: function isVoid() {\n      return false;\n    },\n    onChange: function onChange() {},\n    apply: function apply(op) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = Editor.pathRefs(editor)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var ref = _step.value;\n          PathRef.transform(ref, op);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = Editor.pointRefs(editor)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _ref = _step2.value;\n          PointRef.transform(_ref, op);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = Editor.rangeRefs(editor)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _ref2 = _step3.value;\n          RangeRef.transform(_ref2, op);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var set = new Set();\n      var dirtyPaths = [];\n\n      var add = function add(path) {\n        if (path) {\n          var key = path.join(',');\n\n          if (!set.has(key)) {\n            set.add(key);\n            dirtyPaths.push(path);\n          }\n        }\n      };\n\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var newDirtyPaths = getDirtyPaths$1(op);\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = oldDirtyPaths[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var path = _step4.value;\n          var newPath = Path.transform(path, op);\n          add(newPath);\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n            _iterator4[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = newDirtyPaths[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _path = _step5.value;\n          add(_path);\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n            _iterator5[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      Editor.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor);\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(function () {\n          FLUSHING.set(editor, false);\n          editor.onChange(editor.children, editor.operations);\n          editor.operations = [];\n        });\n      }\n    },\n    exec: function exec(command) {\n      var selection = editor.selection;\n\n      if (Command.isCoreCommand(command)) {\n        switch (command.type) {\n          case 'add_mark':\n            {\n              Editor.addMarks(editor, command.mark);\n              break;\n            }\n\n          case 'delete_backward':\n            {\n              if (selection && Range.isCollapsed(selection)) {\n                Editor[\"delete\"](editor, {\n                  unit: command.unit,\n                  reverse: true\n                });\n              }\n\n              break;\n            }\n\n          case 'delete_forward':\n            {\n              if (selection && Range.isCollapsed(selection)) {\n                Editor[\"delete\"](editor, {\n                  unit: command.unit\n                });\n              }\n\n              break;\n            }\n\n          case 'delete_fragment':\n            {\n              if (selection && Range.isExpanded(selection)) {\n                Editor[\"delete\"](editor);\n              }\n\n              break;\n            }\n\n          case 'insert_break':\n            {\n              Editor.splitNodes(editor, {\n                always: true\n              });\n              break;\n            }\n\n          case 'insert_fragment':\n            {\n              Editor.insertFragment(editor, command.fragment);\n              break;\n            }\n\n          case 'insert_node':\n            {\n              Editor.insertNodes(editor, [command.node]);\n              break;\n            }\n\n          case 'insert_text':\n            {\n              Editor.insertText(editor, command.text);\n              break;\n            }\n\n          case 'remove_mark':\n            {\n              Editor.removeMarks(editor, [command.mark]);\n              break;\n            }\n        }\n      }\n    },\n    normalizeNode: function normalizeNode(entry) {\n      var _entry = slicedToArray(entry, 2),\n          node = _entry[0],\n          path = _entry[1]; // There are no core normalizations for text nodes.\n\n\n      if (Text.isText(node)) {\n        return;\n      } // Ensure that block and inline nodes have at least one text child.\n\n\n      if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: '',\n          marks: []\n        };\n        Editor.insertNodes(editor, child, {\n          at: path.concat(0)\n        });\n        return;\n      } // Determine whether the node should have block or inline children.\n\n\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n\n      var n = 0;\n\n      for (var i = 0; i < node.children.length; i++, n++) {\n        var _child = node.children[i];\n        var prev = node.children[i - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n\n        if (isInlineOrText !== shouldHaveInlines) {\n          Editor.removeNodes(editor, {\n            at: path.concat(n)\n          });\n          n--;\n          continue;\n        }\n\n        if (Element.isElement(_child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: '',\n                marks: []\n              };\n              Editor.insertNodes(editor, newChild, {\n                at: path.concat(n)\n              });\n              n++;\n              continue;\n            }\n\n            if (isLast) {\n              var _newChild = {\n                text: '',\n                marks: []\n              };\n              Editor.insertNodes(editor, _newChild, {\n                at: path.concat(n + 1)\n              });\n              n++;\n              continue;\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or have matching marks.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.matches(_child, prev)) {\n              Editor.mergeNodes(editor, {\n                at: path.concat(n)\n              });\n              n--;\n              continue;\n            } else if (prev.text === '') {\n              Editor.removeNodes(editor, {\n                at: path.concat(n - 1)\n              });\n              n--;\n              continue;\n            } else if (isLast && _child.text === '') {\n              Editor.removeNodes(editor, {\n                at: path.concat(n)\n              });\n              n--;\n              continue;\n            }\n          }\n        }\n      }\n    }\n  };\n  return editor;\n};\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */\n\n\nvar getDirtyPaths$1 = function getDirtyPaths(op) {\n  switch (op.type) {\n    case 'add_mark':\n    case 'insert_text':\n    case 'remove_mark':\n    case 'remove_text':\n    case 'set_mark':\n    case 'set_node':\n      {\n        var path = op.path;\n        return Path.levels(path);\n      }\n\n    case 'insert_node':\n      {\n        var node = op.node,\n            _path2 = op.path;\n        var levels = Path.levels(_path2);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), function (_ref3) {\n          var _ref4 = slicedToArray(_ref3, 2),\n              p = _ref4[1];\n\n          return _path2.concat(p);\n        });\n        return [].concat(toConsumableArray(levels), toConsumableArray(descendants));\n      }\n\n    case 'merge_node':\n      {\n        var _path3 = op.path;\n        var ancestors = Path.ancestors(_path3);\n        var previousPath = Path.previous(_path3);\n        return [].concat(toConsumableArray(ancestors), [previousPath]);\n      }\n\n    case 'move_node':\n      {\n        var _path4 = op.path,\n            newPath = op.newPath;\n\n        if (Path.equals(_path4, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = [];\n        var newAncestors = [];\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = Path.ancestors(_path4)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var ancestor = _step6.value;\n            var p = Path.transform(ancestor, op);\n            oldAncestors.push(p);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n              _iterator6[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = Path.ancestors(newPath)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var _ancestor = _step7.value;\n\n            var _p = Path.transform(_ancestor, op);\n\n            newAncestors.push(_p);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n              _iterator7[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n\n        return [].concat(oldAncestors, newAncestors);\n      }\n\n    case 'remove_node':\n      {\n        var _path5 = op.path;\n\n        var _ancestors = Path.ancestors(_path5);\n\n        return toConsumableArray(_ancestors);\n      }\n\n    case 'split_node':\n      {\n        var _path6 = op.path;\n\n        var _levels = Path.levels(_path6);\n\n        var nextPath = Path.next(_path6);\n        return [].concat(toConsumableArray(_levels), [nextPath]);\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nvar Command = {\n  /**\r\n   * Check if a value is a `Command` object.\r\n   */\n  isCommand: function isCommand(value) {\n    return isPlainObject(value) && typeof value.type === 'string';\n  },\n\n  /**\r\n   * Check if a value is an `AddMarkCommand` object.\r\n   */\n  isAddMarkCommand: function isAddMarkCommand(value) {\n    return Command.isCommand(value) && value.type === 'add_mark' && Mark.isMark(value.mark);\n  },\n\n  /**\r\n   * Check if a value is a `CoreCommand` object.\r\n   */\n  isCoreCommand: function isCoreCommand(value) {\n    return Command.isAddMarkCommand(value) || Command.isDeleteBackwardCommand(value) || Command.isDeleteForwardCommand(value) || Command.isDeleteFragmentCommand(value) || Command.isInsertTextCommand(value) || Command.isInsertFragmentCommand(value) || Command.isInsertBreakCommand(value) || Command.isRemoveMarkCommand(value);\n  },\n\n  /**\r\n   * Check if a value is a `DeleteBackwardCommand` object.\r\n   */\n  isDeleteBackwardCommand: function isDeleteBackwardCommand(value) {\n    return Command.isCommand(value) && value.type === 'delete_backward' && typeof value.unit === 'string';\n  },\n\n  /**\r\n   * Check if a value is a `DeleteForwardCommand` object.\r\n   */\n  isDeleteForwardCommand: function isDeleteForwardCommand(value) {\n    return Command.isCommand(value) && value.type === 'delete_forward' && typeof value.unit === 'string';\n  },\n\n  /**\r\n   * Check if a value is a `DeleteFragmentCommand` object.\r\n   */\n  isDeleteFragmentCommand: function isDeleteFragmentCommand(value) {\n    return Command.isCommand(value) && value.type === 'delete_fragment';\n  },\n\n  /**\r\n   * Check if a value is an `InsertBreakCommand` object.\r\n   */\n  isInsertBreakCommand: function isInsertBreakCommand(value) {\n    return Command.isCommand(value) && value.type === 'insert_break';\n  },\n\n  /**\r\n   * Check if a value is an `InsertFragmentCommand` object.\r\n   */\n  isInsertFragmentCommand: function isInsertFragmentCommand(value) {\n    return Command.isCommand(value) && value.type === 'insert_fragment' && Node.isNodeList(value.fragment);\n  },\n\n  /**\r\n   * Check if a value is an `InsertNodeCommand` object.\r\n   */\n  isInsertNodeCommand: function isInsertNodeCommand(value) {\n    return Command.isCommand(value) && value.type === 'insert_node' && Node.isNode(value.node);\n  },\n\n  /**\r\n   * Check if a value is a `InsertTextCommand` object.\r\n   */\n  isInsertTextCommand: function isInsertTextCommand(value) {\n    return Command.isCommand(value) && value.type === 'insert_text' && typeof value.text === 'string';\n  },\n\n  /**\r\n   * Check if a value is a `RemoveMarkCommand` object.\r\n   */\n  isRemoveMarkCommand: function isRemoveMarkCommand(value) {\n    return Command.isCommand(value) && value.type === 'remove_mark' && Mark.isMark(value.mark);\n  }\n};\nvar ElementQueries = {\n  /**\r\n   * Check if a node has block children.\r\n   */\n  hasBlocks: function hasBlocks(editor, element) {\n    return element.children.some(function (n) {\n      return Element.isElement(n) && !editor.isInline(n);\n    });\n  },\n\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\n  hasInlines: function hasInlines(editor, element) {\n    return element.children.some(function (n) {\n      return Text.isText(n) || Element.isElement(n) && editor.isInline(n);\n    });\n  },\n\n  /**\r\n   * Check if a node has text children.\r\n   */\n  hasTexts: function hasTexts(editor, element) {\n    return element.children.every(function (n) {\n      return Text.isText(n);\n    });\n  },\n\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\n  isEmpty: function isEmpty(editor, element) {\n    var children = element.children;\n\n    var _children = slicedToArray(children, 1),\n        first = _children[0];\n\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n  }\n};\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\nvar GeneralQueries = {\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\n  isEditor: function isEditor(value) {\n    return isPlainObject(value) && typeof value.apply === 'function' && typeof value.exec === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n  },\n\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\n  isNormalizing: function isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pathRef: function pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n    var ref = {\n      current: path,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\n  pathRefs: function pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      PATH_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pointRef: function pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity2 = options.affinity,\n        affinity = _options$affinity2 === void 0 ? 'forward' : _options$affinity2;\n    var ref = {\n      current: point,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\n  pointRefs: function pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      POINT_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  rangeRef: function rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity3 = options.affinity,\n        affinity = _options$affinity3 === void 0 ? 'forward' : _options$affinity3;\n    var ref = {\n      current: range,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\n  rangeRefs: function rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\n  withoutNormalizing: function withoutNormalizing(editor, fn) {\n    var value = Editor.isNormalizing(editor);\n    NORMALIZING.set(editor, false);\n    fn();\n    NORMALIZING.set(editor, value);\n    Editor.normalize(editor);\n  }\n};\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar _typeof_1 = createCommonjsModule(function (module) {\n  function _typeof2(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof2 = function _typeof2(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof2 = function _typeof2(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof2(obj);\n  }\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n      module.exports = _typeof = function _typeof(obj) {\n        return _typeof2(obj);\n      };\n    } else {\n      module.exports = _typeof = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  module.exports = _typeof;\n});\n\nvar runtime_1 = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n  var runtime = function (exports) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1; // More compressible than void 0.\n\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n\n    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n\n    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n\n    function Generator() {}\n\n    function GeneratorFunction() {}\n\n    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n\n\n    var IteratorPrototype = {};\n\n    IteratorPrototype[iteratorSymbol] = function () {\n      return this;\n    };\n\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n    GeneratorFunctionPrototype.constructor = GeneratorFunction;\n    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        prototype[method] = function (arg) {\n          return this._invoke(method, arg);\n        };\n      });\n    }\n\n    exports.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n\n    exports.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n\n        if (!(toStringTagSymbol in genFun)) {\n          genFun[toStringTagSymbol] = \"GeneratorFunction\";\n        }\n      }\n\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    }; // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n\n\n    exports.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n\n    function AsyncIterator(generator) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return Promise.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n\n          return Promise.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n\n      var previousPromise;\n\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new Promise(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n\n        return previousPromise = // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      } // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n\n\n      this._invoke = enqueue;\n    }\n\n    defineIteratorMethods(AsyncIterator.prototype);\n\n    AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n      return this;\n    };\n\n    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n\n    exports.async = function (innerFn, outerFn, self, tryLocsList) {\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));\n      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          } // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n          return doneResult();\n        }\n\n        context.method = method;\n        context.arg = arg;\n\n        while (true) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted; // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    } // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n\n      if (method === undefined$1) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n\n        if (context.method === \"throw\") {\n          // Note: [\"return\"] must be used for ES3 parsing compatibility.\n          if (delegate.iterator[\"return\"]) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n\n        return ContinueSentinel;\n      }\n\n      var record = tryCatch(method, delegate.iterator, context.arg);\n\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      var info = record.arg;\n\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n        context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      } // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n\n\n      context.delegate = null;\n      return ContinueSentinel;\n    } // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n\n\n    defineIteratorMethods(Gp);\n    Gp[toStringTagSymbol] = \"Generator\"; // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n    Gp[iteratorSymbol] = function () {\n      return this;\n    };\n\n    Gp.toString = function () {\n      return \"[object Generator]\";\n    };\n\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n\n      this.tryEntries.push(entry);\n    }\n\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n\n    exports.keys = function (object) {\n      var keys = [];\n\n      for (var key in object) {\n        keys.push(key);\n      }\n\n      keys.reverse(); // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        } // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n\n\n        next.done = true;\n        return next;\n      };\n    };\n\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n              next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n\n            next.value = undefined$1;\n            next.done = true;\n            return next;\n          };\n\n          return next.next = next;\n        }\n      } // Return an iterator with no values.\n\n\n      return {\n        next: doneResult\n      };\n    }\n\n    exports.values = values;\n\n    function doneResult() {\n      return {\n        value: undefined$1,\n        done: true\n      };\n    }\n\n    Context.prototype = {\n      constructor: Context,\n      reset: function reset(skipTempReset) {\n        this.prev = 0;\n        this.next = 0; // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function stop() {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n\n        return this.rval;\n      },\n      dispatchException: function dispatchException(exception) {\n        if (this.done) {\n          throw exception;\n        }\n\n        var context = this;\n\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n\n          return !!caught;\n        }\n\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function abrupt(type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n\n        return this.complete(record);\n      },\n      complete: function complete(record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n\n        return ContinueSentinel;\n      },\n      finish: function finish(finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function _catch(tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n\n            return thrown;\n          }\n        } // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n\n\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined$1;\n        }\n\n        return ContinueSentinel;\n      }\n    }; // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n\n    return exports;\n  }( // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports);\n\n  try {\n    regeneratorRuntime = runtime;\n  } catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n});\nvar regenerator = runtime_1;\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$1(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar LocationQueries = {\n  /**\r\n   * Get the marks that are \"active\" at a location. These are the\r\n   * marks that will be added to any text that is inserted.\r\n   *\r\n   * The `union: true` option can be passed to create a union of marks across\r\n   * the text nodes in the selection, instead of creating an intersection, which\r\n   * is the default.\r\n   *\r\n   * Note: to obey common rich text behavior, if the selection is collapsed at\r\n   * the start of a text node and there are previous text nodes in the same\r\n   * block, it will carry those marks forward from the previous text node. This\r\n   * allows for continuation of marks from previous words.\r\n   */\n  activeMarks: function activeMarks(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    warning(false, 'The `Editor.activeMarks` helper is deprecated, use `Editor.marks` instead.');\n    return Array.from(Editor.marks(editor, {\n      at: options.at,\n      mode: options.union ? 'distinct' : 'universal',\n      continuing: true\n    }), function (_ref) {\n      var _ref2 = slicedToArray(_ref, 1),\n          m = _ref2[0];\n\n      return m;\n    });\n  },\n\n  /**\r\n   * Get the point after a location.\r\n   */\n  after: function after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: 'end'\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance = options.distance,\n        distance = _options$distance === void 0 ? 1 : _options$distance;\n    var d = 0;\n    var target;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Editor.positions(editor, _objectSpread$1({}, options, {\n        at: range\n      }))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var p = _step.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the common ancestor node of a location.\r\n   */\n  ancestor: function ancestor(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (Path.isPath(at) || Point.isPoint(at)) {\n      return Editor.parent(editor, at, options);\n    }\n\n    var path = Editor.path(editor, at, options);\n    var ancestorPath = Path.equals(at.anchor.path, at.focus.path) ? Path.parent(path) : path;\n    var ancestor = Node.get(editor, ancestorPath);\n    return [ancestor, ancestorPath];\n  },\n\n  /**\r\n   * Get the point before a location.\r\n   */\n  before: function before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: 'start'\n    });\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance2 = options.distance,\n        distance = _options$distance2 === void 0 ? 1 : _options$distance2;\n    var d = 0;\n    var target;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = Editor.positions(editor, _objectSpread$1({}, options, {\n        at: range,\n        reverse: true\n      }))[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var p = _step2.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the start and end points of a location.\r\n   */\n  edges: function edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n\n  /**\r\n   * Iterate through all of the elements in the Editor.\r\n   */\n  elements:\n  /*#__PURE__*/\n  regenerator.mark(function elements(editor) {\n    var options,\n        _iteratorNormalCompletion3,\n        _didIteratorError3,\n        _iteratorError3,\n        _iterator3,\n        _step3,\n        _step3$value,\n        node,\n        path,\n        _args = arguments;\n\n    return regenerator.wrap(function elements$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            _iteratorNormalCompletion3 = true;\n            _didIteratorError3 = false;\n            _iteratorError3 = undefined;\n            _context.prev = 4;\n            _iterator3 = this.nodes(editor, options)[Symbol.iterator]();\n\n          case 6:\n            if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n              _context.next = 14;\n              break;\n            }\n\n            _step3$value = slicedToArray(_step3.value, 2), node = _step3$value[0], path = _step3$value[1];\n\n            if (!Element.isElement(node)) {\n              _context.next = 11;\n              break;\n            }\n\n            _context.next = 11;\n            return [node, path];\n\n          case 11:\n            _iteratorNormalCompletion3 = true;\n            _context.next = 6;\n            break;\n\n          case 14:\n            _context.next = 20;\n            break;\n\n          case 16:\n            _context.prev = 16;\n            _context.t0 = _context[\"catch\"](4);\n            _didIteratorError3 = true;\n            _iteratorError3 = _context.t0;\n\n          case 20:\n            _context.prev = 20;\n            _context.prev = 21;\n\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n\n          case 23:\n            _context.prev = 23;\n\n            if (!_didIteratorError3) {\n              _context.next = 26;\n              break;\n            }\n\n            throw _iteratorError3;\n\n          case 26:\n            return _context.finish(23);\n\n          case 27:\n            return _context.finish(20);\n\n          case 28:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, elements, this, [[4, 16, 20, 28], [21,, 23, 27]]);\n  }),\n\n  /**\r\n   * Get the end point of a location.\r\n   */\n  end: function end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'end'\n    });\n  },\n\n  /**\r\n   * Get the first node at a location.\r\n   */\n  first: function first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the fragment at a location.\r\n   */\n  fragment: function fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node.fragment(editor, range);\n    return fragment;\n  },\n\n  /**\r\n   * Check if a point the start point of a location.\r\n   */\n  isStart: function isStart(editor, point, at) {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false;\n    }\n\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n  },\n\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\n  isEnd: function isEnd(editor, point, at) {\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n  },\n\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\n  isEdge: function isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n\n  /**\r\n   * Get the last node at a location.\r\n   */\n  last: function last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\n  leaf: function leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\n  levels:\n  /*#__PURE__*/\n  regenerator.mark(function levels(editor) {\n    var options,\n        _options$at,\n        at,\n        _options$reverse,\n        reverse,\n        levels,\n        path,\n        _iteratorNormalCompletion4,\n        _didIteratorError4,\n        _iteratorError4,\n        _iterator4,\n        _step4,\n        _step4$value,\n        n,\n        p,\n        _args2 = arguments;\n\n    return regenerator.wrap(function levels$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            _options$at = options.at, at = _options$at === void 0 ? editor.selection : _options$at, _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;\n\n            if (at) {\n              _context2.next = 4;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 4:\n            levels = [];\n            path = Editor.path(editor, at);\n            _iteratorNormalCompletion4 = true;\n            _didIteratorError4 = false;\n            _iteratorError4 = undefined;\n            _context2.prev = 9;\n            _iterator4 = Node.levels(editor, path)[Symbol.iterator]();\n\n          case 11:\n            if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n              _context2.next = 19;\n              break;\n            }\n\n            _step4$value = slicedToArray(_step4.value, 2), n = _step4$value[0], p = _step4$value[1];\n            levels.push([n, p]);\n\n            if (!(Element.isElement(n) && editor.isVoid(n))) {\n              _context2.next = 16;\n              break;\n            }\n\n            return _context2.abrupt(\"break\", 19);\n\n          case 16:\n            _iteratorNormalCompletion4 = true;\n            _context2.next = 11;\n            break;\n\n          case 19:\n            _context2.next = 25;\n            break;\n\n          case 21:\n            _context2.prev = 21;\n            _context2.t0 = _context2[\"catch\"](9);\n            _didIteratorError4 = true;\n            _iteratorError4 = _context2.t0;\n\n          case 25:\n            _context2.prev = 25;\n            _context2.prev = 26;\n\n            if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n              _iterator4[\"return\"]();\n            }\n\n          case 28:\n            _context2.prev = 28;\n\n            if (!_didIteratorError4) {\n              _context2.next = 31;\n              break;\n            }\n\n            throw _iteratorError4;\n\n          case 31:\n            return _context2.finish(28);\n\n          case 32:\n            return _context2.finish(25);\n\n          case 33:\n            if (reverse) {\n              levels.reverse();\n            }\n\n            return _context2.delegateYield(levels, \"t1\", 35);\n\n          case 35:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, levels, null, [[9, 21, 25, 33], [26,, 28, 32]]);\n  }),\n\n  /**\r\n   * Iterate through all of the text nodes in the Editor.\r\n   */\n  marks:\n  /*#__PURE__*/\n  regenerator.mark(function marks(editor) {\n    var options,\n        match,\n        _options$mode,\n        mode,\n        _options$reverse2,\n        reverse,\n        _options$continuing,\n        continuing,\n        _options$at2,\n        at,\n        _at,\n        anchor,\n        prev,\n        _prev,\n        prevPath,\n        universalMarks,\n        distinctMarks,\n        universalEntries,\n        first,\n        _iteratorNormalCompletion5,\n        _didIteratorError5,\n        _iteratorError5,\n        _loop,\n        _iterator5,\n        _step5,\n        _ret,\n        _args4 = arguments;\n\n    return regenerator.wrap(function marks$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n            match = options.match, _options$mode = options.mode, mode = _options$mode === void 0 ? 'all' : _options$mode, _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2, _options$continuing = options.continuing, continuing = _options$continuing === void 0 ? false : _options$continuing;\n            _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2;\n\n            if (at) {\n              _context4.next = 5;\n              break;\n            }\n\n            return _context4.abrupt(\"return\");\n\n          case 5:\n            // If the range is collapsed at the start of a text node, it should continue\n            // the marks from the previous text node in the same block.\n            if (continuing && Range.isRange(at) && Range.isCollapsed(at) && at.anchor.offset === 0) {\n              _at = at, anchor = _at.anchor;\n              prev = Editor.previous(editor, anchor, 'text');\n\n              if (prev && Path.isSibling(anchor.path, prev[1])) {\n                _prev = slicedToArray(prev, 2), prevPath = _prev[1];\n                at = Editor.range(editor, prevPath);\n              }\n            }\n\n            universalMarks = [];\n            distinctMarks = [];\n            universalEntries = [];\n            first = true;\n            _iteratorNormalCompletion5 = true;\n            _didIteratorError5 = false;\n            _iteratorError5 = undefined;\n            _context4.prev = 13;\n            _loop =\n            /*#__PURE__*/\n            regenerator.mark(function _loop() {\n              var entry, _entry, node, path, isMatch, i, existing, index, mark, markEntry;\n\n              return regenerator.wrap(function _loop$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      entry = _step5.value;\n                      _entry = slicedToArray(entry, 2), node = _entry[0], path = _entry[1];\n\n                      isMatch = function isMatch(m, entry) {\n                        if (typeof m === 'function') {\n                          return m(entry);\n                        } else {\n                          return Mark.matches(entry[0], m);\n                        }\n                      };\n\n                      if (!(mode === 'universal')) {\n                        _context3.next = 14;\n                        break;\n                      }\n\n                      if (!first) {\n                        _context3.next = 9;\n                        break;\n                      }\n\n                      universalMarks.push.apply(universalMarks, toConsumableArray(node.marks));\n                      universalEntries = node.marks.map(function (m, i) {\n                        return [m, i, node, path];\n                      });\n                      first = false;\n                      return _context3.abrupt(\"return\", \"continue\");\n\n                    case 9:\n                      if (!(universalMarks.length === 0)) {\n                        _context3.next = 11;\n                        break;\n                      }\n\n                      return _context3.abrupt(\"return\", {\n                        v: void 0\n                      });\n\n                    case 11:\n                      for (i = universalMarks.length - 1; i >= 0; i--) {\n                        existing = universalMarks[i];\n\n                        if (!Mark.exists(existing, node.marks)) {\n                          universalMarks.splice(i, 1);\n                        }\n                      }\n\n                      _context3.next = 33;\n                      break;\n\n                    case 14:\n                      index = 0;\n\n                    case 15:\n                      if (!(index < node.marks.length)) {\n                        _context3.next = 33;\n                        break;\n                      }\n\n                      mark = node.marks[index];\n                      markEntry = [mark, index, node, path];\n\n                      if (!(match != null && !isMatch(match, markEntry))) {\n                        _context3.next = 20;\n                        break;\n                      }\n\n                      return _context3.abrupt(\"continue\", 30);\n\n                    case 20:\n                      if (!(mode === 'distinct')) {\n                        _context3.next = 26;\n                        break;\n                      }\n\n                      if (!Mark.exists(mark, distinctMarks)) {\n                        _context3.next = 25;\n                        break;\n                      }\n\n                      return _context3.abrupt(\"continue\", 30);\n\n                    case 25:\n                      distinctMarks.push(mark);\n\n                    case 26:\n                      _context3.next = 28;\n                      return markEntry;\n\n                    case 28:\n                      if (!(mode === 'first')) {\n                        _context3.next = 30;\n                        break;\n                      }\n\n                      return _context3.abrupt(\"break\", 33);\n\n                    case 30:\n                      index++;\n                      _context3.next = 15;\n                      break;\n\n                    case 33:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _loop);\n            });\n            _iterator5 = Editor.texts(editor, {\n              reverse: reverse,\n              at: at\n            })[Symbol.iterator]();\n\n          case 16:\n            if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {\n              _context4.next = 28;\n              break;\n            }\n\n            return _context4.delegateYield(_loop(), \"t0\", 18);\n\n          case 18:\n            _ret = _context4.t0;\n            _context4.t1 = _ret;\n            _context4.next = _context4.t1 === \"continue\" ? 22 : 23;\n            break;\n\n          case 22:\n            return _context4.abrupt(\"continue\", 25);\n\n          case 23:\n            if (!(_typeof_1(_ret) === \"object\")) {\n              _context4.next = 25;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", _ret.v);\n\n          case 25:\n            _iteratorNormalCompletion5 = true;\n            _context4.next = 16;\n            break;\n\n          case 28:\n            _context4.next = 34;\n            break;\n\n          case 30:\n            _context4.prev = 30;\n            _context4.t2 = _context4[\"catch\"](13);\n            _didIteratorError5 = true;\n            _iteratorError5 = _context4.t2;\n\n          case 34:\n            _context4.prev = 34;\n            _context4.prev = 35;\n\n            if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n              _iterator5[\"return\"]();\n            }\n\n          case 37:\n            _context4.prev = 37;\n\n            if (!_didIteratorError5) {\n              _context4.next = 40;\n              break;\n            }\n\n            throw _iteratorError5;\n\n          case 40:\n            return _context4.finish(37);\n\n          case 41:\n            return _context4.finish(34);\n\n          case 42:\n            if (!(mode === 'universal')) {\n              _context4.next = 44;\n              break;\n            }\n\n            return _context4.delegateYield(universalEntries, \"t3\", 44);\n\n          case 44:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, marks, null, [[13, 30, 34, 42], [35,, 37, 41]]);\n  }),\n\n  /**\r\n   * Get the first matching node in a single branch of the document.\r\n   */\n  match: function match(editor, at, _match) {\n    var path = Editor.path(editor, at);\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = Editor.levels(editor, {\n        at: path\n      })[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var entry = _step6.value;\n\n        if (Editor.isMatch(editor, entry, _match)) {\n          return entry;\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n          _iterator6[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Iterate through all of the nodes that match.\r\n   */\n  matches:\n  /*#__PURE__*/\n  regenerator.mark(function matches(editor, options) {\n    var _options$at3, at, _options$reverse3, reverse, match, path, prevPath, _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, _step7$value, n, p;\n\n    return regenerator.wrap(function matches$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            warning(false, 'The `Editor.matches` helper is deprecated, use `Editor.nodes` instead.');\n            _options$at3 = options.at, at = _options$at3 === void 0 ? editor.selection : _options$at3, _options$reverse3 = options.reverse, reverse = _options$reverse3 === void 0 ? false : _options$reverse3;\n            match = options.match;\n\n            if (at) {\n              _context5.next = 5;\n              break;\n            }\n\n            return _context5.abrupt(\"return\");\n\n          case 5:\n            if (match == null) {\n              if (Path.isPath(at)) {\n                path = at;\n\n                match = function match(_ref3) {\n                  var _ref4 = slicedToArray(_ref3, 2),\n                      p = _ref4[1];\n\n                  return Path.equals(p, path);\n                };\n              } else {\n                match = function match() {\n                  return true;\n                };\n              }\n            }\n\n            _iteratorNormalCompletion7 = true;\n            _didIteratorError7 = false;\n            _iteratorError7 = undefined;\n            _context5.prev = 9;\n            _iterator7 = Editor.nodes(editor, {\n              at: at,\n              reverse: reverse\n            })[Symbol.iterator]();\n\n          case 11:\n            if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {\n              _context5.next = 22;\n              break;\n            }\n\n            _step7$value = slicedToArray(_step7.value, 2), n = _step7$value[0], p = _step7$value[1];\n\n            if (!(prevPath && Path.compare(p, prevPath) === 0)) {\n              _context5.next = 15;\n              break;\n            }\n\n            return _context5.abrupt(\"continue\", 19);\n\n          case 15:\n            if (!Editor.isMatch(editor, [n, p], match)) {\n              _context5.next = 19;\n              break;\n            }\n\n            prevPath = p;\n            _context5.next = 19;\n            return [n, p];\n\n          case 19:\n            _iteratorNormalCompletion7 = true;\n            _context5.next = 11;\n            break;\n\n          case 22:\n            _context5.next = 28;\n            break;\n\n          case 24:\n            _context5.prev = 24;\n            _context5.t0 = _context5[\"catch\"](9);\n            _didIteratorError7 = true;\n            _iteratorError7 = _context5.t0;\n\n          case 28:\n            _context5.prev = 28;\n            _context5.prev = 29;\n\n            if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n              _iterator7[\"return\"]();\n            }\n\n          case 31:\n            _context5.prev = 31;\n\n            if (!_didIteratorError7) {\n              _context5.next = 34;\n              break;\n            }\n\n            throw _iteratorError7;\n\n          case 34:\n            return _context5.finish(31);\n\n          case 35:\n            return _context5.finish(28);\n\n          case 36:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, matches, null, [[9, 24, 28, 36], [29,, 31, 35]]);\n  }),\n\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\n  next: function next(editor, at, match) {\n    var _Editor$last = Editor.last(editor, at),\n        _Editor$last2 = slicedToArray(_Editor$last, 2),\n        from = _Editor$last2[1];\n\n    var _Editor$last3 = Editor.last(editor, []),\n        _Editor$last4 = slicedToArray(_Editor$last3, 2),\n        to = _Editor$last4[1];\n\n    var span = [from, to];\n    var i = 0;\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      for (var _iterator8 = Editor.nodes(editor, {\n        at: span,\n        match: match,\n        mode: 'highest'\n      })[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var entry = _step8.value;\n\n        if (i === 1) {\n          return entry;\n        }\n\n        i++;\n      }\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8[\"return\"] != null) {\n          _iterator8[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Get the node at a location.\r\n   */\n  node: function node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\n  nodes:\n  /*#__PURE__*/\n  regenerator.mark(function nodes(editor) {\n    var options,\n        _options$at4,\n        at,\n        match,\n        _options$mode2,\n        mode,\n        _options$reverse4,\n        reverse,\n        from,\n        to,\n        first,\n        last,\n        iterable,\n        prev,\n        _iteratorNormalCompletion9,\n        _didIteratorError9,\n        _iteratorError9,\n        _iterator9,\n        _step9,\n        entry,\n        _prev2,\n        _prev3,\n        prevPath,\n        _entry2,\n        path,\n        _args6 = arguments;\n\n    return regenerator.wrap(function nodes$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n            _options$at4 = options.at, at = _options$at4 === void 0 ? editor.selection : _options$at4, match = options.match, _options$mode2 = options.mode, mode = _options$mode2 === void 0 ? 'all' : _options$mode2, _options$reverse4 = options.reverse, reverse = _options$reverse4 === void 0 ? false : _options$reverse4;\n\n            if (at) {\n              _context6.next = 4;\n              break;\n            }\n\n            return _context6.abrupt(\"return\");\n\n          case 4:\n            if (Span.isSpan(at)) {\n              from = at[0];\n              to = at[1];\n            } else {\n              first = Editor.path(editor, at, {\n                edge: 'start'\n              });\n              last = Editor.path(editor, at, {\n                edge: 'end'\n              });\n              from = reverse ? last : first;\n              to = reverse ? first : last;\n            }\n\n            iterable = Node.nodes(editor, {\n              reverse: reverse,\n              from: from,\n              to: to,\n              pass: function pass(_ref5) {\n                var _ref6 = slicedToArray(_ref5, 1),\n                    n = _ref6[0];\n\n                return Element.isElement(n) && editor.isVoid(n);\n              }\n            });\n            _iteratorNormalCompletion9 = true;\n            _didIteratorError9 = false;\n            _iteratorError9 = undefined;\n            _context6.prev = 9;\n            _iterator9 = iterable[Symbol.iterator]();\n\n          case 11:\n            if (_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done) {\n              _context6.next = 27;\n              break;\n            }\n\n            entry = _step9.value;\n\n            if (!(match != null)) {\n              _context6.next = 22;\n              break;\n            }\n\n            if (!(mode === 'highest' && prev)) {\n              _context6.next = 19;\n              break;\n            }\n\n            _prev2 = prev, _prev3 = slicedToArray(_prev2, 2), prevPath = _prev3[1];\n            _entry2 = slicedToArray(entry, 2), path = _entry2[1];\n\n            if (!(Path.compare(path, prevPath) === 0)) {\n              _context6.next = 19;\n              break;\n            }\n\n            return _context6.abrupt(\"continue\", 24);\n\n          case 19:\n            if (Editor.isMatch(editor, entry, match)) {\n              _context6.next = 21;\n              break;\n            }\n\n            return _context6.abrupt(\"continue\", 24);\n\n          case 21:\n            prev = entry;\n\n          case 22:\n            _context6.next = 24;\n            return entry;\n\n          case 24:\n            _iteratorNormalCompletion9 = true;\n            _context6.next = 11;\n            break;\n\n          case 27:\n            _context6.next = 33;\n            break;\n\n          case 29:\n            _context6.prev = 29;\n            _context6.t0 = _context6[\"catch\"](9);\n            _didIteratorError9 = true;\n            _iteratorError9 = _context6.t0;\n\n          case 33:\n            _context6.prev = 33;\n            _context6.prev = 34;\n\n            if (!_iteratorNormalCompletion9 && _iterator9[\"return\"] != null) {\n              _iterator9[\"return\"]();\n            }\n\n          case 36:\n            _context6.prev = 36;\n\n            if (!_didIteratorError9) {\n              _context6.next = 39;\n              break;\n            }\n\n            throw _iteratorError9;\n\n          case 39:\n            return _context6.finish(36);\n\n          case 40:\n            return _context6.finish(33);\n\n          case 41:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, nodes, null, [[9, 29, 33, 41], [34,, 36, 40]]);\n  }),\n\n  /**\r\n   * Get the parent node of a location.\r\n   */\n  parent: function parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n\n  /**\r\n   * Get the path of a location.\r\n   */\n  path: function path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var depth = options.depth,\n        edge = options.edge;\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        var _Node$first = Node.first(editor, at),\n            _Node$first2 = slicedToArray(_Node$first, 2),\n            firstPath = _Node$first2[1];\n\n        at = firstPath;\n      } else if (edge === 'end') {\n        var _Node$last = Node.last(editor, at),\n            _Node$last2 = slicedToArray(_Node$last, 2),\n            lastPath = _Node$last2[1];\n\n        at = lastPath;\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at);\n      } else if (edge === 'end') {\n        at = Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Get the start or end point of a location.\r\n   */\n  point: function point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$edge = options.edge,\n        edge = _options$edge === void 0 ? 'start' : _options$edge;\n\n    if (Path.isPath(at)) {\n      var path;\n\n      if (edge === 'end') {\n        var _Node$last3 = Node.last(editor, at),\n            _Node$last4 = slicedToArray(_Node$last3, 2),\n            lastPath = _Node$last4[1];\n\n        path = lastPath;\n      } else {\n        var _Node$first3 = Node.first(editor, at),\n            _Node$first4 = slicedToArray(_Node$first3, 2),\n            firstPath = _Node$first4[1];\n\n        path = firstPath;\n      }\n\n      var node = Node.get(editor, path);\n\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n\n      return {\n        path: path,\n        offset: edge === 'end' ? node.text.length : 0\n      };\n    }\n\n    if (Range.isRange(at)) {\n      var _Range$edges = Range.edges(at),\n          _Range$edges2 = slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n\n      return edge === 'start' ? start : end;\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Iterate through all of the positions in the document where a `Point` can be\r\n   * placed.\r\n   *\r\n   * By default it will move forward by individual offsets at a time,  but you\r\n   * can pass the `unit: 'character'` option to moved forward one character, word,\r\n   * or line at at time.\r\n   *\r\n   * Note: void nodes are treated as a single point, and iteration will not\r\n   * happen inside their content.\r\n   */\n  positions:\n  /*#__PURE__*/\n  regenerator.mark(function positions(editor) {\n    var options,\n        _options$at5,\n        at,\n        _options$unit,\n        unit,\n        _options$reverse5,\n        reverse$1,\n        range,\n        _Range$edges3,\n        _Range$edges4,\n        start,\n        end,\n        first,\n        string,\n        available,\n        offset,\n        distance,\n        isNewBlock,\n        advance,\n        _iteratorNormalCompletion10,\n        _didIteratorError10,\n        _iteratorError10,\n        _iterator10,\n        _step10,\n        _step10$value,\n        node,\n        path,\n        e,\n        s,\n        text,\n        isFirst,\n        _args7 = arguments;\n\n    return regenerator.wrap(function positions$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n            _options$at5 = options.at, at = _options$at5 === void 0 ? editor.selection : _options$at5, _options$unit = options.unit, unit = _options$unit === void 0 ? 'offset' : _options$unit, _options$reverse5 = options.reverse, reverse$1 = _options$reverse5 === void 0 ? false : _options$reverse5;\n\n            if (at) {\n              _context7.next = 4;\n              break;\n            }\n\n            return _context7.abrupt(\"return\");\n\n          case 4:\n            range = Editor.range(editor, at);\n            _Range$edges3 = Range.edges(range), _Range$edges4 = slicedToArray(_Range$edges3, 2), start = _Range$edges4[0], end = _Range$edges4[1];\n            first = reverse$1 ? end : start;\n            string = '';\n            available = 0;\n            offset = 0;\n            distance = null;\n            isNewBlock = false;\n\n            advance = function advance() {\n              if (distance == null) {\n                if (unit === 'character') {\n                  distance = getCharacterDistance(string);\n                } else if (unit === 'word') {\n                  distance = getWordDistance(string);\n                } else if (unit === 'line' || unit === 'block') {\n                  distance = string.length;\n                } else {\n                  distance = 1;\n                }\n\n                string = string.slice(distance);\n              } // Add or substract the offset.\n\n\n              offset = reverse$1 ? offset - distance : offset + distance; // Subtract the distance traveled from the available text.\n\n              available = available - distance; // If the available had room to spare, reset the distance so that it will\n              // advance again next time. Otherwise, set it to the overflow amount.\n\n              distance = available >= 0 ? null : 0 - available;\n            };\n\n            _iteratorNormalCompletion10 = true;\n            _didIteratorError10 = false;\n            _iteratorError10 = undefined;\n            _context7.prev = 16;\n            _iterator10 = Editor.nodes(editor, {\n              at: at,\n              reverse: reverse$1\n            })[Symbol.iterator]();\n\n          case 18:\n            if (_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done) {\n              _context7.next = 54;\n              break;\n            }\n\n            _step10$value = slicedToArray(_step10.value, 2), node = _step10$value[0], path = _step10$value[1];\n\n            if (!Element.isElement(node)) {\n              _context7.next = 28;\n              break;\n            }\n\n            if (!editor.isVoid(node)) {\n              _context7.next = 25;\n              break;\n            }\n\n            _context7.next = 24;\n            return Editor.start(editor, path);\n\n          case 24:\n            return _context7.abrupt(\"continue\", 51);\n\n          case 25:\n            if (!editor.isInline(node)) {\n              _context7.next = 27;\n              break;\n            }\n\n            return _context7.abrupt(\"continue\", 51);\n\n          case 27:\n            if (Editor.hasInlines(editor, node)) {\n              e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n              s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n              text = Editor.text(editor, {\n                anchor: s,\n                focus: e\n              });\n              string = reverse$1 ? reverse(text) : text;\n              isNewBlock = true;\n            }\n\n          case 28:\n            if (!Text.isText(node)) {\n              _context7.next = 51;\n              break;\n            }\n\n            isFirst = Path.equals(path, first.path);\n            available = node.text.length;\n            offset = reverse$1 ? available : 0;\n\n            if (isFirst) {\n              available = reverse$1 ? first.offset : available - first.offset;\n              offset = first.offset;\n            }\n\n            if (!(isFirst || isNewBlock || unit === 'offset')) {\n              _context7.next = 36;\n              break;\n            }\n\n            _context7.next = 36;\n            return {\n              path: path,\n              offset: offset\n            };\n\n          case 36:\n            if (!(string === '')) {\n              _context7.next = 41;\n              break;\n            }\n\n            return _context7.abrupt(\"break\", 50);\n\n          case 41:\n            advance();\n\n          case 42:\n            if (!(available >= 0)) {\n              _context7.next = 47;\n              break;\n            }\n\n            _context7.next = 45;\n            return {\n              path: path,\n              offset: offset\n            };\n\n          case 45:\n            _context7.next = 48;\n            break;\n\n          case 47:\n            return _context7.abrupt(\"break\", 50);\n\n          case 48:\n            _context7.next = 36;\n            break;\n\n          case 50:\n            isNewBlock = false;\n\n          case 51:\n            _iteratorNormalCompletion10 = true;\n            _context7.next = 18;\n            break;\n\n          case 54:\n            _context7.next = 60;\n            break;\n\n          case 56:\n            _context7.prev = 56;\n            _context7.t0 = _context7[\"catch\"](16);\n            _didIteratorError10 = true;\n            _iteratorError10 = _context7.t0;\n\n          case 60:\n            _context7.prev = 60;\n            _context7.prev = 61;\n\n            if (!_iteratorNormalCompletion10 && _iterator10[\"return\"] != null) {\n              _iterator10[\"return\"]();\n            }\n\n          case 63:\n            _context7.prev = 63;\n\n            if (!_didIteratorError10) {\n              _context7.next = 66;\n              break;\n            }\n\n            throw _iteratorError10;\n\n          case 66:\n            return _context7.finish(63);\n\n          case 67:\n            return _context7.finish(60);\n\n          case 68:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, positions, null, [[16, 56, 60, 68], [61,, 63, 67]]);\n  }),\n\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\n  previous: function previous(editor, at, match) {\n    var _Editor$first = Editor.first(editor, at),\n        _Editor$first2 = slicedToArray(_Editor$first, 2),\n        from = _Editor$first2[1];\n\n    var _Editor$first3 = Editor.first(editor, []),\n        _Editor$first4 = slicedToArray(_Editor$first3, 2),\n        to = _Editor$first4[1];\n\n    var span = [from, to];\n    var i = 0;\n    var _iteratorNormalCompletion11 = true;\n    var _didIteratorError11 = false;\n    var _iteratorError11 = undefined;\n\n    try {\n      for (var _iterator11 = Editor.nodes(editor, {\n        match: match,\n        at: span,\n        reverse: true,\n        mode: 'highest'\n      })[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n        var entry = _step11.value;\n\n        if (i === 1) {\n          return entry;\n        }\n\n        i++;\n      }\n    } catch (err) {\n      _didIteratorError11 = true;\n      _iteratorError11 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion11 && _iterator11[\"return\"] != null) {\n          _iterator11[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError11) {\n          throw _iteratorError11;\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Get a range of a location.\r\n   */\n  range: function range(editor, at, to) {\n    if (Range.isRange(at) && !to) {\n      return at;\n    }\n\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Get the start point of a location.\r\n   */\n  start: function start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'start'\n    });\n  },\n\n  /**\r\n   * Get the text content of a location.\r\n   *\r\n   * Note: the text of void nodes is presumed to be an empty string, regardless\r\n   * of what their actual content is.\r\n   */\n  text: function text(editor, at) {\n    var range = Editor.range(editor, at);\n\n    var _Range$edges5 = Range.edges(range),\n        _Range$edges6 = slicedToArray(_Range$edges5, 2),\n        start = _Range$edges6[0],\n        end = _Range$edges6[1];\n\n    var text = '';\n    var _iteratorNormalCompletion12 = true;\n    var _didIteratorError12 = false;\n    var _iteratorError12 = undefined;\n\n    try {\n      for (var _iterator12 = Editor.texts(editor, {\n        at: range\n      })[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n        var _step12$value = slicedToArray(_step12.value, 2),\n            node = _step12$value[0],\n            path = _step12$value[1];\n\n        var t = node.text;\n\n        if (Path.equals(path, end.path)) {\n          t = t.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          t = t.slice(start.offset);\n        }\n\n        text += t;\n      }\n    } catch (err) {\n      _didIteratorError12 = true;\n      _iteratorError12 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion12 && _iterator12[\"return\"] != null) {\n          _iterator12[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError12) {\n          throw _iteratorError12;\n        }\n      }\n    }\n\n    return text;\n  },\n\n  /**\r\n   * Iterate through all of the text nodes in the Editor.\r\n   */\n  texts:\n  /*#__PURE__*/\n  regenerator.mark(function texts(editor) {\n    var options,\n        _iteratorNormalCompletion13,\n        _didIteratorError13,\n        _iteratorError13,\n        _iterator13,\n        _step13,\n        _step13$value,\n        node,\n        path,\n        _args8 = arguments;\n\n    return regenerator.wrap(function texts$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n            _iteratorNormalCompletion13 = true;\n            _didIteratorError13 = false;\n            _iteratorError13 = undefined;\n            _context8.prev = 4;\n            _iterator13 = this.nodes(editor, options)[Symbol.iterator]();\n\n          case 6:\n            if (_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done) {\n              _context8.next = 14;\n              break;\n            }\n\n            _step13$value = slicedToArray(_step13.value, 2), node = _step13$value[0], path = _step13$value[1];\n\n            if (!Text.isText(node)) {\n              _context8.next = 11;\n              break;\n            }\n\n            _context8.next = 11;\n            return [node, path];\n\n          case 11:\n            _iteratorNormalCompletion13 = true;\n            _context8.next = 6;\n            break;\n\n          case 14:\n            _context8.next = 20;\n            break;\n\n          case 16:\n            _context8.prev = 16;\n            _context8.t0 = _context8[\"catch\"](4);\n            _didIteratorError13 = true;\n            _iteratorError13 = _context8.t0;\n\n          case 20:\n            _context8.prev = 20;\n            _context8.prev = 21;\n\n            if (!_iteratorNormalCompletion13 && _iterator13[\"return\"] != null) {\n              _iterator13[\"return\"]();\n            }\n\n          case 23:\n            _context8.prev = 23;\n\n            if (!_didIteratorError13) {\n              _context8.next = 26;\n              break;\n            }\n\n            throw _iteratorError13;\n\n          case 26:\n            return _context8.finish(23);\n\n          case 27:\n            return _context8.finish(20);\n\n          case 28:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, texts, this, [[4, 16, 20, 28], [21,, 23, 27]]);\n  })\n};\n/**\r\n * Constants for string distance checking.\r\n */\n\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\nvar SURROGATE_START = 0xd800;\nvar SURROGATE_END = 0xdfff;\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\nvar isWordCharacter = function isWordCharacter(_char, remaining) {\n  if (SPACE.test(_char)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(_char)) {\n    var next = remaining.charAt(0);\n    var length = getCharacterDistance(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n\n    if (isWordCharacter(next, rest)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(_char)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\n\n\nvar getCharacterDistance = function getCharacterDistance(text) {\n  var code = text.charCodeAt(0);\n  var isSurrogate = SURROGATE_START <= code && code <= SURROGATE_END;\n  return isSurrogate ? 2 : 1;\n};\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\n\nvar getWordDistance = function getWordDistance(text) {\n  var length = 0;\n  var i = 0;\n  var started = false;\n\n  var _char2;\n\n  while (_char2 = text.charAt(i)) {\n    var l = getCharacterDistance(_char2);\n    _char2 = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWordCharacter(_char2, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n};\n\nvar MarkTransforms = {\n  /**\r\n   * Add a set of marks to the text nodes at a location.\r\n   */\n  addMarks: function addMarks(editor, mark) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var at = splitLocation(editor, options);\n\n      if (!at) {\n        return;\n      } // De-dupe the marks being added to ensure the set is unique.\n\n\n      var marks = Array.isArray(mark) ? mark : [mark];\n      var set = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = marks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var m = _step.value;\n\n          if (!Mark.exists(m, set)) {\n            set.push(m);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = Editor.texts(editor, {\n          at: at\n        })[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = slicedToArray(_step2.value, 2),\n              node = _step2$value[0],\n              path = _step2$value[1];\n\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = set[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var _m = _step3.value;\n\n              if (!Mark.exists(_m, node.marks)) {\n                editor.apply({\n                  type: 'add_mark',\n                  path: path,\n                  mark: _m\n                });\n              }\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n                _iterator3[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n  },\n  removeMarks: function removeMarks(editor, mark) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var at = splitLocation(editor, options);\n\n      if (at) {\n        var marks = Array.isArray(mark) ? mark : [mark];\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = Editor.marks(editor, {\n            at: at\n          })[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _step4$value = slicedToArray(_step4.value, 4),\n                m = _step4$value[0],\n                i = _step4$value[1],\n                node = _step4$value[2],\n                path = _step4$value[3];\n\n            if (Mark.exists(m, marks)) {\n              editor.apply({\n                type: 'remove_mark',\n                path: path,\n                mark: m\n              });\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n              _iterator4[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n    });\n  },\n  setMarks: function setMarks(editor, mark, props) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var at = splitLocation(editor, options);\n\n      if (at) {\n        var marks = Array.isArray(mark) ? mark : [mark];\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = Editor.marks(editor, {\n            at: at\n          })[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var _step5$value = slicedToArray(_step5.value, 4),\n                m = _step5$value[0],\n                i = _step5$value[1],\n                node = _step5$value[2],\n                path = _step5$value[3];\n\n            if (Mark.exists(m, marks)) {\n              var newProps = {};\n\n              for (var k in props) {\n                if (props[k] !== m[k]) {\n                  newProps[k] = props[k];\n                }\n              }\n\n              if (Object.keys(newProps).length > 0) {\n                editor.apply({\n                  type: 'set_mark',\n                  path: path,\n                  properties: m,\n                  newProperties: newProps\n                });\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n              _iterator5[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n    });\n  }\n};\n/**\r\n * Split the text nodes at a range's edges to prepare for adding/removing marks.\r\n */\n\nvar splitLocation = function splitLocation(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$at = options.at,\n      at = _options$at === void 0 ? editor.selection : _options$at,\n      _options$hanging = options.hanging,\n      hanging = _options$hanging === void 0 ? false : _options$hanging;\n\n  if (!at) {\n    return;\n  }\n\n  if (Range.isRange(at)) {\n    if (!hanging) {\n      at = Editor.unhangRange(editor, at);\n    }\n\n    var rangeRef = Editor.rangeRef(editor, at, {\n      affinity: 'inward'\n    });\n\n    var _Range$edges = Range.edges(at),\n        _Range$edges2 = slicedToArray(_Range$edges, 2),\n        start = _Range$edges2[0],\n        end = _Range$edges2[1];\n\n    Editor.splitNodes(editor, {\n      at: end,\n      match: 'text'\n    });\n    Editor.splitNodes(editor, {\n      at: start,\n      match: 'text'\n    });\n    var range = rangeRef.unref();\n\n    if (options.at == null) {\n      Editor.select(editor, range);\n    }\n\n    return range;\n  }\n\n  return at;\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar objectWithoutProperties = _objectWithoutProperties;\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$2(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$2(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar NodeTransforms = {\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\n  insertNodes: function insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var selection = editor.selection;\n      var _options$hanging = options.hanging,\n          hanging = _options$hanging === void 0 ? false : _options$hanging;\n      var at = options.at,\n          match = options.match;\n      var select = false;\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes];\n      }\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var _nodes = nodes,\n          _nodes2 = slicedToArray(_nodes, 1),\n          node = _nodes2[0];\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var path = at;\n\n          match = function match(_ref) {\n            var _ref2 = slicedToArray(_ref, 2),\n                p = _ref2[1];\n\n            return Path.equals(p, path);\n          };\n        } else if (Text.isText(node)) {\n          match = 'text';\n        } else if (editor.isInline(node)) {\n          match = 'inline';\n        } else {\n          match = 'block';\n        }\n      } // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n\n\n      if (!at) {\n        at = selection || Editor.end(editor, []) || [editor.children.length];\n        select = true;\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges = Range.edges(at),\n              _Range$edges2 = slicedToArray(_Range$edges, 2),\n              end = _Range$edges2[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Editor[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        var atMatch = Editor.match(editor, at.path, match);\n\n        if (atMatch) {\n          var _atMatch = slicedToArray(atMatch, 2),\n              matchPath = _atMatch[1];\n\n          var pathRef = Editor.pathRef(editor, matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, matchPath);\n          Editor.splitNodes(editor, {\n            at: at,\n            match: match\n          });\n\n          var _path = pathRef.unref();\n\n          at = isAtEnd ? Path.next(_path) : _path;\n        } else {\n          return;\n        }\n      }\n\n      var parentPath = Path.parent(at);\n      var index = at[at.length - 1];\n\n      if (Editor.match(editor, parentPath, 'void')) {\n        return;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _node = _step.value;\n\n          var _path2 = parentPath.concat(index);\n\n          index++;\n          editor.apply({\n            type: 'insert_node',\n            path: _path2,\n            node: _node\n          });\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (select) {\n        var point = Editor.end(editor, at);\n\n        if (point) {\n          Editor.select(editor, point);\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\n  liftNodes: function liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$at = options.at,\n          at = _options$at === void 0 ? editor.selection : _options$at;\n      var match = options.match;\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var path = at;\n\n          match = function match(_ref3) {\n            var _ref4 = slicedToArray(_ref3, 2),\n                p = _ref4[1];\n\n            return Path.equals(p, path);\n          };\n        } else {\n          match = 'block';\n        }\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: 'highest'\n      });\n      var pathRefs = Array.from(matches, function (_ref5) {\n        var _ref6 = slicedToArray(_ref5, 2),\n            p = _ref6[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n        var pathRef = _pathRefs[_i];\n\n        var _path3 = pathRef.unref();\n\n        if (_path3.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(_path3, \"] because it has a depth of less than `2`.\"));\n        }\n\n        var _Editor$node = Editor.node(editor, Path.parent(_path3)),\n            _Editor$node2 = slicedToArray(_Editor$node, 2),\n            parent = _Editor$node2[0],\n            parentPath = _Editor$node2[1];\n\n        var index = _path3[_path3.length - 1];\n        var length = parent.children.length;\n\n        if (length === 1) {\n          Editor.moveNodes(editor, {\n            at: _path3,\n            to: Path.next(parentPath)\n          });\n          Editor.removeNodes(editor, {\n            at: parentPath\n          });\n        } else if (index === 0) {\n          Editor.moveNodes(editor, {\n            at: _path3,\n            to: parentPath\n          });\n        } else if (index === length - 1) {\n          Editor.moveNodes(editor, {\n            at: _path3,\n            to: Path.next(parentPath)\n          });\n        } else {\n          Editor.splitNodes(editor, {\n            at: Path.next(_path3)\n          });\n          Editor.moveNodes(editor, {\n            at: _path3,\n            to: Path.next(parentPath)\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\n  mergeNodes: function mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at2 = options.at,\n          at = _options$at2 === void 0 ? editor.selection : _options$at2;\n      var _options$hanging2 = options.hanging,\n          hanging = _options$hanging2 === void 0 ? false : _options$hanging2;\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var _path4 = at;\n\n          match = function match(_ref7) {\n            var _ref8 = slicedToArray(_ref7, 2),\n                p = _ref8[1];\n\n            return Path.equals(p, _path4);\n          };\n        } else {\n          match = 'block';\n        }\n      }\n\n      if (!at) {\n        return;\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges3 = Range.edges(at),\n              _Range$edges4 = slicedToArray(_Range$edges3, 2),\n              end = _Range$edges4[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Editor[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n\n          if (options.at == null) {\n            Editor.select(editor, at);\n          }\n        }\n      }\n\n      var current = Editor.match(editor, at, match);\n\n      if (!current) {\n        return;\n      }\n\n      var prevMatch = 'block';\n\n      var _current = slicedToArray(current, 2),\n          node = _current[0],\n          path = _current[1];\n\n      if (Editor.isEditor(node)) {\n        return;\n      } else if (Text.isText(node)) {\n        prevMatch = 'text';\n      } else if (editor.isInline(node)) {\n        prevMatch = 'inline';\n      }\n\n      var prev = Editor.previous(editor, at, prevMatch);\n\n      if (!prev) {\n        return;\n      }\n\n      var _prev = slicedToArray(prev, 2),\n          prevNode = _prev[0],\n          prevPath = _prev[1];\n\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath); // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n\n      var emptyAncestor = Node.furthest(editor, path, function (_ref9) {\n        var _ref10 = slicedToArray(_ref9, 2),\n            n = _ref10[0],\n            p = _ref10[1];\n\n        return Path.isDescendant(p, commonPath) && Path.isAncestor(p, path) && Element.isElement(n) && n.children.length === 1;\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position; // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        var text = node.text,\n            marks = node.marks,\n            rest = objectWithoutProperties(node, [\"text\", \"marks\"]);\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        var children = node.children,\n            _rest = objectWithoutProperties(node, [\"children\"]);\n\n        position = prevNode.children.length;\n        properties = _rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(JSON.stringify(node), \" \").concat(JSON.stringify(prevNode)));\n      } // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n\n\n      if (!isPreviousSibling) {\n        Editor.moveNodes(editor, {\n          at: path,\n          to: newPath\n        });\n      } // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n\n\n      if (emptyRef) {\n        Editor.removeNodes(editor, {\n          at: emptyRef.current\n        });\n      } // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n\n\n      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '') {\n        Editor.removeNodes(editor, {\n          at: prevPath\n        });\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position: position,\n          target: null,\n          properties: properties\n        });\n      }\n\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\n  moveNodes: function moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, function () {\n      var to = options.to,\n          _options$at3 = options.at,\n          at = _options$at3 === void 0 ? editor.selection : _options$at3;\n      var match = options.match;\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var path = at;\n\n          match = function match(_ref11) {\n            var _ref12 = slicedToArray(_ref11, 2),\n                p = _ref12[1];\n\n            return Path.equals(p, path);\n          };\n        } else {\n          match = 'block';\n        }\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: 'highest'\n      });\n      var pathRefs = Array.from(targets, function (_ref13) {\n        var _ref14 = slicedToArray(_ref13, 2),\n            p = _ref14[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i2 = 0, _pathRefs2 = pathRefs; _i2 < _pathRefs2.length; _i2++) {\n        var pathRef = _pathRefs2[_i2];\n\n        var _path5 = pathRef.unref();\n\n        var newPath = toRef.current;\n\n        if (_path5.length !== 0) {\n          editor.apply({\n            type: 'move_node',\n            path: _path5,\n            newPath: newPath\n          });\n        }\n      }\n\n      toRef.unref();\n    });\n  },\n\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\n  removeNodes: function removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at4 = options.at,\n          at = _options$at4 === void 0 ? editor.selection : _options$at4;\n      var _options$hanging3 = options.hanging,\n          hanging = _options$hanging3 === void 0 ? false : _options$hanging3;\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var path = at;\n\n          match = function match(_ref15) {\n            var _ref16 = slicedToArray(_ref15, 2),\n                p = _ref16[1];\n\n            return Path.equals(p, path);\n          };\n        } else {\n          match = 'block';\n        }\n      }\n\n      if (!at) {\n        return;\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      var depths = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: 'highest'\n      });\n      var pathRefs = Array.from(depths, function (_ref17) {\n        var _ref18 = slicedToArray(_ref17, 2),\n            p = _ref18[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i3 = 0, _pathRefs3 = pathRefs; _i3 < _pathRefs3.length; _i3++) {\n        var pathRef = _pathRefs3[_i3];\n\n        var _path6 = pathRef.unref();\n\n        var _Editor$node3 = Editor.node(editor, _path6),\n            _Editor$node4 = slicedToArray(_Editor$node3, 1),\n            node = _Editor$node4[0];\n\n        editor.apply({\n          type: 'remove_node',\n          path: _path6,\n          node: node\n        });\n      }\n    });\n  },\n\n  /**\r\n   * Set new properties on the nodes ...\r\n   */\n  setNodes: function setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at5 = options.at,\n          at = _options$at5 === void 0 ? editor.selection : _options$at5;\n      var _options$hanging4 = options.hanging,\n          hanging = _options$hanging4 === void 0 ? false : _options$hanging4;\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var path = at;\n\n          match = function match(_ref19) {\n            var _ref20 = slicedToArray(_ref19, 2),\n                p = _ref20[1];\n\n            return Path.equals(p, path);\n          };\n        } else {\n          match = 'block';\n        }\n      }\n\n      if (!at) {\n        return;\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = Editor.nodes(editor, {\n          at: at,\n          match: match,\n          mode: 'highest'\n        })[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = slicedToArray(_step2.value, 2),\n              node = _step2$value[0],\n              _path7 = _step2$value[1];\n\n          var properties = {};\n          var newProperties = {};\n\n          for (var k in props) {\n            if (k === 'marks' || k === 'children' || k === 'selection' || k === 'text') {\n              continue;\n            }\n\n            if (props[k] !== node[k]) {\n              properties[k] = node[k];\n              newProperties[k] = props[k];\n            }\n          }\n\n          if (Object.keys(newProperties).length !== 0) {\n            editor.apply({\n              type: 'set_node',\n              path: _path7,\n              properties: properties,\n              newProperties: newProperties\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\n  splitNodes: function splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at6 = options.at,\n          at = _options$at6 === void 0 ? editor.selection : _options$at6,\n          _options$height = options.height,\n          height = _options$height === void 0 ? 0 : _options$height,\n          _options$always = options.always,\n          always = _options$always === void 0 ? false : _options$always;\n\n      if (match == null) {\n        match = 'block';\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      } // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n\n\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n\n        match = function match(_ref21) {\n          var _ref22 = slicedToArray(_ref21, 2),\n              p = _ref22[1];\n\n          return p.length === path.length - 1;\n        };\n\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward'\n      });\n      var highest = Editor.match(editor, at, match);\n\n      if (!highest) {\n        return;\n      }\n\n      var voidMatch = Editor.match(editor, at, 'void');\n      var nudge = 0;\n\n      if (voidMatch) {\n        var _voidMatch = slicedToArray(voidMatch, 2),\n            voidNode = _voidMatch[0],\n            voidPath = _voidMatch[1];\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n\n          if (!after) {\n            var text = {\n              text: '',\n              marks: []\n            };\n            var afterPath = Path.next(voidPath);\n            Editor.insertNodes(editor, text, {\n              at: afterPath\n            });\n            after = Editor.point(editor, afterPath);\n          }\n\n          at = after;\n          always = true;\n        }\n\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n\n      var afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n\n      var _highest = slicedToArray(highest, 2),\n          highestPath = _highest[1];\n\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n      var target = null;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = Editor.levels(editor, {\n          at: lowestPath,\n          reverse: true\n        })[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _step3$value = slicedToArray(_step3.value, 2),\n              node = _step3$value[0],\n              _path8 = _step3$value[1];\n\n          var split = false;\n\n          if (_path8.length < highestPath.length || _path8.length === 0 || Element.isElement(node) && editor.isVoid(node)) {\n            break;\n          }\n\n          var _point2 = beforeRef.current;\n          var isEnd = Editor.isEnd(editor, _point2, _path8);\n\n          if (always || !beforeRef || !Editor.isEdge(editor, _point2, _path8)) {\n            split = true;\n            var _text = node.text,\n                marks = node.marks,\n                children = node.children,\n                properties = objectWithoutProperties(node, [\"text\", \"marks\", \"children\"]);\n            editor.apply({\n              type: 'split_node',\n              path: _path8,\n              position: position,\n              target: target,\n              properties: properties\n            });\n          }\n\n          target = position;\n          position = _path8[_path8.length - 1] + (split || isEnd ? 1 : 0);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      if (options.at == null) {\n        var _point = afterRef.current || Editor.end(editor, []);\n\n        Editor.select(editor, _point);\n      }\n\n      beforeRef.unref();\n      afterRef.unref();\n    });\n  },\n\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\n  unwrapNodes: function unwrapNodes(editor, options) {\n    Editor.withoutNormalizing(editor, function () {\n      var _options$at7 = options.at,\n          at = _options$at7 === void 0 ? editor.selection : _options$at7,\n          _options$split = options.split,\n          split = _options$split === void 0 ? false : _options$split;\n      var match = options.match;\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var path = at;\n\n          match = function match(_ref23) {\n            var _ref24 = slicedToArray(_ref23, 2),\n                p = _ref24[1];\n\n            return Path.equals(p, path);\n          };\n        } else {\n          match = 'block';\n        }\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: 'highest'\n      });\n      var pathRefs = Array.from(matches, function (_ref25) {\n        var _ref26 = slicedToArray(_ref25, 2),\n            p = _ref26[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      var _loop = function _loop() {\n        var pathRef = _pathRefs4[_i4];\n        var path = pathRef.unref();\n        var depth = path.length + 1;\n        var range = Editor.range(editor, path);\n\n        if (split && Range.isRange(at)) {\n          range = Range.intersection(at, range);\n        }\n\n        Editor.liftNodes(editor, {\n          at: range,\n          match: function match(_ref27) {\n            var _ref28 = slicedToArray(_ref27, 2),\n                p = _ref28[1];\n\n            return p.length === depth;\n          }\n        });\n      };\n\n      for (var _i4 = 0, _pathRefs4 = pathRefs; _i4 < _pathRefs4.length; _i4++) {\n        _loop();\n      }\n    });\n  },\n\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\n  wrapNodes: function wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$split2 = options.split,\n          split = _options$split2 === void 0 ? false : _options$split2;\n      var match = options.match,\n          _options$at8 = options.at,\n          at = _options$at8 === void 0 ? editor.selection : _options$at8;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var path = at;\n\n          match = function match(_ref29) {\n            var _ref30 = slicedToArray(_ref29, 2),\n                p = _ref30[1];\n\n            return Path.equals(p, path);\n          };\n        } else if (editor.isInline(element)) {\n          match = 'inline';\n        } else {\n          match = 'block';\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        var _Range$edges5 = Range.edges(at),\n            _Range$edges6 = slicedToArray(_Range$edges5, 2),\n            start = _Range$edges6[0],\n            end = _Range$edges6[1];\n\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        Editor.splitNodes(editor, {\n          at: end,\n          match: match\n        });\n        Editor.splitNodes(editor, {\n          at: start,\n          match: match\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Editor.select(editor, at);\n        }\n      }\n\n      var roots = editor.isInline(element) ? Array.from(Editor.nodes(editor, _objectSpread$2({}, options, {\n        at: at,\n        match: 'block',\n        mode: 'highest'\n      }))) : [[editor, []]];\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = roots[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _step4$value = slicedToArray(_step4.value, 2),\n              rootPath = _step4$value[1];\n\n          var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n          if (!a) {\n            continue;\n          }\n\n          var matches = Array.from(Editor.nodes(editor, _objectSpread$2({}, options, {\n            at: a,\n            match: match,\n            mode: 'highest'\n          })));\n\n          if (matches.length > 0) {\n            (function () {\n              var _matches = slicedToArray(matches, 1),\n                  first = _matches[0];\n\n              var last = matches[matches.length - 1];\n\n              var _first = slicedToArray(first, 2),\n                  firstPath = _first[1];\n\n              var _last = slicedToArray(last, 2),\n                  lastPath = _last[1];\n\n              var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n              var range = Editor.range(editor, firstPath, lastPath);\n              var depth = commonPath.length + 1;\n              var wrapperPath = Path.next(lastPath).slice(0, depth);\n\n              var wrapper = _objectSpread$2({}, element, {\n                children: []\n              });\n\n              Editor.insertNodes(editor, wrapper, {\n                at: wrapperPath\n              });\n              Editor.moveNodes(editor, {\n                at: range,\n                match: function match(_ref31) {\n                  var _ref32 = slicedToArray(_ref31, 2),\n                      p = _ref32[1];\n\n                  return p.length === depth;\n                },\n                to: wrapperPath.concat(0)\n              });\n            })();\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n            _iterator4[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    });\n  }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\nvar deleteRange = function deleteRange(editor, range) {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var _Range$edges7 = Range.edges(range),\n        _Range$edges8 = slicedToArray(_Range$edges7, 2),\n        end = _Range$edges8[1];\n\n    var pointRef = Editor.pointRef(editor, end);\n    Editor[\"delete\"](editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar NodeQueries = {\n  /**\r\n   * Check if a node entry is a match.\r\n   */\n  isMatch: function isMatch(editor, entry, match) {\n    var _entry = slicedToArray(entry, 1),\n        node = _entry[0]; // If match is an array, treat it as an OR condition.\n\n\n    if (Array.isArray(match)) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = match[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var m = _step.value;\n\n          if (Editor.isMatch(editor, entry, m)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    switch (match) {\n      case 'text':\n        return Text.isText(node);\n\n      case 'editor':\n        return Editor.isEditor(node);\n\n      case 'element':\n        return Element.isElement(node);\n\n      case 'inline':\n        return Element.isElement(node) && editor.isInline(node) || Text.isText(node);\n\n      case 'inline-element':\n        return Element.isElement(node) && editor.isInline(node);\n\n      case 'block':\n        return Element.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node);\n\n      case 'void':\n        return Element.isElement(node) && editor.isVoid(node);\n    }\n\n    if (typeof match === 'function') {\n      return match(entry);\n    } else {\n      return Node.matches(node, match);\n    }\n  }\n};\nvar RangeQueries = {\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\n  unhangRange: function unhangRange(editor, range) {\n    var _Range$edges = Range.edges(range),\n        _Range$edges2 = slicedToArray(_Range$edges, 2),\n        start = _Range$edges2[0],\n        end = _Range$edges2[1]; // PERF: exit early if we can guarantee that the range isn't hanging.\n\n\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range;\n    }\n\n    var closestBlock = Editor.match(editor, end.path, 'block');\n    var blockPath = closestBlock ? closestBlock[1] : [];\n    var first = Editor.start(editor, []);\n    var before = {\n      anchor: first,\n      focus: end\n    };\n    var skip = true;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Editor.texts(editor, {\n        at: before,\n        reverse: true\n      })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _step$value = slicedToArray(_step.value, 2),\n            node = _step$value[0],\n            path = _step$value[1];\n\n        if (skip) {\n          skip = false;\n          continue;\n        }\n\n        if (node.text !== '' || Path.isBefore(path, blockPath)) {\n          end = {\n            path: path,\n            offset: node.text.length\n          };\n          break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return {\n      anchor: start,\n      focus: end\n    };\n  }\n};\nvar SelectionTransforms = {\n  /**\r\n   * Collapse the selection.\r\n   */\n  collapse: function collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$edge = options.edge,\n        edge = _options$edge === void 0 ? 'anchor' : _options$edge;\n    var selection = editor.selection;\n\n    if (!selection) {\n      return;\n    } else if (edge === 'anchor') {\n      Editor.select(editor, selection.anchor);\n    } else if (edge === 'focus') {\n      Editor.select(editor, selection.focus);\n    } else if (edge === 'start') {\n      var _Range$edges = Range.edges(selection),\n          _Range$edges2 = slicedToArray(_Range$edges, 1),\n          start = _Range$edges2[0];\n\n      Editor.select(editor, start);\n    } else if (edge === 'end') {\n      var _Range$edges3 = Range.edges(selection),\n          _Range$edges4 = slicedToArray(_Range$edges3, 2),\n          end = _Range$edges4[1];\n\n      Editor.select(editor, end);\n    }\n  },\n\n  /**\r\n   * Unset the selection.\r\n   */\n  deselect: function deselect(editor) {\n    var selection = editor.selection;\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\n  move: function move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var selection = editor.selection;\n    var _options$distance = options.distance,\n        distance = _options$distance === void 0 ? 1 : _options$distance,\n        _options$unit = options.unit,\n        unit = _options$unit === void 0 ? 'character' : _options$unit,\n        _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var _options$edge2 = options.edge,\n        edge = _options$edge2 === void 0 ? null : _options$edge2;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var opts = {\n      distance: distance,\n      unit: unit\n    };\n    var props = {};\n\n    if (edge == null || edge === 'anchor') {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n      if (point) {\n        props.anchor = point;\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n\n    Editor.setSelection(editor, props);\n  },\n\n  /**\r\n   * Set the selection to a new value.\r\n   */\n  select: function select(editor, target) {\n    var selection = editor.selection;\n    target = Editor.range(editor, target);\n\n    if (selection) {\n      Editor.setSelection(editor, target);\n      return;\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(JSON.stringify(target)));\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target\n    });\n  },\n\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\n  setPoint: function setPoint(editor, props, options) {\n    var selection = editor.selection;\n    var _options$edge3 = options.edge,\n        edge = _options$edge3 === void 0 ? 'both' : _options$edge3;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var point = edge === 'anchor' ? anchor : focus;\n    var newPoint = Object.assign(point, props);\n\n    if (edge === 'anchor') {\n      Editor.setSelection(editor, {\n        anchor: newPoint\n      });\n    } else {\n      Editor.setSelection(editor, {\n        focus: newPoint\n      });\n    }\n  },\n\n  /**\r\n   * Set new properties on the selection.\r\n   */\n  setSelection: function setSelection(editor, props) {\n    var selection = editor.selection;\n    var oldProps = {};\n    var newProps = {};\n\n    if (!selection) {\n      return;\n    }\n\n    for (var k in props) {\n      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n        oldProps[k] = selection[k];\n        newProps[k] = props[k];\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n};\nvar TextTransforms = {\n  /**\r\n   * Delete content in the editor.\r\n   */\n  \"delete\": function _delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$reverse = options.reverse,\n          reverse = _options$reverse === void 0 ? false : _options$reverse,\n          _options$unit = options.unit,\n          unit = _options$unit === void 0 ? 'character' : _options$unit,\n          _options$distance = options.distance,\n          distance = _options$distance === void 0 ? 1 : _options$distance;\n      var _options$at = options.at,\n          at = _options$at === void 0 ? editor.selection : _options$at,\n          _options$hanging = options.hanging,\n          hanging = _options$hanging === void 0 ? false : _options$hanging;\n\n      if (!at) {\n        return;\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor;\n      }\n\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor.match(editor, at.path, 'void');\n\n        if (furthestVoid) {\n          var _furthestVoid = slicedToArray(furthestVoid, 2),\n              voidPath = _furthestVoid[1];\n\n          at = voidPath;\n        } else {\n          var opts = {\n            unit: unit,\n            distance: distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Editor.removeNodes(editor, {\n          at: at\n        });\n        return;\n      }\n\n      if (Range.isCollapsed(at)) {\n        return;\n      }\n\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      var _Range$edges = Range.edges(at),\n          _Range$edges2 = slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n\n      var _Editor$ancestor = Editor.ancestor(editor, at),\n          _Editor$ancestor2 = slicedToArray(_Editor$ancestor, 1),\n          ancestor = _Editor$ancestor2[0];\n\n      var isSingleText = Path.equals(start.path, end.path);\n      var startVoid = Editor.match(editor, start.path, 'void');\n      var endVoid = Editor.match(editor, end.path, 'void'); // If the start or end points are inside an inline void, nudge them out.\n\n      if (startVoid) {\n        var block = Editor.match(editor, start.path, 'block');\n        var before = Editor.before(editor, start);\n\n        if (before && block && Path.isAncestor(block[1], before.path)) {\n          start = before;\n        }\n      }\n\n      if (endVoid) {\n        var _block = Editor.match(editor, end.path, 'block');\n\n        var after = Editor.after(editor, end);\n\n        if (after && _block && Path.isAncestor(_block[1], after.path)) {\n          end = after;\n        }\n      } // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n\n\n      var matches = Editor.nodes(editor, {\n        at: at,\n        mode: 'highest',\n        match: function match(_ref) {\n          var _ref2 = slicedToArray(_ref, 2),\n              n = _ref2[0],\n              p = _ref2[1];\n\n          return Element.isElement(n) && editor.isVoid(n) || !Path.isCommon(p, start.path) && !Path.isCommon(p, end.path);\n        }\n      });\n      var pathRefs = Array.from(matches, function (_ref3) {\n        var _ref4 = slicedToArray(_ref3, 2),\n            p = _ref4[1];\n\n        return Editor.pathRef(editor, p);\n      });\n      var startRef = Editor.pointRef(editor, start);\n      var endRef = Editor.pointRef(editor, end);\n\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n\n        var _Editor$leaf = Editor.leaf(editor, _point),\n            _Editor$leaf2 = slicedToArray(_Editor$leaf, 1),\n            node = _Editor$leaf2[0];\n\n        var path = _point.path;\n        var _start = start,\n            offset = _start.offset;\n        var text = node.text.slice(offset);\n        editor.apply({\n          type: 'remove_text',\n          path: path,\n          offset: offset,\n          text: text\n        });\n      }\n\n      for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n        var pathRef = _pathRefs[_i];\n\n        var _path2 = pathRef.unref();\n\n        Editor.removeNodes(editor, {\n          at: _path2\n        });\n      }\n\n      if (!endVoid) {\n        var _point2 = endRef.current;\n\n        var _Editor$leaf3 = Editor.leaf(editor, _point2),\n            _Editor$leaf4 = slicedToArray(_Editor$leaf3, 1),\n            _node = _Editor$leaf4[0];\n\n        var _path = _point2.path;\n\n        var _offset = isSingleText ? start.offset : 0;\n\n        var _text = _node.text.slice(_offset, end.offset);\n\n        editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset: _offset,\n          text: _text\n        });\n      }\n\n      var isBlockAncestor = Editor.isEditor(ancestor) || Element.isElement(ancestor) && !editor.isInline(ancestor);\n\n      if (!isSingleText && isBlockAncestor && endRef.current && startRef.current) {\n        Editor.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true\n        });\n      }\n\n      var point = endRef.unref() || startRef.unref();\n\n      if (options.at == null && point) {\n        Editor.select(editor, point);\n      }\n    });\n  },\n\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\n  insertFragment: function insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$at2 = options.at,\n          at = _options$at2 === void 0 ? editor.selection : _options$at2;\n      var _options$hanging2 = options.hanging,\n          hanging = _options$hanging2 === void 0 ? false : _options$hanging2;\n\n      if (!fragment.length) {\n        return;\n      }\n\n      if (!at) {\n        return;\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges3 = Range.edges(at),\n              _Range$edges4 = slicedToArray(_Range$edges3, 2),\n              end = _Range$edges4[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Editor[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n\n      if (Editor.match(editor, at.path, 'void')) {\n        return;\n      } // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n\n\n      var inlineElementMatch = Editor.match(editor, at, 'inline-element');\n\n      if (inlineElementMatch) {\n        var _inlineElementMatch = slicedToArray(inlineElementMatch, 2),\n            _inlinePath = _inlineElementMatch[1];\n\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n\n      var blockMatch = Editor.match(editor, at, 'block');\n\n      var _blockMatch = slicedToArray(blockMatch, 2),\n          blockPath = _blockMatch[1];\n\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n\n      var _Node$first = Node.first({\n        children: fragment\n      }, []),\n          _Node$first2 = slicedToArray(_Node$first, 2),\n          firstPath = _Node$first2[1];\n\n      var _Node$last = Node.last({\n        children: fragment\n      }, []),\n          _Node$last2 = slicedToArray(_Node$last, 2),\n          lastPath = _Node$last2[1]; // TODO: convert into a proper `Nodes.matches` iterable\n\n\n      var matches = [];\n\n      var matcher = function matcher(_ref5) {\n        var _ref6 = slicedToArray(_ref5, 2),\n            n = _ref6[0],\n            p = _ref6[1];\n\n        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        return true;\n      };\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = Node.nodes({\n          children: fragment\n        }, {\n          pass: matcher\n        })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var entry = _step.value;\n\n          if (entry[1].length > 0 && matcher(entry)) {\n            matches.push(entry);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n\n      for (var _i2 = 0, _matches = matches; _i2 < _matches.length; _i2++) {\n        var _matches$_i = slicedToArray(_matches[_i2], 1),\n            node = _matches$_i[0];\n\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n\n      var inlineMatch = Editor.match(editor, at, 'inline');\n\n      var _inlineMatch = slicedToArray(inlineMatch, 2),\n          inlinePath = _inlineMatch[1];\n\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Editor.splitNodes(editor, {\n        at: at,\n        match: hasBlocks ? 'block' : 'inline'\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Editor.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: 'inline'\n      });\n      Editor.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: 'block'\n      });\n      Editor.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: 'inline'\n      });\n\n      if (!options.at) {\n        var path;\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current);\n        } else {\n          path = Path.previous(startRef.current);\n        }\n\n        var _end = Editor.end(editor, path);\n\n        Editor.select(editor, _end);\n      }\n\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\n  insertText: function insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$at3 = options.at,\n          at = _options$at3 === void 0 ? editor.selection : _options$at3;\n\n      if (!at) {\n        return;\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var pointRef = Editor.pointRef(editor, Range.end(at));\n          Editor[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Editor.match(editor, at.path, 'void')) {\n        return;\n      }\n\n      var _at = at,\n          path = _at.path,\n          offset = _at.offset;\n      editor.apply({\n        type: 'insert_text',\n        path: path,\n        offset: offset,\n        text: text\n      });\n    });\n  }\n};\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$3(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$3(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Editor = _objectSpread$3({}, ElementQueries, {}, GeneralQueries, {}, GeneralTransforms, {}, LocationQueries, {}, MarkTransforms, {}, NodeQueries, {}, NodeTransforms, {}, RangeQueries, {}, SelectionTransforms, {}, TextTransforms);\n\nvar Element = {\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\n  isElement: function isElement(value) {\n    return isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\n  isElementList: function isElementList(value) {\n    return Array.isArray(value) && (value.length === 0 || Element.isElement(value[0]));\n  },\n\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\n  matches: function matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\nvar Location = {\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\n  isLocation: function isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n};\nvar Span = {\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\n  isSpan: function isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\nvar Mark = {\n  /**\r\n   * Check if a mark exists in a set of marks.\r\n   */\n  exists: function exists(mark, marks) {\n    return !!marks.find(function (f) {\n      return Mark.matches(f, mark);\n    });\n  },\n\n  /**\r\n   * Check if a value implements the `Mark` interface.\r\n   */\n  isMark: function isMark(value) {\n    return isPlainObject(value);\n  },\n\n  /**\r\n   * Check if a value is an array of `Mark` objects.\r\n   */\n  isMarkSet: function isMarkSet(value) {\n    return Array.isArray(value) && (value.length === 0 || Mark.isMark(value[0]));\n  },\n\n  /**\r\n   * Check if a mark matches set of properties.\r\n   */\n  matches: function matches(mark, props) {\n    for (var key in props) {\n      if (mark[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\nvar Node = {\n  matches: function matches(node, props) {\n    return Element.isElement(node) && Element.matches(node, props) || Text.isText(node) && Text.matches(node, props);\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\n  ancestor: function ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return an iterable of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is bottom-up, from lowest to highest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go top-down.\r\n   */\n  ancestors:\n  /*#__PURE__*/\n  regenerator.mark(function ancestors(root, path) {\n    var options,\n        _iteratorNormalCompletion,\n        _didIteratorError,\n        _iteratorError,\n        _iterator,\n        _step,\n        p,\n        n,\n        entry,\n        _args = arguments;\n\n    return regenerator.wrap(function ancestors$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _iteratorError = undefined;\n            _context.prev = 4;\n            _iterator = Path.ancestors(path, options)[Symbol.iterator]();\n\n          case 6:\n            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n              _context.next = 15;\n              break;\n            }\n\n            p = _step.value;\n            n = Node.ancestor(root, p);\n            entry = [n, p];\n            _context.next = 12;\n            return entry;\n\n          case 12:\n            _iteratorNormalCompletion = true;\n            _context.next = 6;\n            break;\n\n          case 15:\n            _context.next = 21;\n            break;\n\n          case 17:\n            _context.prev = 17;\n            _context.t0 = _context[\"catch\"](4);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 21:\n            _context.prev = 21;\n            _context.prev = 22;\n\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n\n          case 24:\n            _context.prev = 24;\n\n            if (!_didIteratorError) {\n              _context.next = 27;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 27:\n            return _context.finish(24);\n\n          case 28:\n            return _context.finish(21);\n\n          case 29:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, ancestors, null, [[4, 17, 21, 29], [22,, 24, 28]]);\n  }),\n\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\n  child: function child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(JSON.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(JSON.stringify(root)));\n    }\n\n    return c;\n  },\n\n  /**\r\n   * Find the closest matching node entry starting from a specific path.\r\n   */\n  closest: function closest(root, path, predicate) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = Node.levels(root, path, {\n        reverse: true\n      })[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var entry = _step2.value;\n\n        if (predicate(entry)) {\n          return entry;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\n  common: function common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\n  descendant: function descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return an iterable of all the descendant node entries inside a root node.\r\n   */\n  descendants:\n  /*#__PURE__*/\n  regenerator.mark(function descendants(root) {\n    var options,\n        _iteratorNormalCompletion3,\n        _didIteratorError3,\n        _iteratorError3,\n        _iterator3,\n        _step3,\n        _step3$value,\n        node,\n        path,\n        _args2 = arguments;\n\n    return regenerator.wrap(function descendants$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            _iteratorNormalCompletion3 = true;\n            _didIteratorError3 = false;\n            _iteratorError3 = undefined;\n            _context2.prev = 4;\n            _iterator3 = Node.nodes(root, options)[Symbol.iterator]();\n\n          case 6:\n            if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n              _context2.next = 14;\n              break;\n            }\n\n            _step3$value = slicedToArray(_step3.value, 2), node = _step3$value[0], path = _step3$value[1];\n\n            if (!(path.length !== 0)) {\n              _context2.next = 11;\n              break;\n            }\n\n            _context2.next = 11;\n            return [node, path];\n\n          case 11:\n            _iteratorNormalCompletion3 = true;\n            _context2.next = 6;\n            break;\n\n          case 14:\n            _context2.next = 20;\n            break;\n\n          case 16:\n            _context2.prev = 16;\n            _context2.t0 = _context2[\"catch\"](4);\n            _didIteratorError3 = true;\n            _iteratorError3 = _context2.t0;\n\n          case 20:\n            _context2.prev = 20;\n            _context2.prev = 21;\n\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n\n          case 23:\n            _context2.prev = 23;\n\n            if (!_didIteratorError3) {\n              _context2.next = 26;\n              break;\n            }\n\n            throw _iteratorError3;\n\n          case 26:\n            return _context2.finish(23);\n\n          case 27:\n            return _context2.finish(20);\n\n          case 28:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, descendants, null, [[4, 16, 20, 28], [21,, 23, 27]]);\n  }),\n\n  /**\r\n   * Return an iterable of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\n  elements:\n  /*#__PURE__*/\n  regenerator.mark(function elements(root) {\n    var options,\n        _iteratorNormalCompletion4,\n        _didIteratorError4,\n        _iteratorError4,\n        _iterator4,\n        _step4,\n        _step4$value,\n        node,\n        path,\n        _args3 = arguments;\n\n    return regenerator.wrap(function elements$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n            _iteratorNormalCompletion4 = true;\n            _didIteratorError4 = false;\n            _iteratorError4 = undefined;\n            _context3.prev = 4;\n            _iterator4 = Node.nodes(root, options)[Symbol.iterator]();\n\n          case 6:\n            if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n              _context3.next = 14;\n              break;\n            }\n\n            _step4$value = slicedToArray(_step4.value, 2), node = _step4$value[0], path = _step4$value[1];\n\n            if (!Element.isElement(node)) {\n              _context3.next = 11;\n              break;\n            }\n\n            _context3.next = 11;\n            return [node, path];\n\n          case 11:\n            _iteratorNormalCompletion4 = true;\n            _context3.next = 6;\n            break;\n\n          case 14:\n            _context3.next = 20;\n            break;\n\n          case 16:\n            _context3.prev = 16;\n            _context3.t0 = _context3[\"catch\"](4);\n            _didIteratorError4 = true;\n            _iteratorError4 = _context3.t0;\n\n          case 20:\n            _context3.prev = 20;\n            _context3.prev = 21;\n\n            if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n              _iterator4[\"return\"]();\n            }\n\n          case 23:\n            _context3.prev = 23;\n\n            if (!_didIteratorError4) {\n              _context3.next = 26;\n              break;\n            }\n\n            throw _iteratorError4;\n\n          case 26:\n            return _context3.finish(23);\n\n          case 27:\n            return _context3.finish(20);\n\n          case 28:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, elements, null, [[4, 16, 20, 28], [21,, 23, 27]]);\n  }),\n\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\n  first: function first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\n  fragment: function fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(JSON.stringify(root)));\n    }\n\n    var newRoot = produce(root, function (r) {\n      var _Range$edges = Range.edges(range),\n          _Range$edges2 = slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n\n      var iterable = Node.nodes(r, {\n        reverse: true,\n        pass: function pass(_ref) {\n          var _ref2 = slicedToArray(_ref, 2),\n              path = _ref2[1];\n\n          return !Range.includes(range, path);\n        }\n      });\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = iterable[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _step5$value = slicedToArray(_step5.value, 2),\n              path = _step5$value[1];\n\n          if (!Range.includes(range, path)) {\n            var parent = Node.parent(r, path);\n            var index = path[path.length - 1];\n            parent.children.splice(index, 1);\n          }\n\n          if (Path.equals(path, end.path)) {\n            var leaf = Node.leaf(r, path);\n            leaf.text = leaf.text.slice(0, end.offset);\n          }\n\n          if (Path.equals(path, start.path)) {\n            var _leaf = Node.leaf(r, path);\n\n            _leaf.text = _leaf.text.slice(start.offset);\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n            _iterator5[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      delete r.selection;\n    });\n    return newRoot.children;\n  },\n\n  /**\r\n   * Find the furthest matching node entry starting from a specific path.\r\n   */\n  furthest: function furthest(root, path, predicate) {\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = Node.levels(root, path)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var entry = _step6.value;\n\n        if (predicate(entry)) {\n          return entry;\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n          _iterator6[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\n  get: function get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(JSON.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\n  has: function has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\n  isNode: function isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\n  isNodeList: function isNodeList(value) {\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]));\n  },\n\n  /**\r\n   * Get the lash node entry in a root node from a path.\r\n   */\n  last: function last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\n  leaf: function leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return an iterable of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from lowest to highest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  levels:\n  /*#__PURE__*/\n  regenerator.mark(function levels(root, path) {\n    var options,\n        _iteratorNormalCompletion7,\n        _didIteratorError7,\n        _iteratorError7,\n        _iterator7,\n        _step7,\n        p,\n        n,\n        _args4 = arguments;\n\n    return regenerator.wrap(function levels$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n            _iteratorNormalCompletion7 = true;\n            _didIteratorError7 = false;\n            _iteratorError7 = undefined;\n            _context4.prev = 4;\n            _iterator7 = Path.levels(path, options)[Symbol.iterator]();\n\n          case 6:\n            if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {\n              _context4.next = 14;\n              break;\n            }\n\n            p = _step7.value;\n            n = Node.get(root, p);\n            _context4.next = 11;\n            return [n, p];\n\n          case 11:\n            _iteratorNormalCompletion7 = true;\n            _context4.next = 6;\n            break;\n\n          case 14:\n            _context4.next = 20;\n            break;\n\n          case 16:\n            _context4.prev = 16;\n            _context4.t0 = _context4[\"catch\"](4);\n            _didIteratorError7 = true;\n            _iteratorError7 = _context4.t0;\n\n          case 20:\n            _context4.prev = 20;\n            _context4.prev = 21;\n\n            if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n              _iterator7[\"return\"]();\n            }\n\n          case 23:\n            _context4.prev = 23;\n\n            if (!_didIteratorError7) {\n              _context4.next = 26;\n              break;\n            }\n\n            throw _iteratorError7;\n\n          case 26:\n            return _context4.finish(23);\n\n          case 27:\n            return _context4.finish(20);\n\n          case 28:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, levels, null, [[4, 16, 20, 28], [21,, 23, 27]]);\n  }),\n\n  /**\r\n   * Return an iterable of all the marks in all of the text nodes in a root node.\r\n   */\n  marks:\n  /*#__PURE__*/\n  regenerator.mark(function marks(root) {\n    var options,\n        _iteratorNormalCompletion8,\n        _didIteratorError8,\n        _iteratorError8,\n        _iterator8,\n        _step8,\n        _step8$value,\n        node,\n        path,\n        i,\n        mark,\n        _args5 = arguments;\n\n    return regenerator.wrap(function marks$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n            _iteratorNormalCompletion8 = true;\n            _didIteratorError8 = false;\n            _iteratorError8 = undefined;\n            _context5.prev = 4;\n            _iterator8 = Node.texts(root, options)[Symbol.iterator]();\n\n          case 6:\n            if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {\n              _context5.next = 19;\n              break;\n            }\n\n            _step8$value = slicedToArray(_step8.value, 2), node = _step8$value[0], path = _step8$value[1];\n            i = 0;\n\n          case 9:\n            if (!(i < node.marks.length)) {\n              _context5.next = 16;\n              break;\n            }\n\n            mark = node.marks[i];\n            _context5.next = 13;\n            return [mark, i, node, path];\n\n          case 13:\n            i++;\n            _context5.next = 9;\n            break;\n\n          case 16:\n            _iteratorNormalCompletion8 = true;\n            _context5.next = 6;\n            break;\n\n          case 19:\n            _context5.next = 25;\n            break;\n\n          case 21:\n            _context5.prev = 21;\n            _context5.t0 = _context5[\"catch\"](4);\n            _didIteratorError8 = true;\n            _iteratorError8 = _context5.t0;\n\n          case 25:\n            _context5.prev = 25;\n            _context5.prev = 26;\n\n            if (!_iteratorNormalCompletion8 && _iterator8[\"return\"] != null) {\n              _iterator8[\"return\"]();\n            }\n\n          case 28:\n            _context5.prev = 28;\n\n            if (!_didIteratorError8) {\n              _context5.next = 31;\n              break;\n            }\n\n            throw _iteratorError8;\n\n          case 31:\n            return _context5.finish(28);\n\n          case 32:\n            return _context5.finish(25);\n\n          case 33:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, marks, null, [[4, 21, 25, 33], [26,, 28, 32]]);\n  }),\n\n  /**\r\n   * Return an iterable of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\n  nodes:\n  /*#__PURE__*/\n  regenerator.mark(function nodes(root) {\n    var options,\n        pass,\n        _options$reverse,\n        reverse,\n        _options$from,\n        from,\n        to,\n        visited,\n        p,\n        n,\n        nextIndex,\n        newPath,\n        _newPath,\n        _args6 = arguments;\n\n    return regenerator.wrap(function nodes$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n            pass = options.pass, _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;\n            _options$from = options.from, from = _options$from === void 0 ? [] : _options$from, to = options.to;\n            visited = new Set();\n            p = [];\n            n = root;\n\n          case 6:\n            if (!(to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to)))) {\n              _context6.next = 9;\n              break;\n            }\n\n            return _context6.abrupt(\"break\", 37);\n\n          case 9:\n            if (visited.has(n)) {\n              _context6.next = 12;\n              break;\n            }\n\n            _context6.next = 12;\n            return [n, p];\n\n          case 12:\n            if (!(!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false))) {\n              _context6.next = 19;\n              break;\n            }\n\n            visited.add(n);\n            nextIndex = reverse ? n.children.length - 1 : 0;\n\n            if (Path.isAncestor(p, from)) {\n              nextIndex = from[p.length];\n            }\n\n            p = p.concat(nextIndex);\n            n = Node.get(root, p);\n            return _context6.abrupt(\"continue\", 6);\n\n          case 19:\n            if (!(p.length === 0)) {\n              _context6.next = 21;\n              break;\n            }\n\n            return _context6.abrupt(\"break\", 37);\n\n          case 21:\n            if (reverse) {\n              _context6.next = 27;\n              break;\n            }\n\n            newPath = Path.next(p);\n\n            if (!Node.has(root, newPath)) {\n              _context6.next = 27;\n              break;\n            }\n\n            p = newPath;\n            n = Node.get(root, p);\n            return _context6.abrupt(\"continue\", 6);\n\n          case 27:\n            if (!(reverse && p[p.length - 1] !== 0)) {\n              _context6.next = 32;\n              break;\n            }\n\n            _newPath = Path.previous(p);\n            p = _newPath;\n            n = Node.get(root, p);\n            return _context6.abrupt(\"continue\", 6);\n\n          case 32:\n            // Otherwise we're going upward...\n            p = Path.parent(p);\n            n = Node.get(root, p);\n            visited.add(n);\n            _context6.next = 6;\n            break;\n\n          case 37:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, nodes);\n  }),\n\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\n  parent: function parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\n  text: function text(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.text).join('');\n    }\n  },\n\n  /**\r\n   * Return an iterable of all leaf text nodes in a root node.\r\n   */\n  texts:\n  /*#__PURE__*/\n  regenerator.mark(function texts(root) {\n    var options,\n        _iteratorNormalCompletion9,\n        _didIteratorError9,\n        _iteratorError9,\n        _iterator9,\n        _step9,\n        _step9$value,\n        node,\n        path,\n        _args7 = arguments;\n\n    return regenerator.wrap(function texts$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n            _iteratorNormalCompletion9 = true;\n            _didIteratorError9 = false;\n            _iteratorError9 = undefined;\n            _context7.prev = 4;\n            _iterator9 = Node.nodes(root, options)[Symbol.iterator]();\n\n          case 6:\n            if (_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done) {\n              _context7.next = 14;\n              break;\n            }\n\n            _step9$value = slicedToArray(_step9.value, 2), node = _step9$value[0], path = _step9$value[1];\n\n            if (!Text.isText(node)) {\n              _context7.next = 11;\n              break;\n            }\n\n            _context7.next = 11;\n            return [node, path];\n\n          case 11:\n            _iteratorNormalCompletion9 = true;\n            _context7.next = 6;\n            break;\n\n          case 14:\n            _context7.next = 20;\n            break;\n\n          case 16:\n            _context7.prev = 16;\n            _context7.t0 = _context7[\"catch\"](4);\n            _didIteratorError9 = true;\n            _iteratorError9 = _context7.t0;\n\n          case 20:\n            _context7.prev = 20;\n            _context7.prev = 21;\n\n            if (!_iteratorNormalCompletion9 && _iterator9[\"return\"] != null) {\n              _iterator9[\"return\"]();\n            }\n\n          case 23:\n            _context7.prev = 23;\n\n            if (!_didIteratorError9) {\n              _context7.next = 26;\n              break;\n            }\n\n            throw _iteratorError9;\n\n          case 26:\n            return _context7.finish(23);\n\n          case 27:\n            return _context7.finish(20);\n\n          case 28:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, texts, null, [[4, 16, 20, 28], [21,, 23, 27]]);\n  })\n};\n\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$4(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$4(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$4(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Operation = {\n  /**\r\n   * Check of a value is a `NodeOperation` object.\r\n   */\n  isNodeOperation: function isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  /**\r\n   * Check of a value is a `MarkOperation` object.\r\n   */\n  isMarkOperation: function isMarkOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_mark');\n  },\n\n  /**\r\n   * Check of a value is an `Operation` object.\r\n   */\n  isOperation: function isOperation(value) {\n    if (!isPlainObject(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'add_mark':\n        {\n          return Path.isPath(value.path) && Mark.isMark(value.mark);\n        }\n\n      case 'insert_node':\n        {\n          return Path.isPath(value.path) && Node.isNode(value.node);\n        }\n\n      case 'insert_text':\n        {\n          return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n        }\n\n      case 'merge_node':\n        {\n          return typeof value.position === 'number' && (typeof value.target === 'number' || value.target === null) && Path.isPath(value.path) && isPlainObject(value.properties);\n        }\n\n      case 'move_node':\n        {\n          return Path.isPath(value.path) && Path.isPath(value.newPath);\n        }\n\n      case 'remove_mark':\n        {\n          return Path.isPath(value.path) && Mark.isMark(value.mark);\n        }\n\n      case 'remove_node':\n        {\n          return Path.isPath(value.path) && Node.isNode(value.node);\n        }\n\n      case 'remove_text':\n        {\n          return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n        }\n\n      case 'set_mark':\n        {\n          return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);\n        }\n\n      case 'set_node':\n        {\n          return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);\n        }\n\n      case 'set_selection':\n        {\n          return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);\n        }\n\n      case 'set_value':\n        {\n          return isPlainObject(value.properties) && isPlainObject(value.newProperties);\n        }\n\n      case 'split_node':\n        {\n          return Path.isPath(value.path) && typeof value.position === 'number' && (typeof value.target === 'number' || value.target === null) && isPlainObject(value.properties);\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n  },\n\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\n  isOperationList: function isOperationList(value) {\n    return Array.isArray(value) && (value.length === 0 || Operation.isOperation(value[0]));\n  },\n\n  /**\r\n   * Check of a value is a `SelectionOperation` object.\r\n   */\n  isSelectionOperation: function isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  /**\r\n   * Check of a value is a `TextOperation` object.\r\n   */\n  isTextOperation: function isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\n  inverse: function inverse(op) {\n    switch (op.type) {\n      case 'add_mark':\n        {\n          return _objectSpread$4({}, op, {\n            type: 'remove_mark'\n          });\n        }\n\n      case 'insert_node':\n        {\n          return _objectSpread$4({}, op, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$4({}, op, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$4({}, op, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var newPath = op.newPath,\n              path = op.path; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // We need to get the original path here, but sometimes the `newPath`\n          // is a younger sibling of (or ends before) the original, and this\n          // accounts for it.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$4({}, op, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_mark':\n        {\n          return _objectSpread$4({}, op, {\n            type: 'add_mark'\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$4({}, op, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$4({}, op, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_mark':\n      case 'set_node':\n        {\n          var properties = op.properties,\n              newProperties = op.newProperties;\n          return _objectSpread$4({}, op, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var _properties = op.properties,\n              _newProperties = op.newProperties;\n\n          if (_properties == null) {\n            return _objectSpread$4({}, op, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$4({}, op, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$4({}, op, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$4({}, op, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n};\nvar Path = {\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\n  ancestors: function ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\n  common: function common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\n  compare: function compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\n  endsAfter: function endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\n  endsAt: function endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\n  endsBefore: function endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\n  equals: function equals(path, another) {\n    return path.length === another.length && path.every(function (n, i) {\n      return n === another[i];\n    });\n  },\n\n  /**\r\n   * Check if a path is after another.\r\n   */\n  isAfter: function isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\n  isAncestor: function isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is before another.\r\n   */\n  isBefore: function isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  /**\r\n   * Check if a path is a child of another.\r\n   */\n  isChild: function isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\n  isCommon: function isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\n  isDescendant: function isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\n  isParent: function isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\n  isPath: function isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\n  isSibling: function isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\n  levels: function levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse2 = options.reverse,\n        reverse = _options$reverse2 === void 0 ? false : _options$reverse2;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\n  next: function next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\n  parent: function parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\n  previous: function previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\n  relative: function relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  /**\r\n   * Transform a path by an operation.\r\n   */\n  transform: function transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(path, function (p) {\n      var _options$affinity = options.affinity,\n          affinity = _options$affinity === void 0 ? 'forward' : _options$affinity; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n      if (path.length === 0) {\n        return;\n      }\n\n      switch (operation.type) {\n        case 'insert_node':\n          {\n            var op = operation.path;\n\n            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n              p[op.length - 1] += 1;\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            var _op = operation.path;\n\n            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n              return null;\n            } else if (Path.endsBefore(_op, p)) {\n              p[_op.length - 1] -= 1;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            var _op2 = operation.path,\n                position = operation.position;\n\n            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n            } else if (Path.isAncestor(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n              p[_op2.length] += position;\n            }\n\n            break;\n          }\n\n        case 'split_node':\n          {\n            var _op3 = operation.path,\n                _position = operation.position;\n\n            if (Path.equals(_op3, p)) {\n              if (affinity === 'forward') {\n                p[p.length - 1] += 1;\n              } else if (affinity === 'backward') ;else {\n                return null;\n              }\n            } else if (Path.endsBefore(_op3, p)) {\n              p[_op3.length - 1] += 1;\n            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n              p[_op3.length - 1] += 1;\n              p[_op3.length] -= _position;\n            }\n\n            break;\n          }\n\n        case 'move_node':\n          {\n            var _op4 = operation.path,\n                onp = operation.newPath; // If the old and new path are the same, it's a no-op.\n\n            if (Path.equals(_op4, onp)) {\n              return;\n            }\n\n            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n              var copy = onp.slice();\n\n              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                var i = Math.min(onp.length, _op4.length) - 1;\n                copy[i] -= 1;\n              }\n\n              return copy.concat(p.slice(_op4.length));\n            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              }\n\n              p[onp.length - 1] += 1;\n            } else if (Path.endsBefore(_op4, p)) {\n              if (Path.equals(onp, p)) {\n                p[onp.length - 1] += 1;\n              }\n\n              p[_op4.length - 1] -= 1;\n            }\n\n            break;\n          }\n      }\n    });\n  }\n};\nvar PathRef = {\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$5(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$5(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$5(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$5(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Point = {\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\n  compare: function compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Check if a point is after another.\r\n   */\n  isAfter: function isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  /**\r\n   * Check if a point is before another.\r\n   */\n  isBefore: function isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\n  equals: function equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\n  isPoint: function isPoint(value) {\n    return isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  /**\r\n   * Transform a point by an operation.\r\n   */\n  transform: function transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(point, function (p) {\n      var _options$affinity = options.affinity,\n          affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n      var path = p.path,\n          offset = p.offset;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$5({}, options, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n};\nvar PointRef = {\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$6(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$6(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$6(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$6(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Range = {\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\n  edges: function edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse = options.reverse,\n        reverse = _options$reverse === void 0 ? false : _options$reverse;\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  /**\r\n   * Get the end point of a range.\r\n   */\n  end: function end(range) {\n    var _Range$edges = Range.edges(range),\n        _Range$edges2 = slicedToArray(_Range$edges, 2),\n        end = _Range$edges2[1];\n\n    return end;\n  },\n\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\n  equals: function equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  /**\r\n   * Check if a range exists in a list or map of ranges.\r\n   */\n  exists: function exists(range, target) {\n    if (Range.isRangeList(target)) {\n      return !!target.find(function (r) {\n        return Range.equals(r, range);\n      });\n    }\n\n    if (Range.isRangeMap(target)) {\n      for (var key in target) {\n        if (Range.equals(range, target[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\n  includes: function includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var _Range$edges3 = Range.edges(range),\n          _Range$edges4 = slicedToArray(_Range$edges3, 2),\n          rs = _Range$edges4[0],\n          re = _Range$edges4[1];\n\n      var _Range$edges5 = Range.edges(target),\n          _Range$edges6 = slicedToArray(_Range$edges5, 2),\n          ts = _Range$edges6[0],\n          te = _Range$edges6[1];\n\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var _Range$edges7 = Range.edges(range),\n        _Range$edges8 = slicedToArray(_Range$edges7, 2),\n        start = _Range$edges8[0],\n        end = _Range$edges8[1];\n\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\n  intersection: function intersection(range, another) {\n    var anchor = range.anchor,\n        focus = range.focus,\n        rest = objectWithoutProperties(range, [\"anchor\", \"focus\"]);\n\n    var _Range$edges9 = Range.edges(range),\n        _Range$edges10 = slicedToArray(_Range$edges9, 2),\n        s1 = _Range$edges10[0],\n        e1 = _Range$edges10[1];\n\n    var _Range$edges11 = Range.edges(another),\n        _Range$edges12 = slicedToArray(_Range$edges11, 2),\n        s2 = _Range$edges12[0],\n        e2 = _Range$edges12[1];\n\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$6({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\n  isBackward: function isBackward(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.isAfter(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\n  isCollapsed: function isCollapsed(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.equals(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\n  isExpanded: function isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\n  isForward: function isForward(range) {\n    return !Range.isBackward(range);\n  },\n\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\n  isRange: function isRange(value) {\n    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  /**\r\n   * Check if a value is an array of `Range` objects.\r\n   */\n  isRangeList: function isRangeList(value) {\n    return Array.isArray(value) && (value.length === 0 || Range.isRange(value[0]));\n  },\n\n  /**\r\n   * Check if a value is a map of `Range` objects.\r\n   */\n  isRangeMap: function isRangeMap(value) {\n    if (!isPlainObject(value)) {\n      return false;\n    }\n\n    for (var key in value) {\n      return Range.isRange(value[key]);\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\n  points:\n  /*#__PURE__*/\n  regenerator.mark(function points(range) {\n    return regenerator.wrap(function points$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return [range.anchor, 'anchor'];\n\n          case 2:\n            _context.next = 4;\n            return [range.focus, 'focus'];\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, points);\n  }),\n\n  /**\r\n   * Get the start point of a range.\r\n   */\n  start: function start(range) {\n    var _Range$edges13 = Range.edges(range),\n        _Range$edges14 = slicedToArray(_Range$edges13, 1),\n        start = _Range$edges14[0];\n\n    return start;\n  },\n\n  /**\r\n   * Transform a range by an operation.\r\n   */\n  transform: function transform(range, op, options) {\n    var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'inward' : _options$affinity;\n    var affinityAnchor;\n    var affinityFocus;\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      } else {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      } else {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      }\n    } else {\n      affinityAnchor = affinity;\n      affinityFocus = affinity;\n    }\n\n    return produce(range, function (r) {\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n};\nvar RangeRef = {\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Range.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\nvar Text = {\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\n  isText: function isText(value) {\n    return isPlainObject(value) && typeof value.text === 'string' && Array.isArray(value.marks);\n  },\n\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\n  isTextList: function isTextList(value) {\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]));\n  },\n\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal. However, if `marks` are passed it\r\n   * will ensure that the set of marks is exactly equal.\r\n   */\n  matches: function matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (key === 'marks' && props.marks != null) {\n        var existing = text.marks;\n        var marks = props.marks; // PERF: If the lengths aren't the same, we know it's not a match.\n\n        if (existing.length !== marks.length) {\n          return false;\n        }\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = existing[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var m = _step.value;\n\n            if (!Mark.exists(m, marks)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = marks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _m = _step2.value;\n\n            if (!Mark.exists(_m, existing)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        continue;\n      }\n\n      if (text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\nexport { Command, Editor, Element, Location, Mark, Node, Operation, Path, PathRef, Point, PointRef, Range, RangeRef, Span, Text, createEditor };","function isElement(el) {\n  return el != null && typeof el === 'object' && el.nodeType === 1;\n}\n\nfunction canOverflow(overflow, skipOverflowHiddenElements) {\n  if (skipOverflowHiddenElements && overflow === 'hidden') {\n    return false;\n  }\n\n  return overflow !== 'visible' && overflow !== 'clip';\n}\n\nfunction isScrollable(el, skipOverflowHiddenElements) {\n  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {\n    var style = getComputedStyle(el, null);\n    return canOverflow(style.overflowY, skipOverflowHiddenElements) || canOverflow(style.overflowX, skipOverflowHiddenElements);\n  }\n\n  return false;\n}\n\nfunction alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {\n  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {\n    return 0;\n  }\n\n  if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {\n    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;\n  }\n\n  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {\n    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;\n  }\n\n  return 0;\n}\n\nexport default (function (target, options) {\n  var scrollMode = options.scrollMode,\n      block = options.block,\n      inline = options.inline,\n      boundary = options.boundary,\n      skipOverflowHiddenElements = options.skipOverflowHiddenElements;\n  var checkBoundary = typeof boundary === 'function' ? boundary : function (node) {\n    return node !== boundary;\n  };\n\n  if (!isElement(target)) {\n    throw new TypeError('Invalid target');\n  }\n\n  var scrollingElement = document.scrollingElement || document.documentElement;\n  var frames = [];\n  var cursor = target;\n\n  while (isElement(cursor) && checkBoundary(cursor)) {\n    cursor = cursor.parentNode;\n\n    if (cursor === scrollingElement) {\n      frames.push(cursor);\n      break;\n    }\n\n    if (cursor === document.body && isScrollable(cursor) && !isScrollable(document.documentElement)) {\n      continue;\n    }\n\n    if (isScrollable(cursor, skipOverflowHiddenElements)) {\n      frames.push(cursor);\n    }\n  }\n\n  var viewportWidth = window.visualViewport ? visualViewport.width : innerWidth;\n  var viewportHeight = window.visualViewport ? visualViewport.height : innerHeight;\n  var viewportX = window.scrollX || pageXOffset;\n  var viewportY = window.scrollY || pageYOffset;\n\n  var _target$getBoundingCl = target.getBoundingClientRect(),\n      targetHeight = _target$getBoundingCl.height,\n      targetWidth = _target$getBoundingCl.width,\n      targetTop = _target$getBoundingCl.top,\n      targetRight = _target$getBoundingCl.right,\n      targetBottom = _target$getBoundingCl.bottom,\n      targetLeft = _target$getBoundingCl.left;\n\n  var targetBlock = block === 'start' || block === 'nearest' ? targetTop : block === 'end' ? targetBottom : targetTop + targetHeight / 2;\n  var targetInline = inline === 'center' ? targetLeft + targetWidth / 2 : inline === 'end' ? targetRight : targetLeft;\n  var computations = [];\n\n  for (var index = 0; index < frames.length; index++) {\n    var frame = frames[index];\n\n    var _frame$getBoundingCli = frame.getBoundingClientRect(),\n        _height = _frame$getBoundingCli.height,\n        _width = _frame$getBoundingCli.width,\n        _top = _frame$getBoundingCli.top,\n        right = _frame$getBoundingCli.right,\n        bottom = _frame$getBoundingCli.bottom,\n        _left = _frame$getBoundingCli.left;\n\n    if (scrollMode === 'if-needed' && targetTop >= 0 && targetLeft >= 0 && targetBottom <= viewportHeight && targetRight <= viewportWidth && targetTop >= _top && targetBottom <= bottom && targetLeft >= _left && targetRight <= right) {\n      return computations;\n    }\n\n    var frameStyle = getComputedStyle(frame);\n    var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);\n    var borderTop = parseInt(frameStyle.borderTopWidth, 10);\n    var borderRight = parseInt(frameStyle.borderRightWidth, 10);\n    var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);\n    var blockScroll = 0;\n    var inlineScroll = 0;\n    var scrollbarWidth = 'offsetWidth' in frame ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight : 0;\n    var scrollbarHeight = 'offsetHeight' in frame ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom : 0;\n\n    if (scrollingElement === frame) {\n      if (block === 'start') {\n        blockScroll = targetBlock;\n      } else if (block === 'end') {\n        blockScroll = targetBlock - viewportHeight;\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);\n      } else {\n        blockScroll = targetBlock - viewportHeight / 2;\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline;\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - viewportWidth / 2;\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - viewportWidth;\n      } else {\n        inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);\n      }\n\n      blockScroll = Math.max(0, blockScroll + viewportY);\n      inlineScroll = Math.max(0, inlineScroll + viewportX);\n    } else {\n      if (block === 'start') {\n        blockScroll = targetBlock - _top - borderTop;\n      } else if (block === 'end') {\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(_top, bottom, _height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);\n      } else {\n        blockScroll = targetBlock - (_top + _height / 2) + scrollbarHeight / 2;\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline - _left - borderLeft;\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - (_left + _width / 2) + scrollbarWidth / 2;\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth;\n      } else {\n        inlineScroll = alignNearest(_left, right, _width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);\n      }\n\n      var scrollLeft = frame.scrollLeft,\n          scrollTop = frame.scrollTop;\n      blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - _height + scrollbarHeight));\n      inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - _width + scrollbarWidth));\n      targetBlock += scrollTop - blockScroll;\n      targetInline += scrollLeft - inlineScroll;\n    }\n\n    computations.push({\n      el: frame,\n      top: blockScroll,\n      left: inlineScroll\n    });\n  }\n\n  return computations;\n});","import compute from 'compute-scroll-into-view';\n\nfunction isOptionsObject(options) {\n  return options === Object(options) && Object.keys(options).length !== 0;\n}\n\nfunction defaultBehavior(actions, behavior) {\n  if (behavior === void 0) {\n    behavior = 'auto';\n  }\n\n  var canSmoothScroll = 'scrollBehavior' in document.body.style;\n  actions.forEach(function (_ref) {\n    var el = _ref.el,\n        top = _ref.top,\n        left = _ref.left;\n\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({\n        top: top,\n        left: left,\n        behavior: behavior\n      });\n    } else {\n      el.scrollTop = top;\n      el.scrollLeft = left;\n    }\n  });\n}\n\nfunction getOptions(options) {\n  if (options === false) {\n    return {\n      block: 'end',\n      inline: 'nearest'\n    };\n  }\n\n  if (isOptionsObject(options)) {\n    return options;\n  }\n\n  return {\n    block: 'start',\n    inline: 'nearest'\n  };\n}\n\nfunction scrollIntoView(target, options) {\n  var targetIsDetached = !target.ownerDocument.documentElement.contains(target);\n\n  if (isOptionsObject(options) && typeof options.behavior === 'function') {\n    return options.behavior(targetIsDetached ? [] : compute(target, options));\n  }\n\n  if (targetIsDetached) {\n    return;\n  }\n\n  var computeOptions = getOptions(options);\n  return defaultBehavior(compute(target, computeOptions), computeOptions.behavior);\n}\n\nexport default scrollIntoView;","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\nimport isObject from 'isobject';\n\nfunction isObjectObject(o) {\n  return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport default function isPlainObject(o) {\n  var ctor, prot;\n  if (isObjectObject(o) === false) return false; // If has modified constructor\n\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false; // If has modified prototype\n\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false; // If constructor does not have an Object-specific method\n\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n;","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\nexport default function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n}\n;","import _objectWithoutProperties from \"C:\\\\Users\\\\lkort\\\\Documents\\\\Projects\\\\D\\\\daterra\\\\studata-frontend\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"C:\\\\Users\\\\lkort\\\\Documents\\\\Projects\\\\D\\\\daterra\\\\studata-frontend\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _slicedToArray2 from \"C:\\\\Users\\\\lkort\\\\Documents\\\\Projects\\\\D\\\\daterra\\\\studata-frontend\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useRef, useLayoutEffect, createContext, useContext, useState, useMemo, useCallback } from 'react';\nimport { Path, Node as Node$1, Editor, Mark, Range, Element as Element$1, Command } from 'slate';\nimport debounce from 'debounce';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport getDirection from 'direction';\nimport isPlainObject from 'is-plain-object';\nimport { isKeyHotkey } from 'is-hotkey';\n/**\r\n * Leaf content strings.\r\n */\n\nvar String = function String(props) {\n  var isLast = props.isLast,\n      leaf = props.leaf,\n      parent = props.parent,\n      text = props.text;\n  var editor = useEditor();\n  var path = ReactEditor.findPath(editor, text);\n  var parentPath = Path.parent(path); // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n\n  if (editor.isVoid(parent)) {\n    return React.createElement(ZeroWidthString, {\n      length: Node$1.text(parent).length\n    });\n  } // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n\n\n  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && Editor.text(editor, parentPath) === '') {\n    return React.createElement(ZeroWidthString, {\n      isLineBreak: true\n    });\n  } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n\n\n  if (leaf.text === '') {\n    return React.createElement(ZeroWidthString, null);\n  } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n\n\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return React.createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n\n  return React.createElement(TextString, {\n    text: leaf.text\n  });\n};\n/**\r\n * Leaf strings with text in them.\r\n */\n\n\nvar TextString = function TextString(props) {\n  var text = props.text,\n      _props$isTrailing = props.isTrailing,\n      isTrailing = _props$isTrailing === void 0 ? false : _props$isTrailing;\n  return React.createElement(\"span\", {\n    \"data-slate-string\": true\n  }, text, isTrailing ? '\\n' : null);\n};\n/**\r\n * Leaf strings without text, render as zero-width strings.\r\n */\n\n\nvar ZeroWidthString = function ZeroWidthString(props) {\n  var _props$length = props.length,\n      length = _props$length === void 0 ? 0 : _props$length,\n      _props$isLineBreak = props.isLineBreak,\n      isLineBreak = _props$isLineBreak === void 0 ? false : _props$isLineBreak;\n  return React.createElement(\"span\", {\n    \"data-slate-zero-width\": isLineBreak ? 'n' : 'z',\n    \"data-slate-length\": length\n  }, \"\\uFEFF\", isLineBreak ? React.createElement(\"br\", null) : null);\n};\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nvar arrayWithoutHoles = _arrayWithoutHoles;\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nvar iterableToArray = _iterableToArray;\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar nonIterableSpread = _nonIterableSpread;\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nvar toConsumableArray = _toConsumableArray;\nvar Leaf;\n\n(function (Leaf) {\n  /**\r\n   * Check if two leaves are equal.\r\n   */\n  Leaf.equals = function (leaf, another) {\n    return leaf.text === another.text && leaf.decorations.length === another.decorations.length && leaf.marks.length === another.marks.length && leaf.marks.every(function (m) {\n      return Mark.exists(m, another.marks);\n    }) && another.marks.every(function (m) {\n      return Mark.exists(m, leaf.marks);\n    }) && isRangeListEqual(leaf.decorations, another.decorations);\n  };\n  /**\r\n   * Check if a value is a `Leaf` object.\r\n   */\n\n\n  Leaf.isLeaf = function (value) {\n    return isPlainObject(value) && typeof value.text === 'string' && Mark.isMarkSet(value.marks) && Range.isRangeList(value.decorations);\n  };\n  /**\r\n   * Split a leaf into two at an offset.\r\n   */\n\n\n  Leaf.split = function (leaf, offset) {\n    return [{\n      text: leaf.text.slice(0, offset),\n      marks: leaf.marks,\n      decorations: toConsumableArray(leaf.decorations)\n    }, {\n      text: leaf.text.slice(offset),\n      marks: leaf.marks,\n      decorations: toConsumableArray(leaf.decorations)\n    }];\n  };\n})(Leaf || (Leaf = {}));\n/**\r\n * Check if a list of ranges is equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */\n\n\nvar isRangeListEqual = function isRangeListEqual(list, another) {\n  if (list.length !== another.length) {\n    return false;\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n\n    if (!Range.equals(range, other)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\r\n * Two weak maps that allow us rebuild a path given a node. They are populated\r\n * at render time such that after a render occurs we can always backtrack.\r\n */\n\n\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\r\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\r\n * are used to resolve DOM event-related logic into Slate actions.\r\n */\n\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar KEY_TO_ELEMENT = new WeakMap();\n/**\r\n * Weak maps for storing editor-related state.\r\n */\n\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\n/**\r\n * Symbols.\r\n */\n\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\n/**\r\n * Individual leaves in a text node with unique formatting.\r\n */\n\nvar Leaf$1 = function Leaf$1(props) {\n  var leaf = props.leaf,\n      isLast = props.isLast,\n      text = props.text,\n      parent = props.parent,\n      _props$renderDecorati = props.renderDecoration,\n      renderDecoration = _props$renderDecorati === void 0 ? function (props) {\n    return React.createElement(DefaultDecoration, Object.assign({}, props));\n  } : _props$renderDecorati,\n      _props$renderMark = props.renderMark,\n      renderMark = _props$renderMark === void 0 ? function (props) {\n    return React.createElement(DefaultMark, Object.assign({}, props));\n  } : _props$renderMark;\n  var children = React.createElement(String, {\n    isLast: isLast,\n    leaf: leaf,\n    parent: parent,\n    text: text\n  }); // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = leaf.marks[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var mark = _step4.value;\n      var ret = renderMark({\n        children: children,\n        leaf: leaf,\n        mark: mark,\n        text: text,\n        attributes: {\n          'data-slate-mark': true\n        }\n      });\n\n      if (ret) {\n        children = ret;\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = leaf.decorations[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var decoration = _step5.value;\n      var p = {\n        children: children,\n        decoration: decoration,\n        leaf: leaf,\n        text: text,\n        attributes: {\n          'data-slate-decoration': true\n        }\n      };\n\n      if (PLACEHOLDER_SYMBOL in decoration) {\n        // @ts-ignore\n        children = React.createElement(PlaceholderDecoration, Object.assign({}, p));\n      } else {\n        // @ts-ignore\n        var _ret = renderDecoration(p);\n\n        if (_ret) {\n          children = _ret;\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  return React.createElement(\"span\", {\n    \"data-slate-leaf\": true\n  }, children);\n};\n\nvar MemoizedLeaf = React.memo(Leaf$1, function (prev, next) {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderDecoration === prev.renderDecoration && next.renderMark === prev.renderMark && next.text === prev.text && Leaf.equals(next.leaf, prev.leaf);\n});\n/**\r\n * The default custom decoration renderer.\r\n */\n\nvar DefaultDecoration = function DefaultDecoration(props) {\n  var attributes = props.attributes,\n      children = props.children;\n  return React.createElement(\"span\", Object.assign({}, attributes), children);\n};\n/**\r\n * The default custom mark renderer.\r\n */\n\n\nvar DefaultMark = function DefaultMark(props) {\n  var attributes = props.attributes,\n      children = props.children;\n  return React.createElement(\"span\", Object.assign({}, attributes), children);\n};\n/**\r\n * A custom decoration for the default placeholder behavior.\r\n */\n\n\nvar PlaceholderDecoration = function PlaceholderDecoration(props) {\n  var decoration = props.decoration,\n      attributes = props.attributes,\n      children = props.children;\n  var placeholder = decoration.placeholder;\n  return React.createElement(\"span\", Object.assign({}, attributes), React.createElement(\"span\", {\n    contentEditable: false,\n    style: {\n      pointerEvents: 'none',\n      display: 'inline-block',\n      verticalAlign: 'text-top',\n      width: '0',\n      maxWidth: '100%',\n      whiteSpace: 'nowrap',\n      opacity: '0.333'\n    }\n  }, placeholder), children);\n};\n/**\r\n * Text.\r\n */\n\n\nvar Text = function Text(props) {\n  var decorations = props.decorations,\n      isLast = props.isLast,\n      parent = props.parent,\n      renderDecoration = props.renderDecoration,\n      renderMark = props.renderMark,\n      text = props.text;\n  var editor = useEditor();\n  var ref = useRef(null);\n  var leaves = getLeaves(text, decorations);\n  var key = ReactEditor.findKey(editor, text);\n  var children = [];\n\n  for (var i = 0; i < leaves.length; i++) {\n    var leaf = leaves[i];\n    children.push(React.createElement(MemoizedLeaf, {\n      isLast: isLast && i === leaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i),\n      leaf: leaf,\n      text: text,\n      parent: parent,\n      renderDecoration: renderDecoration,\n      renderMark: renderMark\n    }));\n  } // Update element-related weak maps with the DOM element ref.\n\n\n  useLayoutEffect(function () {\n    if (ref.current) {\n      KEY_TO_ELEMENT.set(key, ref.current);\n      NODE_TO_ELEMENT.set(text, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, text);\n    } else {\n      KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(text);\n    }\n  });\n  return React.createElement(\"span\", {\n    \"data-slate-node\": \"text\",\n    ref: ref\n  }, children);\n};\n/**\r\n * Get the leaves for a text node given decorations.\r\n */\n\n\nvar getLeaves = function getLeaves(node, decorations) {\n  var text = node.text,\n      marks = node.marks;\n  var leaves = [{\n    text: text,\n    marks: marks,\n    decorations: []\n  }];\n\n  var compile = function compile(range, key) {\n    var _Range$edges = Range.edges(range),\n        _Range$edges2 = _slicedToArray2(_Range$edges, 2),\n        start = _Range$edges2[0],\n        end = _Range$edges2[1];\n\n    var next = [];\n    var o = 0;\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = leaves[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var leaf = _step6.value;\n        var length = leaf.text.length;\n        var offset = o;\n        o += length; // If the range encompases the entire leaf, add the range.\n\n        if (start.offset <= offset && end.offset >= offset + length) {\n          leaf.decorations.push(range);\n          next.push(leaf);\n          continue;\n        } // If the range starts after the leaf, or ends before it, continue.\n\n\n        if (start.offset > offset + length || end.offset < offset || end.offset === offset && offset !== 0) {\n          next.push(leaf);\n          continue;\n        } // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n\n\n        var middle = leaf;\n        var before = void 0;\n        var after = void 0;\n\n        if (end.offset < offset + length) {\n          var _Leaf$split = Leaf.split(middle, end.offset - offset);\n\n          var _Leaf$split2 = _slicedToArray2(_Leaf$split, 2);\n\n          middle = _Leaf$split2[0];\n          after = _Leaf$split2[1];\n        }\n\n        if (start.offset > offset) {\n          var _Leaf$split3 = Leaf.split(middle, start.offset - offset);\n\n          var _Leaf$split4 = _slicedToArray2(_Leaf$split3, 2);\n\n          before = _Leaf$split4[0];\n          middle = _Leaf$split4[1];\n        }\n\n        middle.decorations.push(range);\n\n        if (before) {\n          next.push(before);\n        }\n\n        next.push(middle);\n\n        if (after) {\n          next.push(after);\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n\n    leaves = next;\n  };\n\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = decorations[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var range = _step7.value;\n      compile(range);\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n\n  return leaves;\n};\n\nvar MemoizedText = React.memo(Text, function (prev, next) {\n  if (next.parent === prev.parent && next.isLast === prev.isLast && next.renderDecoration === prev.renderDecoration && next.renderMark === prev.renderMark && next.text === prev.text) {\n    return Leaf.equals(_objectSpread({}, next.text, {\n      decorations: next.decorations\n    }), _objectSpread({}, prev.text, {\n      decorations: prev.decorations\n    }));\n  }\n\n  return false;\n});\n/**\r\n * A React context for sharing the `selected` state of an element.\r\n */\n\nvar SelectedContext = createContext(false);\n/**\r\n * Get the current `selected` state of an element.\r\n */\n\nvar useSelected = function useSelected() {\n  return useContext(SelectedContext);\n};\n/**\r\n * Element.\r\n */\n\n\nvar Element = function Element(props) {\n  var decorate = props.decorate,\n      decorations = props.decorations,\n      element = props.element,\n      renderDecoration = props.renderDecoration,\n      _props$renderElement = props.renderElement,\n      renderElement = _props$renderElement === void 0 ? function (p) {\n    return React.createElement(DefaultElement, Object.assign({}, p));\n  } : _props$renderElement,\n      renderMark = props.renderMark,\n      selection = props.selection;\n  var ref = useRef(null);\n  var editor = useEditor();\n  var readOnly = useReadOnly();\n  var isInline = editor.isInline(element);\n  var key = ReactEditor.findKey(editor, element);\n  var children = React.createElement(Children, {\n    decorate: decorate,\n    decorations: decorations,\n    node: element,\n    renderDecoration: renderDecoration,\n    renderElement: renderElement,\n    renderMark: renderMark,\n    selection: selection\n  }); // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n\n  var attributes = {\n    'data-slate-node': 'element',\n    ref: ref\n  };\n\n  if (isInline) {\n    attributes['data-slate-inline'] = true;\n  } // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n\n\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    var text = Node$1.text(element);\n    var dir = getDirection(text);\n\n    if (dir === 'rtl') {\n      attributes.dir = dir;\n    }\n  } // If it's a void node, wrap the children in extra void-specific elements.\n\n\n  if (editor.isVoid(element)) {\n    attributes['data-slate-void'] = true;\n\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false;\n    }\n\n    var Tag = isInline ? 'span' : 'div';\n\n    var _Node$1$texts = Node$1.texts(element),\n        _Node$1$texts2 = _slicedToArray2(_Node$1$texts, 1),\n        _Node$1$texts2$ = _slicedToArray2(_Node$1$texts2[0], 1),\n        _text = _Node$1$texts2$[0];\n\n    children = readOnly ? null : React.createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      }\n    }, React.createElement(MemoizedText, {\n      decorations: [],\n      isLast: false,\n      parent: element,\n      text: _text\n    }));\n    NODE_TO_INDEX.set(_text, 0);\n    NODE_TO_PARENT.set(_text, element);\n  } // Update element-related weak maps with the DOM element ref.\n\n\n  useLayoutEffect(function () {\n    if (ref.current) {\n      KEY_TO_ELEMENT.set(key, ref.current);\n      NODE_TO_ELEMENT.set(element, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, element);\n    } else {\n      KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(element);\n    }\n  });\n  return React.createElement(SelectedContext.Provider, {\n    value: !!selection\n  }, renderElement({\n    attributes: attributes,\n    children: children,\n    element: element\n  }));\n};\n\nvar MemoizedElement = React.memo(Element, function (prev, next) {\n  return prev.decorate === next.decorate && prev.element === next.element && prev.renderDecoration === next.renderDecoration && prev.renderElement === next.renderElement && prev.renderMark === next.renderMark && isRangeListEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection));\n});\n/**\r\n * The default element renderer.\r\n */\n\nvar DefaultElement = function DefaultElement(props) {\n  var attributes = props.attributes,\n      children = props.children,\n      element = props.element;\n  var editor = useEditor();\n  var Tag = editor.isInline(element) ? 'span' : 'div';\n  return React.createElement(Tag, Object.assign({}, attributes, {\n    style: {\n      position: 'relative'\n    }\n  }), children);\n};\n/**\r\n * A React context for sharing the `Editor` class.\r\n */\n\n\nvar EditorContext = createContext(null);\n/**\r\n * Get the current `Editor` class that the component lives under.\r\n */\n\nvar useEditor = function useEditor() {\n  var editor = useContext(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n/**\r\n * Children.\r\n */\n\n\nvar Children = function Children(props) {\n  var decorate = props.decorate,\n      decorations = props.decorations,\n      node = props.node,\n      renderDecoration = props.renderDecoration,\n      renderElement = props.renderElement,\n      renderMark = props.renderMark,\n      selection = props.selection;\n  var editor = useEditor();\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  var isLeafBlock = Element$1.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node);\n\n  for (var i = 0; i < node.children.length; i++) {\n    var p = path.concat(i);\n    var _n2 = node.children[i];\n    var key = ReactEditor.findKey(editor, _n2);\n    var range = Editor.range(editor, p);\n    var sel = selection && Range.intersection(range, selection);\n    var ds = decorate([_n2, p]);\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      for (var _iterator8 = decorations[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var dec = _step8.value;\n        var d = Range.intersection(dec, range);\n\n        if (d) {\n          ds.push(d);\n        }\n      }\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n\n    if (Element$1.isElement(_n2)) {\n      children.push(React.createElement(MemoizedElement, {\n        decorate: decorate,\n        decorations: ds,\n        element: _n2,\n        key: key.id,\n        renderDecoration: renderDecoration,\n        renderElement: renderElement,\n        renderMark: renderMark,\n        selection: sel\n      }));\n    } else {\n      children.push(React.createElement(MemoizedText, {\n        decorations: ds,\n        key: key.id,\n        isLast: isLeafBlock && i === node.children.length,\n        parent: node,\n        renderDecoration: renderDecoration,\n        renderMark: renderMark,\n        text: _n2\n      }));\n    }\n\n    NODE_TO_INDEX.set(_n2, i);\n    NODE_TO_PARENT.set(_n2, node);\n  }\n\n  return React.createElement(React.Fragment, null, children);\n};\n\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_SAFARI = typeof navigator !== 'undefined' && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent);\n/**\r\n * Hotkey mappings for each platform.\r\n */\n\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  splitBlock: 'shift?+enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\r\n * Create a platform-aware hotkey checker.\r\n */\n\nvar create = function create(key) {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && isKeyHotkey(generic);\n  var isApple = apple && isKeyHotkey(apple);\n  var isWindows = windows && isKeyHotkey(windows);\n  return function (event) {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\r\n * Hotkeys.\r\n */\n\n\nvar Hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n/**\r\n * A React context for sharing the `readOnly` state of the editor.\r\n */\n\nvar ReadOnlyContext = createContext(false);\n/**\r\n * Get the current `readOnly` state of the editor.\r\n */\n\nvar useReadOnly = function useReadOnly() {\n  return useContext(ReadOnlyContext);\n};\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar arrayWithHoles = _arrayWithHoles;\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nvar iterableToArrayLimit = _iterableToArrayLimit;\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar nonIterableRest = _nonIterableRest;\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nvar slicedToArray = _slicedToArray;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar classCallCheck = _classCallCheck;\n/**\r\n * An auto-incrementing identifier for keys.\r\n */\n\nvar n = 0;\n/**\r\n * A class that keeps track of a key string. We use a full class here because we\r\n * want to be able to use them as keys in `WeakMap` objects.\r\n */\n\nvar Key = function Key() {\n  classCallCheck(this, Key);\n  this.id = \"\".concat(n++);\n};\n/**\r\n * Check if a DOM node is a comment node.\r\n */\n\n\nvar isDOMComment = function isDOMComment(value) {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\n\nvar isDOMElement = function isDOMElement(value) {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\r\n * Check if a value is a DOM node.\r\n */\n\n\nvar isDOMNode = function isDOMNode(value) {\n  return value instanceof Node;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\n\nvar isDOMText = function isDOMText(value) {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\r\n * Normalize a DOM point so that it always refers to a text node.\r\n */\n\n\nvar normalizeDOMPoint = function normalizeDOMPoint(domPoint) {\n  var _domPoint = slicedToArray(domPoint, 2),\n      node = _domPoint[0],\n      offset = _domPoint[1]; // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n\n\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var direction = isLast ? 'backward' : 'forward';\n    var index = isLast ? offset - 1 : offset;\n    node = getEditableChild(node, index, direction); // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, direction);\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return [node, offset];\n};\n/**\r\n * Get the nearest editable child at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\n\nvar getEditableChild = function getEditableChild(parent, index, direction) {\n  var childNodes = parent.childNodes;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    i += direction === 'forward' ? 1 : -1;\n  }\n\n  return child;\n};\n\nvar ReactEditor = {\n  /**\r\n   * Find a key for a Slate node.\r\n   */\n  findKey: function findKey(editor, node) {\n    var key = NODE_TO_KEY.get(node);\n\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n\n    return key;\n  },\n\n  /**\r\n   * Find the path of Slate node.\r\n   */\n  findPath: function findPath(editor, node) {\n    var path = [];\n    var child = node;\n\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n\n      var i = NODE_TO_INDEX.get(child);\n\n      if (i == null) {\n        break;\n      }\n\n      path.unshift(i);\n      child = parent;\n    }\n\n    throw new Error(\"Unable to find the path for Slate node: \".concat(JSON.stringify(node)));\n  },\n\n  /**\r\n   * Check if the editor is focused.\r\n   */\n  isFocused: function isFocused(editor) {\n    return !!IS_FOCUSED.get(editor);\n  },\n\n  /**\r\n   * Check if the editor is in read-only mode.\r\n   */\n  isReadOnly: function isReadOnly(editor) {\n    return !!IS_READ_ONLY.get(editor);\n  },\n\n  /**\r\n   * Blur the editor.\r\n   */\n  blur: function blur(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    IS_FOCUSED.set(editor, false);\n\n    if (window.document.activeElement === el) {\n      el.blur();\n    }\n  },\n\n  /**\r\n   * Focus the editor.\r\n   */\n  focus: function focus(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    IS_FOCUSED.set(editor, true);\n\n    if (window.document.activeElement !== el) {\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n\n  /**\r\n   * Deselect the editor.\r\n   */\n  deselect: function deselect(editor) {\n    var selection = editor.selection;\n    var domSelection = window.getSelection();\n\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n\n    if (selection) {\n      Editor.deselect(editor);\n    }\n  },\n\n  /**\r\n   * Check if a DOM node is within the editor.\r\n   */\n  hasDOMNode: function hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$editable = options.editable,\n        editable = _options$editable === void 0 ? false : _options$editable;\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var element; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n\n    try {\n      element = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n\n    if (!element) {\n      return false;\n    }\n\n    return element.closest(\"[data-slate-editor]\") === el && (!editable || el.isContentEditable);\n  },\n\n  /**\r\n   * Find the native DOM element from a Slate node.\r\n   */\n  toDOMNode: function toDOMNode(editor, node) {\n    var domNode = Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(JSON.stringify(node)));\n    }\n\n    return domNode;\n  },\n\n  /**\r\n   * Find a native DOM selection point from a Slate point.\r\n   */\n  toDOMPoint: function toDOMPoint(editor, point) {\n    var _Editor$node = Editor.node(editor, point.path),\n        _Editor$node2 = slicedToArray(_Editor$node, 1),\n        node = _Editor$node2[0];\n\n    var el = ReactEditor.toDOMNode(editor, node);\n    var domPoint; // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n\n    for (var _i = 0, _texts = texts; _i < _texts.length; _i++) {\n      var text = _texts[_i];\n      var domNode = text.childNodes[0];\n\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n\n      var length = domNode.textContent.length;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength;\n\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n\n      start = end;\n    }\n\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(JSON.stringify(point)));\n    }\n\n    return domPoint;\n  },\n\n  /**\r\n   * Find a native DOM range from a Slate `range`.\r\n   */\n  toDOMRange: function toDOMRange(editor, range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n    var domFocus = Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n    var domRange = window.document.createRange();\n    var start = Range.isBackward(range) ? domFocus : domAnchor;\n    var end = Range.isBackward(range) ? domAnchor : domFocus;\n    domRange.setStart(start[0], start[1]);\n    domRange.setEnd(end[0], end[1]);\n    return domRange;\n  },\n\n  /**\r\n   * Find a Slate node from a native DOM `element`.\r\n   */\n  toSlateNode: function toSlateNode(editor, domNode) {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Get the target range from a DOM `event`.\r\n   */\n  findEventRange: function findEventRange(editor, event) {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n\n    var _event = event,\n        x = _event.clientX,\n        y = _event.clientY,\n        target = _event.target;\n\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n\n    var node = ReactEditor.toSlateNode(editor, event.target);\n    var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n\n    if (Element$1.isElement(node) && editor.isVoid(node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);\n\n      if (point) {\n        var _range = Editor.range(editor, point);\n\n        return _range;\n      }\n    } // Else resolve a range from the caret position where the drop occured.\n\n\n    var domRange;\n    var _window = window,\n        document = _window.document; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    } // Resolve a Slate range from the DOM range.\n\n\n    var range = ReactEditor.toSlateRange(editor, domRange);\n    return range;\n  },\n\n  /**\r\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\r\n   */\n  toSlatePoint: function toSlatePoint(editor, domPoint) {\n    var _normalizeDOMPoint = normalizeDOMPoint(domPoint),\n        _normalizeDOMPoint2 = slicedToArray(_normalizeDOMPoint, 2),\n        nearestNode = _normalizeDOMPoint2[0],\n        nearestOffset = _normalizeDOMPoint2[1];\n\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n\n    if (parentNode) {\n      var voidNode = parentNode.closest('[data-slate-void=\"true\"]');\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n        var range = window.document.createRange();\n        range.setStart(textNode, 0);\n        range.setEnd(nearestNode, nearestOffset);\n        var contents = range.cloneContents();\n        var removals = [].concat(toConsumableArray(contents.querySelectorAll('[data-slate-zero-width]')), toConsumableArray(contents.querySelectorAll('[contenteditable=false]')));\n        removals.forEach(function (el) {\n          el.parentNode.removeChild(el);\n        }); // COMPAT: Edge has a bug where Range.prototype.toString() will\n        // convert \\n into \\r\\n. The bug causes a loop when slate-react\n        // attempts to reposition its cursor to match the native position. Use\n        // textContent.length instead.\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n        offset = contents.textContent.length;\n        domNode = textNode;\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent.\n        leafNode = voidNode.querySelector('[data-slate-leaf]');\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n        domNode = leafNode;\n        offset = domNode.textContent.length;\n      } // COMPAT: If the parent node is a Slate zero-width space, editor is\n      // because the text node should have no characters. However, during IME\n      // composition the ASCII characters will be prepended to the zero-width\n      // space, so subtract 1 from the offset to account for the zero-width\n      // space character.\n\n\n      if (domNode && offset === domNode.textContent.length && parentNode.hasAttribute('data-slate-zero-width')) {\n        offset--;\n      }\n    }\n\n    if (!textNode) {\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    } // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n\n\n    var slateNode = ReactEditor.toSlateNode(editor, textNode);\n    var path = ReactEditor.findPath(editor, slateNode);\n    return {\n      path: path,\n      offset: offset\n    };\n  },\n\n  /**\r\n   * Find a Slate range from a DOM range or selection.\r\n   */\n  toSlateRange: function toSlateRange(editor, domRange) {\n    var el = domRange instanceof Selection ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n\n    if (el) {\n      if (domRange instanceof Selection) {\n        anchorNode = domRange.anchorNode;\n        anchorOffset = domRange.anchorOffset;\n        focusNode = domRange.focusNode;\n        focusOffset = domRange.focusOffset;\n        isCollapsed = domRange.isCollapsed;\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n\n    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset]);\n    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset]);\n    return {\n      anchor: anchor,\n      focus: focus\n    };\n  }\n};\n/**\r\n * A React context for sharing the `focused` state of the editor.\r\n */\n\nvar FocusedContext = createContext(false);\n/**\r\n * Get the current `focused` state of the editor.\r\n */\n\nvar useFocused = function useFocused() {\n  return useContext(FocusedContext);\n};\n/**\r\n * Associate the context change listener with the editor.\r\n */\n\n\nvar EDITOR_TO_CONTEXT_LISTENER = new WeakMap();\n/**\r\n * A React context for sharing the `Editor` class, in a way that re-renders the\r\n * context whenever changes occur.\r\n */\n\nvar SlateContext = createContext(null);\n/**\r\n * A wrapper around the provider to handle `onChange` events, because the editor\r\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\r\n */\n\nvar Slate = function Slate(props) {\n  var editor = props.editor,\n      children = props.children,\n      _props$defaultValue = props.defaultValue,\n      defaultValue = _props$defaultValue === void 0 ? [] : _props$defaultValue,\n      _props$onChange = props.onChange,\n      onChange = _props$onChange === void 0 ? function () {} : _props$onChange;\n\n  var _useState = useState([editor]),\n      _useState2 = _slicedToArray2(_useState, 2),\n      context = _useState2[0],\n      setContext = _useState2[1];\n\n  var value = useMemo(function () {\n    return [editor];\n  }, [context, editor]);\n  var listener = useMemo(function () {\n    editor.children = defaultValue;\n    return function (children, operations) {\n      onChange(children, operations);\n      setContext([editor]);\n    };\n  }, [editor]);\n  EDITOR_TO_CONTEXT_LISTENER.set(editor, listener);\n  return React.createElement(SlateContext.Provider, {\n    value: value\n  }, React.createElement(EditorContext.Provider, {\n    value: editor\n  }, React.createElement(FocusedContext.Provider, {\n    value: ReactEditor.isFocused(editor)\n  }, children)));\n};\n/**\r\n * Get the current `Editor` class that the component lives under.\r\n */\n\n\nvar useSlate = function useSlate() {\n  var context = useContext(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <SlateProvider> component's context.\");\n  }\n\n  var _context = _slicedToArray2(context, 1),\n      editor = _context[0];\n\n  return editor;\n};\n/**\r\n * Editable.\r\n */\n\n\nvar Editable = function Editable(props) {\n  var _props$decorate = props.decorate,\n      decorate = _props$decorate === void 0 ? defaultDecorate : _props$decorate,\n      placeholder = props.placeholder,\n      _props$readOnly = props.readOnly,\n      readOnly = _props$readOnly === void 0 ? false : _props$readOnly,\n      renderDecoration = props.renderDecoration,\n      renderElement = props.renderElement,\n      renderMark = props.renderMark,\n      _props$style = props.style,\n      style = _props$style === void 0 ? {} : _props$style,\n      propsOnDOMBeforeInput = props.onDOMBeforeInput,\n      attributes = _objectWithoutProperties(props, [\"decorate\", \"placeholder\", \"readOnly\", \"renderDecoration\", \"renderElement\", \"renderMark\", \"style\", \"onDOMBeforeInput\"]);\n\n  var editor = useSlate();\n  var ref = useRef(null); // Update internal state on each render.\n\n  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.\n\n  var state = useMemo(function () {\n    return {\n      isComposing: false,\n      isUpdatingSelection: false,\n      latestElement: null\n    };\n  }, []); // Update element-related weak maps with the DOM element ref.\n\n  useLayoutEffect(function () {\n    if (ref.current) {\n      EDITOR_TO_ELEMENT.set(editor, ref.current);\n      NODE_TO_ELEMENT.set(editor, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      NODE_TO_ELEMENT.delete(editor);\n    }\n  }); // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n\n  useLayoutEffect(function () {\n    window.document.addEventListener('selectionchange', onDOMSelectionChange);\n    return function () {\n      window.document.removeEventListener('selectionchange', onDOMSelectionChange);\n    };\n  }, []); // Attach a native DOM event handler for `beforeinput` events, because React's\n  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n  // real `beforeinput` events sadly... (2019/11/04)\n  // https://github.com/facebook/react/issues/11211\n\n  useLayoutEffect(function () {\n    if (ref.current) {\n      // @ts-ignore The `beforeinput` event isn't recognized.\n      ref.current.addEventListener('beforeinput', onDOMBeforeInput);\n    }\n\n    return function () {\n      if (ref.current) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);\n      }\n    };\n  }, []); // Whenever the editor updates, make sure the DOM selection state is in sync.\n\n  useLayoutEffect(function () {\n    var selection = editor.selection;\n    var domSelection = window.getSelection();\n\n    if (state.isComposing || !domSelection || !ReactEditor.isFocused(editor)) {\n      return;\n    }\n\n    var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.\n\n    if (!selection && !hasDomSelection) {\n      return;\n    }\n\n    var newDomRange = selection && ReactEditor.toDOMRange(editor, selection); // If the DOM selection is already correct, we're done.\n\n    if (hasDomSelection && newDomRange && isRangeEqual(domSelection.getRangeAt(0), newDomRange)) {\n      return;\n    } // Otherwise the DOM selection is out of sync, so update it.\n\n\n    var el = ReactEditor.toDOMNode(editor, editor);\n    state.isUpdatingSelection = true;\n    domSelection.removeAllRanges();\n\n    if (newDomRange) {\n      domSelection.addRange(newDomRange);\n      var leafEl = newDomRange.startContainer.parentElement;\n      scrollIntoView(leafEl, {\n        scrollMode: 'if-needed'\n      });\n    }\n\n    setTimeout(function () {\n      // COMPAT: In Firefox, it's not enough to create a range, you also need\n      // to focus the contenteditable element too. (2016/11/16)\n      if (newDomRange && IS_FIREFOX) {\n        el.focus();\n      }\n\n      state.isUpdatingSelection = false;\n    });\n  }); // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n\n  var onDOMBeforeInput = useCallback(function (event) {\n    if (!readOnly && hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var selection = editor.selection;\n      var type = event.inputType;\n      var data = event.dataTransfer || event.data || undefined; // These two types occur while a user is composing text and can't be\n      // cancelled. Let them through and wait for the composition to end.\n\n      if (type === 'insertCompositionText' || type === 'deleteCompositionText') {\n        return;\n      }\n\n      event.preventDefault(); // COMPAT: For the deleting forward/backward input types we don't want\n      // to change the selection because it is the range that will be deleted,\n      // and those commands determine that for themselves.\n\n      if (!type.startsWith('delete') || type.startsWith('deleteBy')) {\n        var _event$getTargetRange = event.getTargetRanges(),\n            _event$getTargetRange2 = _slicedToArray2(_event$getTargetRange, 1),\n            targetRange = _event$getTargetRange2[0];\n\n        if (targetRange) {\n          var range = ReactEditor.toSlateRange(editor, targetRange);\n\n          if (!selection || !Range.equals(selection, range)) {\n            Editor.select(editor, range);\n          }\n        }\n      } // COMPAT: If the selection is expanded, even if the command seems like\n      // a delete forward/backward command it should delete the selection.\n\n\n      if (selection && Range.isExpanded(selection) && type.startsWith('delete')) {\n        editor.exec({\n          type: 'delete_fragment'\n        });\n        return;\n      }\n\n      switch (type) {\n        case 'deleteByComposition':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          {\n            editor.exec({\n              type: 'delete_fragment'\n            });\n            break;\n          }\n\n        case 'deleteContent':\n        case 'deleteContentForward':\n          {\n            editor.exec({\n              type: 'delete_forward',\n              unit: 'character'\n            });\n            break;\n          }\n\n        case 'deleteContentBackward':\n          {\n            editor.exec({\n              type: 'delete_backward',\n              unit: 'character'\n            });\n            break;\n          }\n\n        case 'deleteEntireSoftLine':\n          {\n            editor.exec({\n              type: 'delete_backward',\n              unit: 'line'\n            });\n            editor.exec({\n              type: 'delete_forward',\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineBackward':\n          {\n            editor.exec({\n              type: 'delete_backward',\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineBackward':\n          {\n            editor.exec({\n              type: 'delete_backward',\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineForward':\n          {\n            editor.exec({\n              type: 'delete_forward',\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineForward':\n          {\n            editor.exec({\n              type: 'delete_forward',\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteWordBackward':\n          {\n            editor.exec({\n              type: 'delete_backward',\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'deleteWordForward':\n          {\n            editor.exec({\n              type: 'delete_forward',\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'insertLineBreak':\n        case 'insertParagraph':\n          {\n            editor.exec({\n              type: 'insert_break'\n            });\n            break;\n          }\n\n        case 'insertFromComposition':\n        case 'insertFromDrop':\n        case 'insertFromPaste':\n        case 'insertFromYank':\n        case 'insertReplacementText':\n        case 'insertText':\n          {\n            if (data instanceof DataTransfer) {\n              editor.exec({\n                type: 'insert_data',\n                data: data\n              });\n            } else if (typeof data === 'string') {\n              editor.exec({\n                type: 'insert_text',\n                text: data\n              });\n            }\n\n            break;\n          }\n      }\n    }\n  }, []); // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n\n  var onDOMSelectionChange = useCallback(debounce(function () {\n    if (!readOnly && !state.isComposing && !state.isUpdatingSelection) {\n      var activeElement = window.document.activeElement;\n      var el = ReactEditor.toDOMNode(editor, editor);\n      var domSelection = window.getSelection();\n      var domRange = domSelection && domSelection.rangeCount > 0 && domSelection.getRangeAt(0);\n\n      if (activeElement === el) {\n        state.latestElement = activeElement;\n        IS_FOCUSED.set(editor, true);\n      } else {\n        IS_FOCUSED.delete(editor);\n      }\n\n      if (domRange && hasEditableTarget(editor, domRange.startContainer) && hasEditableTarget(editor, domRange.endContainer)) {\n        var range = ReactEditor.toSlateRange(editor, domRange);\n        Editor.select(editor, range);\n      } else {\n        Editor.deselect(editor);\n      }\n    }\n  }, 100), []);\n  var decorations = decorate([editor, []]);\n\n  if (placeholder && editor.children.length === 1 && Array.from(Node$1.texts(editor)).length === 1 && Node$1.text(editor) === '') {\n    var _decorations$push;\n\n    var start = Editor.start(editor, []);\n    decorations.push((_decorations$push = {}, _defineProperty(_decorations$push, PLACEHOLDER_SYMBOL, true), _defineProperty(_decorations$push, \"placeholder\", placeholder), _defineProperty(_decorations$push, \"anchor\", start), _defineProperty(_decorations$push, \"focus\", start), _decorations$push));\n  }\n\n  return React.createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, React.createElement(\"div\", Object.assign({\n    \"data-gramm\": false,\n    role: readOnly ? undefined : 'textbox'\n  }, attributes, {\n    // COMPAT: Firefox doesn't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    spellCheck: IS_FIREFOX ? undefined : attributes.spellCheck,\n    autoCorrect: IS_FIREFOX ? undefined : attributes.autoCorrect,\n    autoCapitalize: IS_FIREFOX ? undefined : attributes.autoCapitalize,\n    \"data-slate-editor\": true,\n    \"data-slate-node\": \"value\",\n    contentEditable: readOnly ? undefined : true,\n    suppressContentEditableWarning: true,\n    ref: ref,\n    style: _objectSpread({\n      // Prevent the default outline styles.\n      outline: 'none',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word'\n    }, style),\n    onBeforeInput: useCallback(function (event) {\n      // COMPAT: Firefox doesn't support the `beforeinput` event, so we\n      // fall back to React's leaky polyfill instead just for it. It\n      // only works for the `insertText` input type.\n      if (IS_FIREFOX && !readOnly) {\n        event.preventDefault();\n        var text = event.data;\n        editor.exec({\n          type: 'insert_text',\n          text: text\n        });\n      }\n    }, []),\n    onBlur: useCallback(function (event) {\n      if (readOnly || state.isUpdatingSelection || !hasEditableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      } // COMPAT: If the current `activeElement` is still the previous\n      // one, this is due to the window being blurred when the tab\n      // itself becomes unfocused, so we want to abort early to allow to\n      // editor to stay focused when the tab becomes focused again.\n\n\n      if (state.latestElement === window.document.activeElement) {\n        return;\n      }\n\n      var relatedTarget = event.relatedTarget;\n      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning\n      // to the editor from an embedded editable element (eg. an <input>\n      // element inside a void node).\n\n      if (relatedTarget === el) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving from\n      // the editor to inside a void node's spacer element.\n\n\n      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving to a\n      // non- editable section of an element that isn't a void node (eg.\n      // a list item of the check list example).\n\n\n      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n\n        if (Element$1.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      }\n\n      IS_FOCUSED.delete(editor);\n    }, [attributes.onBlur]),\n    onClick: useCallback(function (event) {\n      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n\n        var _start = Editor.start(editor, path);\n\n        if (Editor.match(editor, _start, 'void')) {\n          var range = Editor.range(editor, _start);\n          Editor.select(editor, range);\n        }\n      }\n    }, [attributes.onClick]),\n    onCompositionEnd: useCallback(function (event) {\n      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionEnd)) {\n        state.isComposing = false; // COMPAT: In Chrome, `beforeinput` events for compositions\n        // aren't correct and never fire the \"insertFromComposition\"\n        // type that we need. So instead, insert whenever a composition\n        // ends since it will already have been committed to the DOM.\n\n        if (!IS_SAFARI && event.data) {\n          editor.exec({\n            type: 'insert_text',\n            text: event.data\n          });\n        }\n      }\n    }, [attributes.onCompositionEnd]),\n    onCompositionStart: useCallback(function (event) {\n      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionStart)) {\n        state.isComposing = true;\n      }\n    }, [attributes.onCompositionStart]),\n    onCopy: useCallback(function (event) {\n      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {\n        event.preventDefault();\n        setFragmentData(event.clipboardData, editor);\n      }\n    }, [attributes.onCopy]),\n    onCut: useCallback(function (event) {\n      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {\n        event.preventDefault();\n        setFragmentData(event.clipboardData, editor);\n        var selection = editor.selection;\n\n        if (selection && Range.isExpanded(selection)) {\n          editor.exec({\n            type: 'delete_fragment'\n          });\n        }\n      }\n    }, [attributes.onCut]),\n    onDragOver: useCallback(function (event) {\n      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        // Only when the target is void, call `preventDefault` to signal\n        // that drops are allowed. Editable content is droppable by\n        // default, and calling `preventDefault` hides the cursor.\n        var node = ReactEditor.toSlateNode(editor, event.target);\n\n        if (Element$1.isElement(node) && editor.isVoid(node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver]),\n    onDragStart: useCallback(function (event) {\n      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = Editor.match(editor, path, 'void'); // If starting a drag on a void node, make sure it is selected\n        // so that it shows up in the selection's fragment.\n\n        if (voidMatch) {\n          var range = Editor.range(editor, path);\n          Editor.select(editor, range);\n        }\n\n        setFragmentData(event.dataTransfer, editor);\n      }\n    }, [attributes.onDragStart]),\n    onDrop: useCallback(function (event) {\n      if (hasTarget(editor, event.target) && !readOnly && !isEventHandled(event, attributes.onDrop)) {\n        // COMPAT: Firefox doesn't fire `beforeinput` events at all, and\n        // Chromium browsers don't properly fire them for files being\n        // dropped into a `contenteditable`. (2019/11/26)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1028668\n        if (IS_FIREFOX || !IS_SAFARI && event.dataTransfer.files.length > 0) {\n          event.preventDefault();\n          var range = ReactEditor.findEventRange(editor, event);\n          var data = event.dataTransfer;\n          Editor.select(editor, range);\n          editor.exec({\n            type: 'insert_data',\n            data: data\n          });\n        }\n      }\n    }, [attributes.onDrop]),\n    onFocus: useCallback(function (event) {\n      if (!readOnly && !state.isUpdatingSelection && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        state.latestElement = window.document.activeElement; // COMPAT: If the editor has nested editable elements, the focus\n        // can go to them. In Firefox, this must be prevented because it\n        // results in issues with keyboard navigation. (2017/03/30)\n\n        if (IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n\n        IS_FOCUSED.set(editor, true);\n      }\n    }, [attributes.onFocus]),\n    onKeyDown: useCallback(function (event) {\n      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onKeyDown)) {\n        var nativeEvent = event.nativeEvent;\n        var selection = editor.selection; // COMPAT: Since we prevent the default behavior on\n        // `beforeinput` events, the browser doesn't think there's ever\n        // any history stack to undo or redo, so we have to manage these\n        // hotkeys ourselves. (2019/11/06)\n\n        if (Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n          editor.exec({\n            type: 'redo'\n          });\n          return;\n        }\n\n        if (Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n          editor.exec({\n            type: 'undo'\n          });\n          return;\n        } // COMPAT: Certain browsers don't handle the selection updates\n        // properly. In Chrome, the selection isn't properly extended.\n        // And in Firefox, the selection isn't properly collapsed.\n        // (2017/10/17)\n\n\n        if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Editor.move(editor, {\n            unit: 'line',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          Editor.move(editor, {\n            unit: 'line'\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Editor.move(editor, {\n            unit: 'line',\n            edge: 'focus',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          Editor.move(editor, {\n            unit: 'line',\n            edge: 'focus'\n          });\n          return;\n        } // COMPAT: If a void node is selected, or a zero-width text node\n        // adjacent to an inline is selected, we need to handle these\n        // hotkeys manually because browsers won't be able to skip over\n        // the void node with the zero-width space not being an empty\n        // string.\n\n\n        if (Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isCollapsed(selection)) {\n            Editor.move(editor, {\n              reverse: true\n            });\n          } else {\n            Editor.collapse(editor, {\n              edge: 'start'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isCollapsed(selection)) {\n            Editor.move(editor);\n          } else {\n            Editor.collapse(editor, {\n              edge: 'end'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n          Editor.move(editor, {\n            unit: 'word',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n          Editor.move(editor, {\n            unit: 'word'\n          });\n          return;\n        } // COMPAT: Firefox doesn't support the `beforeinput` event, so we\n        // fall back to guessing at the input intention for hotkeys.\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n\n\n        if (IS_FIREFOX) {\n          // We don't have a core behavior for these, but they change the\n          // DOM if we don't prevent them, so we have to.\n          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n\n          if (Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            editor.exec({\n              type: 'insert_break'\n            });\n            return;\n          }\n\n          if (Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              editor.exec({\n                type: 'delete_fragment'\n              });\n            } else {\n              editor.exec({\n                type: 'delete_backward',\n                unit: 'character'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              editor.exec({\n                type: 'delete_fragment'\n              });\n            } else {\n              editor.exec({\n                type: 'delete_forward',\n                unit: 'character'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              editor.exec({\n                type: 'delete_fragment'\n              });\n            } else {\n              editor.exec({\n                type: 'delete_backward',\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              editor.exec({\n                type: 'delete_fragment'\n              });\n            } else {\n              editor.exec({\n                type: 'delete_forward',\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              editor.exec({\n                type: 'delete_fragment'\n              });\n            } else {\n              editor.exec({\n                type: 'delete_backward',\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              editor.exec({\n                type: 'delete_fragment'\n              });\n            } else {\n              editor.exec({\n                type: 'delete_forward',\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n        }\n      }\n    }, [attributes.onKeyDown]),\n    onPaste: useCallback(function (event) {\n      // COMPAT: Firefox doesn't support the `beforeinput` event, so we\n      // fall back to React's `onPaste` here instead.\n      if (IS_FIREFOX && !readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        event.preventDefault();\n        editor.exec({\n          type: 'insert_data',\n          data: event.clipboardData\n        });\n      }\n    }, [attributes.onPaste])\n  }), React.createElement(Children, {\n    decorate: decorate,\n    decorations: decorations,\n    node: editor,\n    renderDecoration: renderDecoration,\n    renderElement: renderElement,\n    renderMark: renderMark,\n    selection: editor.selection\n  })));\n};\n/**\r\n * A default memoized decorate function.\r\n */\n\n\nvar defaultDecorate = function defaultDecorate() {\n  return [];\n};\n/**\r\n * Check if two DOM range objects are equal.\r\n */\n\n\nvar isRangeEqual = function isRangeEqual(a, b) {\n  return a.startContainer === b.startContainer && a.startOffset === b.startOffset && a.endContainer === b.endContainer && a.endOffset === b.endOffset || a.startContainer === b.endContainer && a.startOffset === b.endOffset && a.endContainer === b.startContainer && a.endOffset === b.startOffset;\n};\n/**\r\n * Check if the target is in the editor.\r\n */\n\n\nvar hasTarget = function hasTarget(editor, target) {\n  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);\n};\n/**\r\n * Check if the target is editable and in the editor.\r\n */\n\n\nvar hasEditableTarget = function hasEditableTarget(editor, target) {\n  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n    editable: true\n  });\n};\n/**\r\n * Check if an event is overrided by a handler.\r\n */\n\n\nvar isEventHandled = function isEventHandled(event, handler) {\n  if (!handler) {\n    return false;\n  }\n\n  handler(event);\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\r\n * Check if a DOM event is overrided by a handler.\r\n */\n\n\nvar isDOMEventHandled = function isDOMEventHandled(event, handler) {\n  if (!handler) {\n    return false;\n  }\n\n  handler(event);\n  return event.defaultPrevented;\n};\n/**\r\n * Set the currently selected fragment to the clipboard.\r\n */\n\n\nvar setFragmentData = function setFragmentData(dataTransfer, editor) {\n  var selection = editor.selection;\n\n  if (!selection) {\n    return;\n  }\n\n  var _Range$edges3 = Range.edges(selection),\n      _Range$edges4 = _slicedToArray2(_Range$edges3, 2),\n      start = _Range$edges4[0],\n      end = _Range$edges4[1];\n\n  var startVoid = Editor.match(editor, start.path, 'void');\n  var endVoid = Editor.match(editor, end.path, 'void');\n\n  if (Range.isCollapsed(selection) && !startVoid) {\n    return;\n  } // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n\n\n  var domRange = ReactEditor.toDOMRange(editor, selection);\n  var contents = domRange.cloneContents();\n  var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.\n\n  contents.childNodes.forEach(function (node) {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node;\n    }\n  }); // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n\n  if (endVoid) {\n    var _endVoid = _slicedToArray2(endVoid, 1),\n        voidNode = _endVoid[0];\n\n    var r = domRange.cloneRange();\n    var domNode = ReactEditor.toDOMNode(editor, voidNode);\n    r.setEndAfter(domNode);\n    contents = r.cloneContents();\n  } // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n\n\n  if (startVoid) {\n    attach = contents.querySelector('[data-slate-spacer]');\n  } // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n\n\n  Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(function (zw) {\n    var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n    zw.textContent = isNewline ? '\\n' : '';\n  }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n  if (isDOMText(attach)) {\n    var span = document.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n\n    span.style.whiteSpace = 'pre';\n    span.appendChild(attach);\n    contents.appendChild(span);\n    attach = span;\n  }\n\n  var fragment = Node$1.fragment(editor, selection);\n  var string = JSON.stringify(fragment);\n  var encoded = window.btoa(encodeURIComponent(string));\n  attach.setAttribute('data-slate-fragment', encoded);\n  dataTransfer.setData('application/x-slate-fragment', encoded); // Add the content to a <div> so that we can get its inner HTML.\n\n  var div = document.createElement('div');\n  div.appendChild(contents);\n  dataTransfer.setData('text/html', div.innerHTML);\n  dataTransfer.setData('text/plain', getPlainText(div));\n};\n/**\r\n * Get a plaintext representation of the content of a node, accounting for block\r\n * elements which get a newline appended.\r\n */\n\n\nvar getPlainText = function getPlainText(domNode) {\n  var text = '';\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n\n  if (isDOMElement(domNode)) {\n    for (var _i2 = 0, _Array$from = Array.from(domNode.childNodes); _i2 < _Array$from.length; _i2++) {\n      var childNode = _Array$from[_i2];\n      text += getPlainText(childNode);\n    }\n\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n\n  return text;\n};\n\nvar ReactCommand = {\n  /**\r\n   * Check if a value is an `InsertDataCommand` object.\r\n   */\n  isInsertDataCommand: function isInsertDataCommand(value) {\n    return Command.isCommand(value) && value.type === 'insert_data' && value.data instanceof DataTransfer;\n  },\n\n  /**\r\n   * Check if a value is a `ReactCommand` object.\r\n   */\n  isReactCommand: function isReactCommand(value) {\n    return ReactCommand.isInsertDataCommand(value);\n  }\n};\n/**\r\n * `withReact` adds React and DOM specific behaviors to the editor.\r\n */\n\nvar withReact = function withReact(editor) {\n  var apply = editor.apply,\n      exec = editor.exec,\n      onChange = editor.onChange;\n\n  editor.apply = function (op) {\n    var matches = [];\n\n    switch (op.type) {\n      case 'add_mark':\n      case 'insert_text':\n      case 'remove_mark':\n      case 'remove_text':\n      case 'set_mark':\n      case 'set_node':\n        {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = Editor.levels(editor, {\n              at: op.path\n            })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var _step$value = slicedToArray(_step.value, 2),\n                  node = _step$value[0],\n                  path = _step$value[1];\n\n              var key = ReactEditor.findKey(editor, node);\n              matches.push([path, key]);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n        {\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = Editor.levels(editor, {\n              at: Path.parent(op.path)\n            })[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var _step2$value = slicedToArray(_step2.value, 2),\n                  _node = _step2$value[0],\n                  _path = _step2$value[1];\n\n              var _key = ReactEditor.findKey(editor, _node);\n\n              matches.push([_path, _key]);\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                _iterator2[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          break;\n        }\n    }\n\n    apply(op);\n\n    for (var _i = 0, _matches = matches; _i < _matches.length; _i++) {\n      var _matches$_i = slicedToArray(_matches[_i], 2),\n          _path2 = _matches$_i[0],\n          _key2 = _matches$_i[1];\n\n      var _Editor$node = Editor.node(editor, _path2),\n          _Editor$node2 = slicedToArray(_Editor$node, 1),\n          _node2 = _Editor$node2[0];\n\n      NODE_TO_KEY.set(_node2, _key2);\n    }\n  };\n\n  editor.exec = function (command) {\n    if (ReactCommand.isInsertDataCommand(command)) {\n      var data = command.data;\n      var fragment = data.getData('application/x-slate-fragment');\n\n      if (fragment) {\n        var decoded = decodeURIComponent(window.atob(fragment));\n        var parsed = JSON.parse(decoded);\n        Editor.insertFragment(editor, parsed);\n        return;\n      }\n\n      var text = data.getData('text/plain');\n\n      if (text) {\n        var lines = text.split('\\n');\n        var split = false;\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = lines[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var line = _step3.value;\n\n            if (split) {\n              Editor.splitNodes(editor);\n            }\n\n            Editor.insertText(editor, line);\n            split = true;\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    } else {\n      exec(command);\n    }\n  };\n\n  editor.onChange = function (children, operations) {\n    var contextOnChange = EDITOR_TO_CONTEXT_LISTENER.get(editor);\n\n    if (contextOnChange) {\n      contextOnChange(children, operations);\n    }\n\n    onChange(children, operations);\n  };\n\n  return editor;\n};\n\nexport { DefaultDecoration, DefaultElement, DefaultMark, EDITOR_TO_CONTEXT_LISTENER, Editable, EditorContext, FocusedContext, ReactCommand, ReactEditor, ReadOnlyContext, SelectedContext, Slate, SlateContext, useEditor, useFocused, useReadOnly, useSelected, useSlate, withReact };","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\nimport isObject from 'isobject';\n\nfunction isObjectObject(o) {\n  return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport default function isPlainObject(o) {\n  var ctor, prot;\n  if (isObjectObject(o) === false) return false; // If has modified constructor\n\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false; // If has modified prototype\n\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false; // If constructor does not have an Object-specific method\n\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n;","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\nexport default function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n}\n;","import isPlainObject from 'is-plain-object';\nimport { Operation, Command, Editor, Path } from 'slate';\nvar History = {\n  /**\r\n   * Check if a value is a `History` object.\r\n   */\n  isHistory: function isHistory(value) {\n    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0]));\n  }\n};\nvar HistoryCommand = {\n  /**\r\n   * Check if a value is a `HistoryCommand` object.\r\n   */\n  isHistoryCommand: function isHistoryCommand(value) {\n    return HistoryCommand.isRedoCommand(value) || HistoryCommand.isUndoCommand(value);\n  },\n\n  /**\r\n   * Check if a value is a `RedoCommand` object.\r\n   */\n  isRedoCommand: function isRedoCommand(value) {\n    return Command.isCommand(value) && value.type === 'redo';\n  },\n\n  /**\r\n   * Check if a value is an `UndoCommand` object.\r\n   */\n  isUndoCommand: function isUndoCommand(value) {\n    return Command.isCommand(value) && value.type === 'undo';\n  }\n};\n/**\r\n * Weakmaps for attaching state to the editor.\r\n */\n\nvar HISTORY = new WeakMap();\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap();\nvar HistoryEditor = {\n  /**\r\n   * Check if a value is a `HistoryEditor` object.\r\n   */\n  isHistoryEditor: function isHistoryEditor(value) {\n    return Editor.isEditor(value) && History.isHistory(value.history);\n  },\n\n  /**\r\n   * Get the merge flag's current value.\r\n   */\n  isMerging: function isMerging(editor) {\n    return MERGING.get(editor);\n  },\n\n  /**\r\n   * Get the saving flag's current value.\r\n   */\n  isSaving: function isSaving(editor) {\n    return SAVING.get(editor);\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\r\n   * the new operations into previous save point in the history.\r\n   */\n  withoutMerging: function withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\r\n   * their operations into the history.\r\n   */\n  withoutSaving: function withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  }\n};\n/**\r\n * The `withHistory` plugin keeps track of the operation history of a Slate\r\n * editor as operations are applied to it, using undo and redo stacks.\r\n */\n\nvar withHistory = function withHistory(editor) {\n  var apply = editor.apply,\n      exec = editor.exec;\n  editor.history = {\n    undos: [],\n    redos: []\n  };\n\n  editor.exec = function (command) {\n    if (HistoryEditor.isHistoryEditor(editor)) {\n      var history = editor.history;\n      var undos = history.undos,\n          redos = history.redos;\n\n      if (redos.length > 0 && HistoryCommand.isRedoCommand(command)) {\n        var batch = redos[redos.length - 1];\n        HistoryEditor.withoutSaving(editor, function () {\n          Editor.withoutNormalizing(editor, function () {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = batch[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var op = _step.value;\n                editor.apply(op);\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                  _iterator[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          });\n        });\n        history.redos.pop();\n        history.undos.push(batch);\n        return;\n      }\n\n      if (undos.length > 0 && HistoryCommand.isUndoCommand(command)) {\n        var _batch = undos[undos.length - 1];\n        HistoryEditor.withoutSaving(editor, function () {\n          Editor.withoutNormalizing(editor, function () {\n            var inverseOps = _batch.map(Operation.inverse).reverse();\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = inverseOps[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var op = _step2.value; // If the final operation is deselecting the editor, skip it. This is\n\n                if (op === inverseOps[inverseOps.length - 1] && op.type === 'set_selection' && op.newProperties == null) {\n                  continue;\n                } else {\n                  editor.apply(op);\n                }\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                  _iterator2[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          });\n        });\n        history.redos.push(_batch);\n        history.undos.pop();\n        return;\n      }\n    }\n\n    exec(command);\n  };\n\n  editor.apply = function (op) {\n    if (HistoryEditor.isHistoryEditor(editor)) {\n      var operations = editor.operations,\n          history = editor.history;\n      var undos = history.undos;\n      var lastBatch = undos[undos.length - 1];\n      var lastOp = lastBatch && lastBatch[lastBatch.length - 1];\n      var overwrite = shouldOverwrite(op, lastOp);\n      var save = HistoryEditor.isSaving(editor);\n      var merge = HistoryEditor.isMerging(editor);\n\n      if (save == null) {\n        save = shouldSave(op);\n      }\n\n      if (save) {\n        if (merge == null) {\n          if (lastBatch == null) {\n            merge = false;\n          } else if (operations.length !== 0) {\n            merge = true;\n          } else {\n            merge = shouldMerge(op, lastOp) || overwrite;\n          }\n        }\n\n        if (lastBatch && merge) {\n          if (overwrite) {\n            lastBatch.pop();\n          }\n\n          lastBatch.push(op);\n        } else {\n          var batch = [op];\n          undos.push(batch);\n        }\n\n        while (undos.length > 100) {\n          undos.shift();\n        }\n\n        if (shouldClear(op)) {\n          history.redos = [];\n        }\n      }\n    }\n\n    apply(op);\n  };\n\n  return editor;\n};\n/**\r\n * Check whether to merge an operation into the previous operation.\r\n */\n\n\nvar shouldMerge = function shouldMerge(op, prev) {\n  if (op.type === 'set_selection') {\n    return true;\n  }\n\n  if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check whether an operation needs to be saved to the history.\r\n */\n\n\nvar shouldSave = function shouldSave(op, prev) {\n  if (op.type === 'set_selection' && op.newProperties == null) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Check whether an operation should overwrite the previous one.\r\n */\n\n\nvar shouldOverwrite = function shouldOverwrite(op, prev) {\n  if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check whether an operation should clear the redos stack.\r\n */\n\n\nvar shouldClear = function shouldClear(op) {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n\n  return true;\n};\n\nexport { HISTORY, History, HistoryCommand, HistoryEditor, MERGING, SAVING, withHistory };","/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  }\n\n  ;\n\n  var debounced = function debounced() {\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function () {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  debounced.flush = function () {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n}\n\n; // Adds compatibility for ES modules\n\ndebounce.debounce = debounce;\nmodule.exports = debounce;","'use strict';\n\nmodule.exports = direction;\nvar RTL = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\nvar LTR = \"A-Za-z\\xC0-\\xD6\\xD8-\\xF6\" + \"\\xF8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C\" + \"\\uFE00-\\uFE6F\\uFEFD-\\uFFFF\";\nvar rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\nvar ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\n\nfunction direction(value) {\n  value = String(value || '');\n\n  if (rtl.test(value)) {\n    return 'rtl';\n  }\n\n  if (ltr.test(value)) {\n    return 'ltr';\n  }\n\n  return 'neutral';\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Constants.\n */\n\nvar IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\nvar MODIFIERS = {\n  alt: 'altKey',\n  control: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey'\n};\nvar ALIASES = {\n  add: '+',\n  break: 'pause',\n  cmd: 'meta',\n  command: 'meta',\n  ctl: 'control',\n  ctrl: 'control',\n  del: 'delete',\n  down: 'arrowdown',\n  esc: 'escape',\n  ins: 'insert',\n  left: 'arrowleft',\n  mod: IS_MAC ? 'meta' : 'control',\n  opt: 'alt',\n  option: 'alt',\n  return: 'enter',\n  right: 'arrowright',\n  space: ' ',\n  spacebar: ' ',\n  up: 'arrowup',\n  win: 'meta',\n  windows: 'meta'\n};\nvar CODES = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  ' ': 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  '\\'': 222\n};\n\nfor (var f = 1; f < 20; f++) {\n  CODES['f' + f] = 111 + f;\n}\n/**\n * Is hotkey?\n */\n\n\nfunction isHotkey(hotkey, options, event) {\n  if (options && !('byKey' in options)) {\n    event = options;\n    options = null;\n  }\n\n  if (!Array.isArray(hotkey)) {\n    hotkey = [hotkey];\n  }\n\n  var array = hotkey.map(function (string) {\n    return parseHotkey(string, options);\n  });\n\n  var check = function check(e) {\n    return array.some(function (object) {\n      return compareHotkey(object, e);\n    });\n  };\n\n  var ret = event == null ? check : check(event);\n  return ret;\n}\n\nfunction isCodeHotkey(hotkey, event) {\n  return isHotkey(hotkey, event);\n}\n\nfunction isKeyHotkey(hotkey, event) {\n  return isHotkey(hotkey, {\n    byKey: true\n  }, event);\n}\n/**\n * Parse.\n */\n\n\nfunction parseHotkey(hotkey, options) {\n  var byKey = options && options.byKey;\n  var ret = {}; // Special case to handle the `+` key since we use it as a separator.\n\n  hotkey = hotkey.replace('++', '+add');\n  var values = hotkey.split('+');\n  var length = values.length; // Ensure that all the modifiers are set to false unless the hotkey has them.\n\n  for (var k in MODIFIERS) {\n    ret[MODIFIERS[k]] = false;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n      var optional = value.endsWith('?') && value.length > 1;\n\n      if (optional) {\n        value = value.slice(0, -1);\n      }\n\n      var name = toKeyName(value);\n      var modifier = MODIFIERS[name];\n\n      if (length === 1 || !modifier) {\n        if (byKey) {\n          ret.key = name;\n        } else {\n          ret.which = toKeyCode(value);\n        }\n      }\n\n      if (modifier) {\n        ret[modifier] = optional ? null : true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ret;\n}\n/**\n * Compare.\n */\n\n\nfunction compareHotkey(object, event) {\n  for (var key in object) {\n    var expected = object[key];\n    var actual = void 0;\n\n    if (expected == null) {\n      continue;\n    }\n\n    if (key === 'key' && event.key != null) {\n      actual = event.key.toLowerCase();\n    } else if (key === 'which') {\n      actual = expected === 91 && event.which === 93 ? 91 : event.which;\n    } else {\n      actual = event[key];\n    }\n\n    if (actual == null && expected === false) {\n      continue;\n    }\n\n    if (actual !== expected) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Utils.\n */\n\n\nfunction toKeyCode(name) {\n  name = toKeyName(name);\n  var code = CODES[name] || name.toUpperCase().charCodeAt(0);\n  return code;\n}\n\nfunction toKeyName(name) {\n  name = name.toLowerCase();\n  name = ALIASES[name] || name;\n  return name;\n}\n/**\n * Export.\n */\n\n\nexports.default = isHotkey;\nexports.isHotkey = isHotkey;\nexports.isCodeHotkey = isCodeHotkey;\nexports.isKeyHotkey = isKeyHotkey;\nexports.parseHotkey = parseHotkey;\nexports.compareHotkey = compareHotkey;\nexports.toKeyCode = toKeyCode;\nexports.toKeyName = toKeyName;","var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : (obj = {}, obj[\"immer-nothing\"] = true, obj);\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n\nfunction isDraftable(value) {\n  if (!value) {\n    return false;\n  }\n\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\n\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n\n  if (Array.isArray(value)) {\n    return true;\n  }\n\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\n\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n} // We use Maps as `drafts` for Sets, not Objects\n// See proxy.js\n\n\nfunction assignSet(target, override) {\n  override.forEach(function (value) {\n    // When we add new drafts we have to remove their originals if present\n    var prev = original(value);\n\n    if (prev) {\n      target.delete(prev);\n    }\n\n    target.add(value);\n  });\n  return target;\n} // We use Maps as `drafts` for Maps, not Objects\n// See proxy.js\n\n\nfunction assignMap(target, override) {\n  override.forEach(function (value, key) {\n    return target.set(key, value);\n  });\n  return target;\n}\n\nvar assign = Object.assign || function (target) {\n  var overrides = [],\n      len = arguments.length - 1;\n\n  while (len-- > 0) {\n    overrides[len] = arguments[len + 1];\n  }\n\n  overrides.forEach(function (override) {\n    return Object.keys(override).forEach(function (key) {\n      return target[key] = override[key];\n    });\n  });\n  return target;\n};\n\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : Object.getOwnPropertyNames;\n\nfunction shallowCopy(base, invokeGetters) {\n  if (invokeGetters === void 0) invokeGetters = false;\n\n  if (Array.isArray(base)) {\n    return base.slice();\n  }\n\n  if (isMap(base)) {\n    return new Map(base);\n  }\n\n  if (isSet(base)) {\n    return new Set(base);\n  }\n\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\n\nfunction each(obj, iter) {\n  if (Array.isArray(obj) || isMap(obj) || isSet(obj)) {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  } else {\n    ownKeys(obj).forEach(function (key) {\n      return iter(key, obj[key], obj);\n    });\n  }\n}\n\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\n\nfunction has(thing, prop) {\n  return isMap(thing) ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n\nfunction get(thing, prop) {\n  return isMap(thing) ? thing.get(prop) : thing[prop];\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\n\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\n\nvar hasSet = typeof Set !== \"undefined\";\n\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\n\nfunction makeIterable(next) {\n  var obj;\n  var self;\n  return self = (obj = {}, obj[Symbol.iterator] = function () {\n    return self;\n  }, obj.next = next, obj);\n}\n/** Map.prototype.values _-or-_ Map.prototype.entries */\n\n\nfunction iterateMapValues(state, prop, receiver) {\n  var isEntries = prop !== \"values\";\n  return function () {\n    var iterator = latest(state)[Symbol.iterator]();\n    return makeIterable(function () {\n      var result = iterator.next();\n\n      if (!result.done) {\n        var ref = result.value;\n        var key = ref[0];\n        var value = receiver.get(key);\n        result.value = isEntries ? [key, value] : value;\n      }\n\n      return result;\n    });\n  };\n}\n\nfunction makeIterateSetValues(createProxy) {\n  function iterateSetValues(state, prop) {\n    var isEntries = prop === \"entries\";\n    return function () {\n      var iterator = latest(state)[Symbol.iterator]();\n      return makeIterable(function () {\n        var result = iterator.next();\n\n        if (!result.done) {\n          var value = wrapSetValue(state, result.value);\n          result.value = isEntries ? [value, value] : value;\n        }\n\n        return result;\n      });\n    };\n  }\n\n  function wrapSetValue(state, value) {\n    var key = original(value) || value;\n    var draft = state.drafts.get(key);\n\n    if (!draft) {\n      if (state.finalized || !isDraftable(value) || state.finalizing) {\n        return value;\n      }\n\n      draft = createProxy(value, state);\n      state.drafts.set(key, draft);\n\n      if (state.modified) {\n        state.copy.add(draft);\n      }\n    }\n\n    return draft;\n  }\n\n  return iterateSetValues;\n}\n\nfunction latest(state) {\n  return state.copy || state.base;\n}\n\nfunction clone(obj) {\n  if (!isDraftable(obj)) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n\n  if (isMap(obj)) {\n    return new Map(obj);\n  }\n\n  if (isSet(obj)) {\n    return new Set(obj);\n  }\n\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) {\n    cloned[key] = clone(obj[key]);\n  }\n\n  return cloned;\n}\n\nfunction freeze(obj, deep) {\n  if (deep === void 0) deep = false;\n\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) {\n    return;\n  }\n\n  if (isSet(obj)) {\n    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  } else if (isMap(obj)) {\n    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n\n  if (deep) {\n    each(obj, function (_, value) {\n      return freeze(value, true);\n    });\n  }\n}\n\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n/** Each scope represents a `produce` call. */\n\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches(patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1() {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave() {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\n\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\n\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n\n  if (isMap(base)) {\n    proxyMap(draft);\n  } else if (isSet(base)) {\n    proxySet(draft);\n  } else {\n    each(draft, function (prop) {\n      proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n    });\n  } // See \"proxy.js\" for property documentation.\n\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: isMap(base) ? new Map() : {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    drafts: isSet(base) ? new Map() : null,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction latest$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(latest$1(state), prop);\n\n  if (state.finalizing) {\n    return value;\n  } // Create a draft if the value is unmodified.\n\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(latest$1(state), prop))) {\n      return;\n    }\n\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n\n    if (state.parent) {\n      markChanged(state.parent);\n    }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) {\n    state.copy = clonePotentialDraft(state.base);\n  }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\n\nvar descriptors = {};\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n      get: function get$1$1() {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction proxyMap(target) {\n  Object.defineProperties(target, mapTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateMapValues));\n  }\n}\n\nvar mapTraps = finalizeTraps({\n  size: function size(state) {\n    return latest$1(state).size;\n  },\n  has: function has(state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  set: function set(state) {\n    return function (key, value) {\n      if (latest$1(state).get(key) !== value) {\n        prepareCopy(state);\n        markChanged(state);\n        state.assigned.set(key, true);\n        state.copy.set(key, value);\n      }\n\n      return state.draft;\n    };\n  },\n  delete: function _delete(state) {\n    return function (key) {\n      prepareCopy(state);\n      markChanged(state);\n      state.assigned.set(key, false);\n      state.copy.delete(key);\n      return false;\n    };\n  },\n  clear: function clear(state) {\n    return function () {\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      markChanged(state);\n      state.assigned = new Map();\n\n      for (var i = 0, list = latest$1(state).keys(); i < list.length; i += 1) {\n        var key = list[i];\n        state.assigned.set(key, false);\n      }\n\n      return state.copy.clear();\n    };\n  },\n  forEach: function forEach(state, key, reciever) {\n    return function (cb) {\n      latest$1(state).forEach(function (value, key, map) {\n        cb(reciever.get(key), key, map);\n      });\n    };\n  },\n  get: function get(state) {\n    return function (key) {\n      var value = latest$1(state).get(key);\n\n      if (state.finalizing || state.finalized || !isDraftable(value)) {\n        return value;\n      }\n\n      if (value !== state.base.get(key)) {\n        return value;\n      }\n\n      var draft = createProxy(value, state);\n      prepareCopy(state);\n      state.copy.set(key, draft);\n      return draft;\n    };\n  },\n  keys: function keys(state) {\n    return function () {\n      return latest$1(state).keys();\n    };\n  },\n  values: iterateMapValues,\n  entries: iterateMapValues\n});\n\nfunction proxySet(target) {\n  Object.defineProperties(target, setTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateSetValues));\n  }\n}\n\nvar iterateSetValues = makeIterateSetValues(createProxy);\nvar setTraps = finalizeTraps({\n  size: function size(state) {\n    return latest$1(state).size;\n  },\n  add: function add(state) {\n    return function (value) {\n      if (!latest$1(state).has(value)) {\n        markChanged(state);\n\n        if (!state.copy) {\n          prepareCopy(state);\n        }\n\n        state.copy.add(value);\n      }\n\n      return state.draft;\n    };\n  },\n  delete: function _delete(state) {\n    return function (value) {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      return state.copy.delete(value);\n    };\n  },\n  has: function has(state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  clear: function clear(state) {\n    return function () {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      return state.copy.clear();\n    };\n  },\n  keys: iterateSetValues,\n  entries: iterateSetValues,\n  values: iterateSetValues,\n  forEach: function forEach(state) {\n    return function (cb, thisArg) {\n      var iterator = iterateSetValues(state)();\n      var result = iterator.next();\n\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, state.draft);\n        result = iterator.next();\n      }\n    };\n  }\n});\n\nfunction finalizeTraps(traps) {\n  return Object.keys(traps).reduce(function (acc, key) {\n    var builder = key === \"size\" ? proxyAttr : proxyMethod;\n    acc[key] = builder(traps[key], key);\n    return acc;\n  }, {});\n}\n\nfunction proxyAttr(fn) {\n  return {\n    get: function get() {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      return fn(state);\n    }\n  };\n}\n\nfunction proxyMethod(trap, key) {\n  return {\n    get: function get() {\n      return function () {\n        var args = [],\n            len = arguments.length;\n\n        while (len--) {\n          args[len] = arguments[len];\n        }\n\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        return trap(state, key, state.draft).apply(void 0, args);\n      };\n    }\n  };\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) {\n    throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest$1(state)));\n  }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) {\n          markChanged(state);\n        }\n      } else if (isMap(state.base)) {\n        if (hasMapChanges(state)) {\n          markChanged(state);\n        }\n      } else if (isSet(state.base)) {\n        if (hasSetChanges(state)) {\n          markChanged(state);\n        }\n      } else if (hasObjectChanges(state)) {\n        markChanged(state);\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") {\n    return;\n  }\n\n  var state = object[DRAFT_STATE];\n\n  if (!state) {\n    return;\n  }\n\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) {\n        assigned[i] = false;\n      }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) {\n        assigned[i$1] = true;\n      }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) {\n        markChangesRecursively(draft[i$2]);\n      }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state$1 = value && value[DRAFT_STATE];\n\n        if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n\n  if (draft.length !== state.base.length) {\n    return true;\n  } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) {\n    return true;\n  } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n\n  return false;\n}\n\nfunction hasMapChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n\n  if (base.size !== draft.size) {\n    return true;\n  } // IE11 supports only forEach iteration\n\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : value !== base.get(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction hasSetChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n\n  if (base.size !== draft.size) {\n    return true;\n  } // IE11 supports only forEach iteration\n\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : !base.has(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy =\n/*#__PURE__*/\nObject.freeze({\n  willFinalize: willFinalize,\n  createProxy: createProxy\n});\nvar obj$1, obj$1$1;\n\nfunction willFinalize$1() {}\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\n\n\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var target = state;\n  var traps = objectTraps;\n\n  if (Array.isArray(base)) {\n    target = [state];\n    traps = arrayTraps;\n  } // Map drafts must support object keys, so we use Map objects to track changes.\n  else if (isMap(base)) {\n      traps = mapTraps$1;\n      state.drafts = new Map();\n      state.assigned = new Map();\n    } // Set drafts use a Map object to track which of its values are drafted.\n    // And we don't need the \"assigned\" property, because Set objects have no keys.\n    else if (isSet(base)) {\n        traps = setTraps$1;\n        state.drafts = new Map();\n      }\n\n  var ref = Proxy.revocable(target, traps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\n/**\n * Object drafts\n */\n\n\nvar objectTraps = {\n  get: function get(state, prop) {\n    if (prop === DRAFT_STATE) {\n      return state;\n    }\n\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n\n    var value = latest$2(state)[prop];\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek$1(state.base, prop)) {\n        return value;\n      } // Store drafts on the copy (when one exists).\n\n\n      drafts = state.copy;\n    }\n\n    return drafts[prop] = createProxy$1(value, state);\n  },\n  has: function has(state, prop) {\n    return prop in latest$2(state);\n  },\n  ownKeys: function ownKeys(state) {\n    return Reflect.ownKeys(latest$2(state));\n  },\n  set: function set(state, prop, value) {\n    if (!state.modified) {\n      var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n\n      if (isUnchanged) {\n        return true;\n      }\n\n      markChanged$1(state);\n    }\n\n    state.assigned[prop] = true;\n    state.copy[prop] = value;\n    return true;\n  },\n  deleteProperty: function deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      markChanged$1(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    }\n\n    if (state.copy) {\n      delete state.copy[prop];\n    }\n\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n    var owner = latest$2(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n    }\n\n    return desc;\n  },\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n  getPrototypeOf: function getPrototypeOf(state) {\n    return Object.getPrototypeOf(state.base);\n  },\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n};\n/**\n * Array drafts\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // Used by Map and Set drafts\n\n\nvar reflectTraps = makeReflectTraps([\"ownKeys\", \"has\", \"set\", \"deleteProperty\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"preventExtensions\", \"isExtensible\", \"getPrototypeOf\"]);\n/**\n * Map drafts\n */\n\nvar mapTraps$1 = makeTrapsForGetters((obj$1 = {}, obj$1[DRAFT_STATE] = function (state) {\n  return state;\n}, obj$1.size = function (state) {\n  return latest$2(state).size;\n}, obj$1.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, obj$1.set = function (state) {\n  return function (key, value) {\n    var values = latest$2(state);\n\n    if (!values.has(key) || values.get(key) !== value) {\n      markChanged$1(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n\n    return state.draft;\n  };\n}, obj$1.delete = function (state) {\n  return function (key) {\n    if (latest$2(state).has(key)) {\n      markChanged$1(state);\n      state.assigned.set(key, false);\n      return state.copy.delete(key);\n    }\n\n    return false;\n  };\n}, obj$1.clear = function (state) {\n  return function () {\n    markChanged$1(state);\n    state.assigned = new Map();\n\n    for (var i = 0, list = latest$2(state).keys(); i < list.length; i += 1) {\n      var key = list[i];\n      state.assigned.set(key, false);\n    }\n\n    return state.copy.clear();\n  };\n}, obj$1.forEach = function (state, _, receiver) {\n  return function (cb, thisArg) {\n    return latest$2(state).forEach(function (_, key, map) {\n      var value = receiver.get(key);\n      cb.call(thisArg, value, key, map);\n    });\n  };\n}, obj$1.get = function (state) {\n  return function (key) {\n    var drafts = state[state.modified ? \"copy\" : \"drafts\"];\n\n    if (drafts.has(key)) {\n      return drafts.get(key);\n    }\n\n    var value = latest$2(state).get(key);\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    var draft = createProxy$1(value, state);\n    drafts.set(key, draft);\n    return draft;\n  };\n}, obj$1.keys = function (state) {\n  return function () {\n    return latest$2(state).keys();\n  };\n}, obj$1.values = iterateMapValues, obj$1.entries = iterateMapValues, obj$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateMapValues, obj$1));\nvar iterateSetValues$1 = makeIterateSetValues(createProxy$1);\n/**\n * Set drafts\n */\n\nvar setTraps$1 = makeTrapsForGetters((obj$1$1 = {}, obj$1$1[DRAFT_STATE] = function (state) {\n  return state;\n}, obj$1$1.size = function (state) {\n  return latest$2(state).size;\n}, obj$1$1.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, obj$1$1.add = function (state) {\n  return function (value) {\n    if (!latest$2(state).has(value)) {\n      markChanged$1(state);\n      state.copy.add(value);\n    }\n\n    return state.draft;\n  };\n}, obj$1$1.delete = function (state) {\n  return function (value) {\n    markChanged$1(state);\n    return state.copy.delete(value);\n  };\n}, obj$1$1.clear = function (state) {\n  return function () {\n    markChanged$1(state);\n    return state.copy.clear();\n  };\n}, obj$1$1.forEach = function (state) {\n  return function (cb, thisArg) {\n    var iterator = iterateSetValues$1(state)();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  };\n}, obj$1$1.keys = iterateSetValues$1, obj$1$1.values = iterateSetValues$1, obj$1$1.entries = iterateSetValues$1, obj$1$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateSetValues$1, obj$1$1));\n/**\n * Helpers\n */\n// Retrieve the latest values of the draft.\n\nfunction latest$2(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest$2(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    var base = state.base;\n    var drafts = state.drafts;\n    var parent = state.parent;\n    var copy = shallowCopy(base);\n\n    if (isSet(base)) {\n      // Note: The `drafts` property is preserved for Set objects, since\n      // we need to keep track of which values are drafted.\n      assignSet(copy, drafts);\n    } else {\n      // Merge nested drafts into the copy.\n      if (isMap(base)) {\n        assignMap(copy, drafts);\n      } else {\n        assign(copy, drafts);\n      }\n\n      state.drafts = null;\n    }\n\n    state.copy = copy;\n\n    if (parent) {\n      markChanged$1(parent);\n    }\n  }\n}\n/** Create traps that all use the `Reflect` API on the `latest(state)` */\n\n\nfunction makeReflectTraps(names) {\n  return names.reduce(function (traps, name) {\n    traps[name] = function (state) {\n      var args = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        args[len] = arguments[len + 1];\n      }\n\n      return Reflect[name].apply(Reflect, [latest$2(state)].concat(args));\n    };\n\n    return traps;\n  }, {});\n}\n\nfunction makeTrapsForGetters(getters) {\n  return Object.assign({}, reflectTraps, {\n    get: function get(state, prop, receiver) {\n      return getters.hasOwnProperty(prop) ? getters[prop](state, prop, receiver) : Reflect.get(state, prop, receiver);\n    },\n    setPrototypeOf: function setPrototypeOf(state) {\n      throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n    }\n  });\n}\n\nvar modernProxy =\n/*#__PURE__*/\nObject.freeze({\n  willFinalize: willFinalize$1,\n  createProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  var generatePatchesFn = Array.isArray(state.base) ? generateArrayPatches : isSet(state.base) ? generateSetPatches : generatePatchesFromAssigned;\n  generatePatchesFn(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    assign = [copy, base], base = assign[0], copy = assign[1];\n    assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1];\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n\n    if (origValue === value && op === \"replace\") {\n      return;\n    }\n\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  var i = 0;\n\n  for (var i$1 = 0, list = base; i$1 < list.length; i$1 += 1) {\n    var value = list[i$1];\n\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  }\n\n  i = 0;\n\n  for (var i$2 = 0, list$1 = copy; i$2 < list$1.length; i$2 += 1) {\n    var value$1 = list$1[i$2];\n\n    if (!base.has(value$1)) {\n      var path$1 = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path$1,\n        value: value$1\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path$1,\n        value: value$1\n      });\n    }\n\n    i++;\n  }\n}\n\nvar applyPatches = function applyPatches(draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n    var path = patch.path;\n    var op = patch.op;\n\n    if (!path.length) {\n      throw new Error(\"Illegal state\");\n    }\n\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n\n      if (!base || typeof base !== \"object\") {\n        throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\"));\n      } // prettier-ignore\n\n    }\n\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        if (isMap(base)) {\n          base.set(key, value);\n        } else if (isSet(base)) {\n          throw new Error('Sets cannot have \"replace\" patches.');\n        } else {\n          // if value is an object, then it's assigned by reference\n          // in the following add or remove ops, the value field inside the patch will also be modifyed\n          // so we use value from the cloned patch\n          base[key] = value;\n        }\n\n        break;\n\n      case \"add\":\n        if (isSet(base)) {\n          base.delete(patch.value);\n        }\n\n        Array.isArray(base) ? base.splice(key, 0, value) : isMap(base) ? base.set(key, value) : isSet(base) ? base.add(value) : base[key] = value;\n        break;\n\n      case \"remove\":\n        Array.isArray(base) ? base.splice(key, 1) : isMap(base) ? base.delete(key) : isSet(base) ? base.delete(patch.value) : delete base[key];\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n\n  return draft;\n};\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\n\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n  this.produceWithPatches = this.produceWithPatches.bind(this);\n};\n\nImmer.prototype.produce = function produce(base, recipe, patchListener) {\n  var this$1 = this; // curried invocation\n\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n      var this$1 = this;\n      if (base === void 0) base = defaultBase;\n      var args = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        args[len] = arguments[len + 1];\n      }\n\n      return self.produce(base, function (draft) {\n        return recipe.call.apply(recipe, [this$1, draft].concat(args));\n      }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) {\n        scope.revoke();\n      } else {\n        scope.leave();\n      }\n    }\n\n    if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n\n    if (result === NOTHING) {\n      return undefined;\n    }\n\n    if (result === undefined) {\n      result = base;\n    }\n\n    this.maybeFreeze(result, true);\n    return result;\n  }\n};\n\nImmer.prototype.produceWithPatches = function produceWithPatches(arg1, arg2, arg3) {\n  var this$1 = this;\n\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n      var args = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        args[len] = arguments[len + 1];\n      }\n\n      return this$1.produceWithPatches(state, function (draft) {\n        return arg1.apply(void 0, [draft].concat(args));\n      });\n    };\n  } // non-curried form\n\n\n  if (arg3) {\n    throw new Error(\"A patch listener cannot be passed to produceWithPatches\");\n  }\n\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\n\nImmer.prototype.createDraft = function createDraft(base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft(draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze(value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies(value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1(base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) {\n    return applyPatches(draft, patches.slice(i + 1));\n  });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult(result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n      this.maybeFreeze(result);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize(draft, path, scope) {\n  var this$1 = this;\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) {\n      return draft;\n    }\n\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    this.maybeFreeze(state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n    if (this.onDelete && !isSet(state.base)) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n        each(assigned, function (prop, exists) {\n          if (!exists) {\n            this$1.onDelete(state, prop);\n          }\n        });\n      } else {\n        // TODO: Figure it out for Maps and Sets if we need to support ES5\n        var base = state.base;\n        var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) {\n            this$1.onDelete(state, prop);\n          }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      freeze(state.copy, false);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree(root, rootPath, scope) {\n  var this$1 = this;\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function finalizeProperty(prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n    var isSetMember = isSet(parent);\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !isSetMember && // Set objects are atomic since they have no keys.\n      !has(state.assigned, prop) // Skip deep patches for assigned keys.\n      ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope);\n      replace(parent, prop, value); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === get(state.base, prop)) {\n        return;\n      }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, get(state.base, prop))) {\n        return;\n      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n      else if (isDraftable(value) && !Object.isFrozen(value)) {\n          each(value, finalizeProperty);\n          this$1.maybeFreeze(value);\n        }\n\n    if (isDraftProp && this$1.onAssign && !isSetMember) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nImmer.prototype.maybeFreeze = function maybeFreeze(value, deep) {\n  if (deep === void 0) deep = false;\n\n  if (this.autoFreeze && !isDraft(value)) {\n    freeze(value, deep);\n  }\n};\n\nfunction replace(parent, prop, value) {\n  if (isMap(parent)) {\n    parent.set(prop, value);\n  } else if (isSet(parent)) {\n    // In this case, the `prop` is actually a draft.\n    parent.delete(prop);\n    parent.add(value);\n  } else if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n    // Preserve non-enumerable properties.\n    parent[prop] = value;\n  } else {\n    Object.defineProperty(parent, prop, {\n      value: value,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };","/*! https://mths.be/esrever v0.2.0 by @mathias */\n;\n\n(function (root) {\n  // Detect free variables `exports`\n  var freeExports = typeof exports == 'object' && exports; // Detect free variable `module`\n\n  var freeModule = typeof module == 'object' && module && module.exports == freeExports && module; // Detect free variable `global`, from Node.js or Browserified code,\n  // and use it as `root`\n\n  var freeGlobal = typeof global == 'object' && global;\n\n  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n    root = freeGlobal;\n  }\n  /*--------------------------------------------------------------------------*/\n\n\n  var regexSymbolWithCombiningMarks = /([\\0-\\u02FF\\u0370-\\u1AAF\\u1B00-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uE000-\\uFE1F\\uFE30-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])([\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]+)/g;\n  var regexSurrogatePair = /([\\uD800-\\uDBFF])([\\uDC00-\\uDFFF])/g;\n\n  var reverse = function reverse(string) {\n    // Step 1: deal with combining marks and astral symbols (surrogate pairs)\n    string = string // Swap symbols with their combining marks so the combining marks go first\n    .replace(regexSymbolWithCombiningMarks, function ($0, $1, $2) {\n      // Reverse the combining marks so they will end up in the same order\n      // later on (after another round of reversing)\n      return reverse($2) + $1;\n    }) // Swap high and low surrogates so the low surrogates go first\n    .replace(regexSurrogatePair, '$2$1'); // Step 2: reverse the code units in the string\n\n    var result = '';\n    var index = string.length;\n\n    while (index--) {\n      result += string.charAt(index);\n    }\n\n    return result;\n  };\n  /*--------------------------------------------------------------------------*/\n\n\n  var esrever = {\n    'version': '0.2.0',\n    'reverse': reverse\n  }; // Some AMD build optimizers, like r.js, check for specific condition patterns\n  // like the following:\n\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    define(function () {\n      return esrever;\n    });\n  } else if (freeExports && !freeExports.nodeType) {\n    if (freeModule) {\n      // in Node.js, io.js, or RingoJS v0.8.0+\n      freeModule.exports = esrever;\n    } else {\n      // in Narwhal or RingoJS v0.7.0-\n      for (var key in esrever) {\n        esrever.hasOwnProperty(key) && (freeExports[key] = esrever[key]);\n      }\n    }\n  } else {\n    // in Rhino or a web browser\n    root.esrever = esrever;\n  }\n})(this);","module.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n\n    module.paths = []; // module.parent = undefined by default\n\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, \"loaded\", {\n      enumerable: true,\n      get: function get() {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, \"id\", {\n      enumerable: true,\n      get: function get() {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};"],"sourceRoot":""}