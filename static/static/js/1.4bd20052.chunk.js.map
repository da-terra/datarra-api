{"version":3,"sources":["../node_modules/tiny-warning/dist/tiny-warning.esm.js","../node_modules/slate/node_modules/is-plain-object/index.js","../node_modules/slate/node_modules/isobject/index.js","../../../../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../../../../node_modules/@babel/runtime/helpers/iterableToArray.js","../../../../node_modules/@babel/runtime/helpers/nonIterableSpread.js","../../../../node_modules/@babel/runtime/helpers/toConsumableArray.js","../../../../node_modules/@babel/runtime/helpers/arrayWithHoles.js","../../../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../../../../node_modules/@babel/runtime/helpers/nonIterableRest.js","../../../../node_modules/@babel/runtime/helpers/slicedToArray.js","../../../../node_modules/@babel/runtime/helpers/defineProperty.js","../../src/interfaces/editor/transforms/general.ts","../../src/create-editor.ts","../../src/interfaces/command.ts","../../src/interfaces/editor/queries/element.ts","../../src/interfaces/editor/queries/general.ts","../../../../node_modules/@babel/runtime/helpers/typeof.js","../../../../node_modules/@babel/runtime/regenerator/index.js","../../../../node_modules/regenerator-runtime/runtime.js","../../src/interfaces/editor/queries/location.ts","../../src/interfaces/editor/transforms/mark.ts","../../../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","../../../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js","../../src/interfaces/editor/transforms/node.ts","../../src/interfaces/editor/index.ts","../../src/interfaces/editor/queries/mark.ts","../../src/interfaces/editor/queries/node.ts","../../src/interfaces/editor/queries/range.ts","../../src/interfaces/editor/transforms/selection.ts","../../src/interfaces/editor/transforms/text.ts","../../src/interfaces/element.ts","../../src/interfaces/location.ts","../../src/interfaces/mark.ts","../../src/interfaces/node.ts","../../src/interfaces/operation.ts","../../src/interfaces/path.ts","../../src/interfaces/path-ref.ts","../../src/interfaces/point.ts","../../src/interfaces/point-ref.ts","../../src/interfaces/range.ts","../../src/interfaces/range-ref.ts","../../src/interfaces/text.ts","../node_modules/compute-scroll-into-view/es/index.js","../node_modules/scroll-into-view-if-needed/es/index.js","../node_modules/slate-react/node_modules/is-plain-object/index.js","../node_modules/slate-react/node_modules/isobject/index.js","../../src/components/string.tsx","../../src/utils/leaf.ts","../../src/utils/weak-maps.ts","../../src/components/leaf.tsx","../../src/components/text.tsx","../../src/hooks/use-selected.ts","../../src/components/element.tsx","../../src/hooks/use-editor.tsx","../../src/components/children.tsx","../../src/utils/environment.ts","../../src/utils/hotkeys.ts","../../src/hooks/use-read-only.ts","../../../../node_modules/@babel/runtime/helpers/classCallCheck.js","../../src/utils/key.ts","../../src/utils/dom.ts","../../src/react-editor.ts","../../src/hooks/use-focused.ts","../../src/hooks/use-slate.tsx","../../src/components/editable.tsx","../../src/react-command.ts","../../src/with-react.ts","../node_modules/slate-history/node_modules/is-plain-object/index.js","../node_modules/slate-history/node_modules/isobject/index.js","../../src/history.ts","../../src/history-command.ts","../../src/history-editor.ts","../../src/with-history.ts","../node_modules/debounce/index.js","../node_modules/direction/index.js","../node_modules/is-hotkey/lib/index.js","../../node_modules/tslib/tslib.es6.js","../node_modules/esrever/esrever.js","../node_modules/webpack/buildin/module.js"],"names":["isProduction","process","warning","condition","message","text","console","warn","Error","x","isObjectObject","o","val","Array","isArray","Object","prototype","toString","call","isPlainObject","ctor","prot","constructor","hasOwnProperty","arr","i","arr2","length","iter","Symbol","iterator","from","TypeError","arrayWithoutHoles","iterableToArray","nonIterableSpread","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","value","err","arrayWithHoles","iterableToArrayLimit","nonIterableRest","obj","key","defineProperty","enumerable","configurable","writable","DIRTY_PATHS","GeneralTransforms","normalize","options","force","Editor","allPaths","Node","getDirtyPaths","max","m","path","entry","editor","transform","createDraft","selection","op","mark","node","Mark","parent","index","Range","point","Point","offset","before","after","prevPath","Path","prev","Text","newPath","truePath","newParent","newIndex","reverse","result","prevNode","nextPath","newNextPath","properties","newProperties","JSON","position","newNode","children","finishDraft","isDraft","FLUSHING","createEditor","operations","isInline","isVoid","onChange","apply","ref","PathRef","PointRef","RangeRef","set","dirtyPaths","add","oldDirtyPaths","newDirtyPaths","Promise","exec","Command","command","unit","always","normalizeNode","Element","marks","at","shouldHaveInlines","n","child","isLast","levels","descendants","p","ancestors","previousPath","oldAncestors","newAncestors","ancestor","isCommand","type","isAddMarkCommand","isCoreCommand","isDeleteBackwardCommand","isDeleteForwardCommand","isDeleteFragmentCommand","isInsertBreakCommand","isInsertFragmentCommand","isInsertNodeCommand","isInsertTextCommand","isRemoveMarkCommand","ElementQueries","hasBlocks","element","hasInlines","hasTexts","isEmpty","first","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","GeneralQueries","isEditor","Operation","isNormalizing","pathRef","affinity","current","unref","pathRefs","refs","pointRef","pointRefs","rangeRef","rangeRefs","withoutNormalizing","fn","_typeof2","_typeof","module","runtime","exports","Op","hasOwn","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","GenStateSuspendedYield","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","__await","then","unwrapped","error","info","resultName","nextLoc","pushTryEntry","locs","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","name","setPrototypeOf","__proto__","awrap","async","keys","object","pop","skipTempReset","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","LocationQueries","activeMarks","mode","continuing","anchor","edge","focus","range","distance","d","target","ancestorPath","edges","elements","nodes","end","fragment","isStart","start","isEnd","isEdge","last","leaf","match","universalMarks","distinctMarks","universalEntries","existing","markEntry","matches","span","to","Span","pass","parentPath","depth","firstPath","lastPath","positions","string","available","isNewBlock","advance","getCharacterDistance","getWordDistance","e","s","reverseText","isFirst","previous","t","texts","SPACE","PUNCTUATION","CHAMELEON","isWordCharacter","remaining","code","SURROGATE_START","started","char","l","rest","MarkTransforms","addMarks","splitLocation","removeMarks","setMarks","newProps","props","hanging","source","excluded","sourceKeys","indexOf","objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","NodeTransforms","insertNodes","select","atMatch","matchPath","isAtEnd","liftNodes","mergeNodes","prevMatch","commonPath","isPreviousSibling","emptyAncestor","emptyRef","moveNodes","toRef","targets","removeNodes","depths","setNodes","k","splitNodes","height","deleteRange","beforeRef","highest","voidMatch","voidNode","voidPath","afterPath","afterRef","highestPath","lowestPath","split","unwrapNodes","wrapNodes","roots","rootPath","a","wrapperPath","wrapper","isMarkMatch","isMatch","unhangRange","closestBlock","blockPath","skip","collapse","deselect","move","opts","setPoint","newPoint","setSelection","oldProps","furthestVoid","isSingleText","startVoid","endVoid","block","startRef","endRef","isBlockAncestor","insertFragment","inlineElementMatch","inlinePath","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","matcher","starts","middles","ends","starting","inlineMatch","isInlineStart","isInlineEnd","middleRef","insertText","isElement","isElementList","isSpan","exists","f","isMark","isMarkSet","c","root","closest","predicate","common","descendant","produce","r","furthest","get","has","isNode","isNodeList","visited","nextIndex","isNodeOperation","isMarkOperation","isOperation","isOperationList","isSelectionOperation","isTextOperation","inverse","paths","another","av","compare","min","Math","endsAfter","as","bs","bv","endsAt","endsBefore","equals","isAfter","isAncestor","isBefore","isChild","isCommon","isDescendant","isParent","isPath","isSibling","list","relative","operation","onp","copy","isPoint","includes","rs","re","ts","te","isAfterStart","isBeforeEnd","intersection","s1","e1","s2","e2","isBackward","isCollapsed","isExpanded","isForward","isRange","isRangeList","isRangeMap","points","affinityAnchor","affinityFocus","isText","isTextList","el","nodeType","canOverflow","overflow","skipOverflowHiddenElements","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","style","getComputedStyle","overflowY","overflowX","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","scrollMode","inline","boundary","checkBoundary","scrollingElement","document","documentElement","frames","cursor","parentNode","body","viewportWidth","window","visualViewport","width","innerWidth","viewportHeight","innerHeight","viewportX","scrollX","pageXOffset","viewportY","scrollY","pageYOffset","_target$getBoundingCl","getBoundingClientRect","targetHeight","targetWidth","targetTop","top","targetRight","right","targetBottom","bottom","targetLeft","left","targetBlock","targetInline","computations","frame","_frame$getBoundingCli","_height","_width","_top","_left","frameStyle","borderLeft","parseInt","borderLeftWidth","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","blockScroll","inlineScroll","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","scrollLeft","scrollTop","isOptionsObject","scrollIntoView","targetIsDetached","ownerDocument","contains","behavior","compute","computeOptions","getOptions","actions","canSmoothScroll","_ref","scroll","defaultBehavior","ReactEditor","findPath","isTrailing","isLineBreak","Leaf","isRangeListEqual","decorations","other","NODE_TO_INDEX","NODE_TO_PARENT","EDITOR_TO_ELEMENT","NODE_TO_ELEMENT","ELEMENT_TO_NODE","NODE_TO_KEY","KEY_TO_ELEMENT","IS_READ_ONLY","IS_FOCUSED","PLACEHOLDER_SYMBOL","MemoizedLeaf","memo","renderDecoration","renderMark","ret","attributes","decoration","SlateLeaf","placeholder","contentEditable","pointerEvents","display","verticalAlign","maxWidth","whiteSpace","opacity","leaves","compile","middle","MemoizedText","findKey","id","delete","SelectedContext","createContext","MemoizedElement","decorate","renderElement","readOnly","dir","Tag","color","outline","Provider","EditorContext","isLeafBlock","concat","sel","ds","dec","ElementComponent","TextComponent","Fragment","IS_APPLE","navigator","test","IS_FIREFOX","IS_SAFARI","HOTKEYS","bold","compose","moveBackward","moveForward","moveWordBackward","moveWordForward","deleteBackward","deleteForward","extendBackward","extendForward","italic","splitBlock","undo","APPLE_HOTKEYS","moveLineBackward","moveLineForward","deleteLineBackward","deleteLineForward","deleteWordBackward","deleteWordForward","extendLineBackward","extendLineForward","redo","transposeCharacter","WINDOWS_HOTKEYS","generic","apple","windows","isGeneric","isKeyHotkey","isApple","isWindows","isBold","isCompose","isMoveBackward","isMoveForward","isDeleteBackward","isDeleteForward","isDeleteLineBackward","isDeleteLineForward","isDeleteWordBackward","isDeleteWordForward","isExtendBackward","isExtendForward","isExtendLineBackward","isExtendLineForward","isItalic","isMoveLineBackward","isMoveLineForward","isMoveWordBackward","isMoveWordForward","isRedo","isSplitBlock","isTransposeCharacter","isUndo","ReadOnlyContext","useReadOnly","useContext","instance","Constructor","Key","isDOMElement","isDOMNode","isDOMText","getEditableChild","childNodes","triedForward","triedBackward","isDOMComment","direction","isFocused","isReadOnly","blur","preventScroll","domSelection","hasDOMNode","editable","toDOMNode","domNode","toDOMPoint","attr","domPoint","toDOMRange","domAnchor","domFocus","domRange","toSlateNode","domEl","findEventRange","event","clientX","y","clientY","rect","isPrev","toSlatePoint","normalizeDOMPoint","nearestNode","nearestOffset","textNode","leafNode","contents","removals","slateNode","toSlateRange","anchorNode","anchorOffset","focusNode","focusOffset","FocusedContext","EDITOR_TO_CONTEXT_LISTENER","WeakMap","SlateContext","defaultValue","setContext","listener","defaultDecorate","propsOnDOMBeforeInput","onDOMBeforeInput","isComposing","isUpdatingSelection","latestElement","addEventListener","onDOMSelectionChange","removeEventListener","getSelection","hasDomSelection","newDomRange","isRangeEqual","getRangeAt","removeAllRanges","addRange","leafEl","startContainer","parentElement","setTimeout","hasEditableTarget","isDOMEventHandled","inputType","data","dataTransfer","preventDefault","startsWith","getTargetRanges","targetRange","DataTransfer","activeElement","rangeCount","endContainer","role","spellCheck","autoCorrect","autoCapitalize","suppressContentEditableWarning","wordWrap","onBeforeInput","onBlur","isEventHandled","relatedTarget","hasAttribute","onClick","hasTarget","onCompositionEnd","onCompositionStart","onCopy","clipboardData","onCut","onDragOver","onDragStart","onDrop","files","onFocus","onKeyDown","nativeEvent","Hotkeys","onPaste","b","startOffset","endOffset","handler","isDefaultPrevented","isPropagationStopped","defaultPrevented","cloneContents","attach","textContent","trim","cloneRange","setEndAfter","querySelector","querySelectorAll","zw","isNewline","getAttribute","createElement","appendChild","stringify","encoded","btoa","encodeURIComponent","setAttribute","setData","div","innerHTML","getPlainText","nodeValue","getPropertyValue","tagName","ReactCommand","isInsertDataCommand","isReactCommand","withReact","decoded","decodeURIComponent","parsed","lines","line","contextOnChange","History","HistoryCommand","isHistoryCommand","isRedoCommand","isUndoCommand","SAVING","MERGING","HistoryEditor","isHistoryEditor","isMerging","isSaving","withoutMerging","withoutSaving","withHistory","undos","redos","history","batch","inverseOps","lastBatch","lastOp","overwrite","shouldOverwrite","save","merge","shouldSave","shouldMerge","shouldClear","debounce","func","wait","immediate","timeout","args","timestamp","later","Date","now","debounced","arguments","callNow","clear","clearTimeout","flush","String","rtl","ltr","LTR","RegExp","IS_MAC","platform","MODIFIERS","alt","control","meta","shift","ALIASES","break","cmd","ctl","ctrl","del","down","esc","ins","mod","opt","option","return","space","spacebar","up","win","CODES","backspace","tab","enter","pause","capslock","escape","pageup","pagedown","home","arrowleft","arrowup","arrowright","arrowdown","insert","numlock","scrolllock","'","isHotkey","hotkey","array","map","parseHotkey","check","some","compareHotkey","byKey","replace","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","optional","endsWith","toKeyName","modifier","which","toKeyCode","expected","actual","toLowerCase","toUpperCase","charCodeAt","default","isCodeHotkey","freeExports","freeGlobal","global","regexSymbolWithCombiningMarks","regexSurrogatePair","esrever","$0","$1","$2","define","webpackPolyfill","deprecate"],"mappings":"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","file":"static/js/1.4bd20052.chunk.js","sourcesContent":["var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nimport isObject from 'isobject';\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport default function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nexport default function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","import { createDraft, finishDraft, isDraft } from 'immer'\nimport {\n  Node,\n  Editor,\n  Mark,\n  Range,\n  Point,\n  Text,\n  Element,\n  Operation,\n  Descendant,\n  Path,\n} from '../../..'\n\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\n\nexport const GeneralTransforms = {\n  /**\n   * Normalize any dirty objects in the editor.\n   */\n\n  normalize(\n    editor: Editor,\n    options: {\n      force?: boolean\n    } = {}\n  ) {\n    const { force = false } = options\n\n    if (!Editor.isNormalizing(editor)) {\n      return\n    }\n\n    if (force) {\n      const allPaths = Array.from(Node.nodes(editor), ([, p]) => p)\n      DIRTY_PATHS.set(editor, allPaths)\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      const max = getDirtyPaths(editor).length * 42 // HACK: better way to do editor?\n      let m = 0\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(`\n            Could not completely normalize the editor after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          `)\n        }\n\n        const path = getDirtyPaths(editor).pop()!\n        const entry = Editor.node(editor, path)\n        editor.normalizeNode(entry)\n        m++\n      }\n    })\n  },\n\n  /**\n   * Transform the editor by an operation.\n   */\n\n  transform(editor: Editor, op: Operation) {\n    editor.children = createDraft(editor.children)\n    let selection = editor.selection && createDraft(editor.selection)\n\n    switch (op.type) {\n      case 'add_mark': {\n        const { path, mark } = op\n        const node = Node.leaf(editor, path)\n\n        if (!Mark.exists(mark, node.marks)) {\n          node.marks.push(mark)\n        }\n\n        break\n      }\n\n      case 'insert_node': {\n        const { path, node } = op\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        parent.children.splice(index, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'insert_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset)\n        node.text = before + text + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'merge_node': {\n        const { path } = op\n        const node = Node.get(editor, path)\n        const prevPath = Path.previous(path)\n        const prev = Node.get(editor, prevPath)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        if (Text.isText(node) && Text.isText(prev)) {\n          prev.text += node.text\n        } else if (!Text.isText(node) && !Text.isText(prev)) {\n          prev.children.push(...node.children)\n        } else {\n          throw new Error(\n            `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interaces: ${node} ${prev}`\n          )\n        }\n\n        parent.children.splice(index, 1)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'move_node': {\n        const { path, newPath } = op\n\n        if (Path.isAncestor(path, newPath)) {\n          throw new Error(\n            `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        parent.children.splice(index, 1)\n        const truePath = Path.transform(path, op)!\n        const newParent = Node.get(editor, Path.parent(truePath))\n        const newIndex = truePath[truePath.length - 1]\n\n        newParent.children.splice(newIndex, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'remove_mark': {\n        const { path, mark } = op\n        const node = Node.leaf(editor, path)\n\n        for (let i = 0; i < node.marks.length; i++) {\n          if (Mark.matches(node.marks[i], mark)) {\n            node.marks.splice(i, 1)\n            break\n          }\n        }\n\n        break\n      }\n\n      case 'remove_node': {\n        const { path } = op\n        const index = path[path.length - 1]\n        const parent = Node.parent(editor, path)\n        const [, prev] = Node.texts(editor, { from: path, reverse: true })\n        const [, next] = Node.texts(editor, { from: path })\n        parent.children.splice(index, 1)\n\n        // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            const result = Point.transform(point, op)\n\n            if (selection != null && result != null) {\n              selection[key] = result\n            } else if (prev) {\n              const [prevNode, prevPath] = prev\n              point.path = prevPath\n              point.offset = prevNode.text.length\n            } else if (next) {\n              const [, nextPath] = next\n              const newNextPath = Path.transform(nextPath, op)!\n              point.path = newNextPath\n              point.offset = 0\n            } else {\n              selection = null\n            }\n          }\n        }\n\n        break\n      }\n\n      case 'remove_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset + text.length)\n        node.text = before + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'set_mark': {\n        const { path, properties, newProperties } = op\n        const node = Node.leaf(editor, path)\n\n        for (const mark of node.marks) {\n          if (Mark.matches(mark, properties)) {\n            Object.assign(mark, newProperties)\n            break\n          }\n        }\n\n        break\n      }\n\n      case 'set_node': {\n        const { path, newProperties } = op\n\n        if (path.length === 0) {\n          throw new Error(`Cannot set properties on the root node!`)\n        }\n\n        const node = Node.get(editor, path)\n        Object.assign(node, newProperties)\n        break\n      }\n\n      case 'set_selection': {\n        const { newProperties } = op\n\n        if (newProperties == null) {\n          selection = newProperties\n        } else if (selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          selection = newProperties\n        } else {\n          Object.assign(selection, newProperties)\n        }\n\n        break\n      }\n\n      case 'split_node': {\n        const { path, position, properties } = op\n\n        if (path.length === 0) {\n          throw new Error(\n            `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        let newNode: Descendant\n\n        if (Text.isText(node)) {\n          const before = node.text.slice(0, position)\n          const after = node.text.slice(position)\n          node.text = before\n          newNode = {\n            ...node,\n            ...(properties as Partial<Text>),\n            text: after,\n          }\n        } else {\n          const before = node.children.slice(0, position)\n          const after = node.children.slice(position)\n          node.children = before\n\n          newNode = {\n            ...node,\n            ...(properties as Partial<Element>),\n            children: after,\n          }\n        }\n\n        parent.children.splice(index + 1, 0, newNode)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n    }\n\n    editor.children = finishDraft(editor.children) as Node[]\n\n    if (selection) {\n      editor.selection = isDraft(selection)\n        ? (finishDraft(selection) as Range)\n        : selection\n    }\n  },\n}\n\nconst getDirtyPaths = (editor: Editor) => {\n  return DIRTY_PATHS.get(editor) || []\n}\n","import {\n  Command,\n  Descendant,\n  Editor,\n  Element,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  PointRef,\n  Range,\n  RangeRef,\n  Text,\n} from '.'\nimport { DIRTY_PATHS } from './interfaces/editor/transforms/general'\n\nconst FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\n\n/**\n * Create a new Slate `Editor` object.\n */\n\nexport const createEditor = (): Editor => {\n  const editor: Editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n    apply: (op: Operation) => {\n      for (const ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.pointRefs(editor)) {\n        PointRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.rangeRefs(editor)) {\n        RangeRef.transform(ref, op)\n      }\n\n      const set = new Set()\n      const dirtyPaths: Path[] = []\n\n      const add = (path: Path | null) => {\n        if (path) {\n          const key = path.join(',')\n\n          if (!set.has(key)) {\n            set.add(key)\n            dirtyPaths.push(path)\n          }\n        }\n      }\n\n      const oldDirtyPaths = DIRTY_PATHS.get(editor) || []\n      const newDirtyPaths = getDirtyPaths(op)\n\n      for (const path of oldDirtyPaths) {\n        const newPath = Path.transform(path, op)\n        add(newPath)\n      }\n\n      for (const path of newDirtyPaths) {\n        add(path)\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths)\n      Editor.transform(editor, op)\n      editor.operations.push(op)\n      Editor.normalize(editor)\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true)\n\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false)\n          editor.onChange(editor.children, editor.operations)\n          editor.operations = []\n        })\n      }\n    },\n    exec: (command: Command) => {\n      const { selection } = editor\n\n      if (Command.isCoreCommand(command)) {\n        switch (command.type) {\n          case 'add_mark': {\n            Editor.addMarks(editor, command.mark)\n            break\n          }\n\n          case 'delete_backward': {\n            if (selection && Range.isCollapsed(selection)) {\n              Editor.delete(editor, { unit: command.unit, reverse: true })\n            }\n\n            break\n          }\n\n          case 'delete_forward': {\n            if (selection && Range.isCollapsed(selection)) {\n              Editor.delete(editor, { unit: command.unit })\n            }\n\n            break\n          }\n\n          case 'delete_fragment': {\n            if (selection && Range.isExpanded(selection)) {\n              Editor.delete(editor)\n            }\n\n            break\n          }\n\n          case 'insert_break': {\n            Editor.splitNodes(editor, { always: true })\n            break\n          }\n\n          case 'insert_fragment': {\n            Editor.insertFragment(editor, command.fragment)\n            break\n          }\n\n          case 'insert_node': {\n            Editor.insertNodes(editor, [command.node])\n            break\n          }\n\n          case 'insert_text': {\n            Editor.insertText(editor, command.text)\n            break\n          }\n\n          case 'remove_mark': {\n            Editor.removeMarks(editor, [command.mark])\n            break\n          }\n        }\n      }\n    },\n    normalizeNode: (entry: NodeEntry) => {\n      const [node, path] = entry\n\n      // There are no core normalizations for text nodes.\n      if (Text.isText(node)) {\n        return\n      }\n\n      // Ensure that block and inline nodes have at least one text child.\n      if (Element.isElement(node) && node.children.length === 0) {\n        const child = { text: '', marks: [] }\n        Editor.insertNodes(editor, child, { at: path.concat(0) })\n        return\n      }\n\n      // Determine whether the node should have block or inline children.\n      const shouldHaveInlines = Editor.isEditor(node)\n        ? false\n        : Element.isElement(node) &&\n          (editor.isInline(node) ||\n            node.children.length === 0 ||\n            Text.isText(node.children[0]) ||\n            editor.isInline(node.children[0]))\n\n      // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n      let n = 0\n\n      for (let i = 0; i < node.children.length; i++, n++) {\n        const child = node.children[i] as Descendant\n        const prev = node.children[i - 1] as Descendant\n        const isLast = i === node.children.length - 1\n        const isInlineOrText =\n          Text.isText(child) ||\n          (Element.isElement(child) && editor.isInline(child))\n\n        // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n          Editor.removeNodes(editor, { at: path.concat(n) })\n          n--\n          continue\n        }\n\n        if (Element.isElement(child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(child)) {\n            if (prev == null || !Text.isText(prev)) {\n              const newChild = { text: '', marks: [] }\n              Editor.insertNodes(editor, newChild, { at: path.concat(n) })\n              n++\n              continue\n            }\n\n            if (isLast) {\n              const newChild = { text: '', marks: [] }\n              Editor.insertNodes(editor, newChild, { at: path.concat(n + 1) })\n              n++\n              continue\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or have matching marks.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.matches(child, prev)) {\n              Editor.mergeNodes(editor, { at: path.concat(n) })\n              n--\n              continue\n            } else if (prev.text === '') {\n              Editor.removeNodes(editor, { at: path.concat(n - 1) })\n              n--\n              continue\n            } else if (isLast && child.text === '') {\n              Editor.removeNodes(editor, { at: path.concat(n) })\n              n--\n              continue\n            }\n          }\n        }\n      }\n    },\n  }\n\n  return editor\n}\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\n\nconst getDirtyPaths = (op: Operation) => {\n  switch (op.type) {\n    case 'add_mark':\n    case 'insert_text':\n    case 'remove_mark':\n    case 'remove_text':\n    case 'set_mark':\n    case 'set_node': {\n      const { path } = op\n      return Path.levels(path)\n    }\n\n    case 'insert_node': {\n      const { node, path } = op\n      const levels = Path.levels(path)\n      const descendants = Text.isText(node)\n        ? []\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n\n      return [...levels, ...descendants]\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      const previousPath = Path.previous(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.equals(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors: Path[] = []\n      const newAncestors: Path[] = []\n\n      for (const ancestor of Path.ancestors(path)) {\n        const p = Path.transform(ancestor, op)\n        oldAncestors.push(p!)\n      }\n\n      for (const ancestor of Path.ancestors(newPath)) {\n        const p = Path.transform(ancestor, op)\n        newAncestors.push(p!)\n      }\n\n      return [...oldAncestors, ...newAncestors]\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      return [...ancestors]\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const levels = Path.levels(path)\n      const nextPath = Path.next(path)\n      return [...levels, nextPath]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n","import isPlainObject from 'is-plain-object'\nimport { Mark, Node, Range } from '..'\n\n/**\n * `Command` objects represent an action that a user is taking on the editor.\n * They capture the semantic \"intent\" of a user while they edit a document.\n */\n\nexport interface Command {\n  type: string\n  [key: string]: any\n}\n\nexport const Command = {\n  /**\n   * Check if a value is a `Command` object.\n   */\n\n  isCommand(value: any): value is Command {\n    return isPlainObject(value) && typeof value.type === 'string'\n  },\n\n  /**\n   * Check if a value is an `AddMarkCommand` object.\n   */\n\n  isAddMarkCommand(value: any): value is AddMarkCommand {\n    return (\n      Command.isCommand(value) &&\n      value.type === 'add_mark' &&\n      Mark.isMark(value.mark)\n    )\n  },\n\n  /**\n   * Check if a value is a `CoreCommand` object.\n   */\n\n  isCoreCommand(value: any): value is CoreCommand {\n    return (\n      Command.isAddMarkCommand(value) ||\n      Command.isDeleteBackwardCommand(value) ||\n      Command.isDeleteForwardCommand(value) ||\n      Command.isDeleteFragmentCommand(value) ||\n      Command.isInsertTextCommand(value) ||\n      Command.isInsertFragmentCommand(value) ||\n      Command.isInsertBreakCommand(value) ||\n      Command.isRemoveMarkCommand(value)\n    )\n  },\n\n  /**\n   * Check if a value is a `DeleteBackwardCommand` object.\n   */\n\n  isDeleteBackwardCommand(value: any): value is DeleteBackwardCommand {\n    return (\n      Command.isCommand(value) &&\n      value.type === 'delete_backward' &&\n      typeof value.unit === 'string'\n    )\n  },\n\n  /**\n   * Check if a value is a `DeleteForwardCommand` object.\n   */\n\n  isDeleteForwardCommand(value: any): value is DeleteForwardCommand {\n    return (\n      Command.isCommand(value) &&\n      value.type === 'delete_forward' &&\n      typeof value.unit === 'string'\n    )\n  },\n\n  /**\n   * Check if a value is a `DeleteFragmentCommand` object.\n   */\n\n  isDeleteFragmentCommand(value: any): value is DeleteFragmentCommand {\n    return Command.isCommand(value) && value.type === 'delete_fragment'\n  },\n\n  /**\n   * Check if a value is an `InsertBreakCommand` object.\n   */\n\n  isInsertBreakCommand(value: any): value is InsertBreakCommand {\n    return Command.isCommand(value) && value.type === 'insert_break'\n  },\n\n  /**\n   * Check if a value is an `InsertFragmentCommand` object.\n   */\n\n  isInsertFragmentCommand(value: any): value is InsertFragmentCommand {\n    return (\n      Command.isCommand(value) &&\n      value.type === 'insert_fragment' &&\n      Node.isNodeList(value.fragment)\n    )\n  },\n\n  /**\n   * Check if a value is an `InsertNodeCommand` object.\n   */\n\n  isInsertNodeCommand(value: any): value is InsertNodeCommand {\n    return (\n      Command.isCommand(value) &&\n      value.type === 'insert_node' &&\n      Node.isNode(value.node)\n    )\n  },\n\n  /**\n   * Check if a value is a `InsertTextCommand` object.\n   */\n\n  isInsertTextCommand(value: any): value is InsertTextCommand {\n    return (\n      Command.isCommand(value) &&\n      value.type === 'insert_text' &&\n      typeof value.text === 'string'\n    )\n  },\n\n  /**\n   * Check if a value is a `RemoveMarkCommand` object.\n   */\n\n  isRemoveMarkCommand(value: any): value is RemoveMarkCommand {\n    return (\n      Command.isCommand(value) &&\n      value.type === 'remove_mark' &&\n      Mark.isMark(value.mark)\n    )\n  },\n}\n\n/**\n * The `AddMarkCommand` adds a mark to the current selection.\n */\n\nexport interface AddMarkCommand {\n  type: 'add_mark'\n  mark: Mark\n}\n\n/**\n * The `DeleteBackwardCommand` delete's content backward, meaning before the\n * current selection, by a specific `unit` of distance.\n */\n\nexport interface DeleteBackwardCommand {\n  type: 'delete_backward'\n  unit: 'character' | 'word' | 'line' | 'block'\n}\n\n/**\n * The `DeleteBackwardCommand` delete's content forward, meaning after the\n * current selection, by a specific `unit` of distance.\n */\n\nexport interface DeleteForwardCommand {\n  type: 'delete_forward'\n  unit: 'character' | 'word' | 'line' | 'block'\n}\n\n/**\n * The `DeleteFragmentCommand` delete's the content of the current selection.\n */\n\nexport interface DeleteFragmentCommand {\n  type: 'delete_fragment'\n}\n\n/**\n * The `InsertBreakCommand` breaks a block in two at the current selection.\n */\n\nexport interface InsertBreakCommand {\n  type: 'insert_break'\n}\n\n/**\n * The `InsertFragmentCommand` inserts a list of nodes at the current selection.\n */\n\nexport interface InsertFragmentCommand {\n  type: 'insert_fragment'\n  fragment: Node[]\n}\n\n/**\n * The `InsertNodeCommand` inserts a node at the current selection.\n */\n\nexport interface InsertNodeCommand {\n  type: 'insert_node'\n  node: Node\n}\n\n/**\n * The `InsertTextCommand` inserts a string of text at the current selection.\n */\n\nexport interface InsertTextCommand {\n  type: 'insert_text'\n  text: string\n}\n\n/**\n * The `RemoveMarkCommand` removes a mark in the current selection.\n */\n\nexport interface RemoveMarkCommand {\n  type: 'remove_mark'\n  mark: Mark\n}\n\n/**\n * The `CoreCommand` union is a set of all of the commands that are recognized\n * by Slate's \"core\" out of the box.\n */\n\nexport type CoreCommand =\n  | AddMarkCommand\n  | DeleteBackwardCommand\n  | DeleteForwardCommand\n  | DeleteFragmentCommand\n  | InsertBreakCommand\n  | InsertFragmentCommand\n  | InsertNodeCommand\n  | InsertTextCommand\n  | RemoveMarkCommand\n","import { Editor, Element, Text } from '../../..'\n\nexport const ElementQueries = {\n  /**\n   * Check if a node has block children.\n   */\n\n  hasBlocks(editor: Editor, element: Element): boolean {\n    return element.children.some(\n      n => Element.isElement(n) && !editor.isInline(n)\n    )\n  },\n\n  /**\n   * Check if a node has inline and text children.\n   */\n\n  hasInlines(editor: Editor, element: Element): boolean {\n    return element.children.some(\n      n => Text.isText(n) || (Element.isElement(n) && editor.isInline(n))\n    )\n  },\n\n  /**\n   * Check if a node has text children.\n   */\n\n  hasTexts(editor: Editor, element: Element): boolean {\n    return element.children.every(n => Text.isText(n))\n  },\n\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n\n  isEmpty(editor: Editor, element: Element): boolean {\n    const { children } = element\n    const [first] = children\n    return (\n      children.length === 0 ||\n      (children.length === 1 &&\n        Text.isText(first) &&\n        first.text === '' &&\n        !editor.isVoid(element))\n    )\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport {\n  Editor,\n  Operation,\n  Path,\n  Point,\n  PathRef,\n  PointRef,\n  Range,\n  RangeRef,\n  Node,\n} from '../../..'\n\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\n\nexport const GeneralQueries = {\n  /**\n   * Check if a value is an `Editor` object.\n   */\n\n  isEditor(value: any): value is Editor {\n    return (\n      isPlainObject(value) &&\n      typeof value.apply === 'function' &&\n      typeof value.exec === 'function' &&\n      typeof value.isInline === 'function' &&\n      typeof value.isVoid === 'function' &&\n      typeof value.normalizeNode === 'function' &&\n      typeof value.onChange === 'function' &&\n      (value.selection === null || Range.isRange(value.selection)) &&\n      Node.isNodeList(value.children) &&\n      Operation.isOperationList(value.operations)\n    )\n  },\n\n  /**\n   * Check if the editor is currently normalizing after each operation.\n   */\n\n  isNormalizing(editor: Editor): boolean {\n    const isNormalizing = NORMALIZING.get(editor)\n    return isNormalizing === undefined ? true : isNormalizing\n  },\n\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pathRef(\n    editor: Editor,\n    path: Path,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PathRef {\n    const { affinity = 'forward' } = options\n    const ref: PathRef = {\n      current: path,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pathRefs = Editor.pathRefs(editor)\n        pathRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pathRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked path refs of the editor.\n   */\n\n  pathRefs(editor: Editor): Set<PathRef> {\n    let refs = PATH_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      PATH_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pointRef(\n    editor: Editor,\n    point: Point,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PointRef {\n    const { affinity = 'forward' } = options\n    const ref: PointRef = {\n      current: point,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pointRefs = Editor.pointRefs(editor)\n        pointRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pointRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked point refs of the editor.\n   */\n\n  pointRefs(editor: Editor): Set<PointRef> {\n    let refs = POINT_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      POINT_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  rangeRef(\n    editor: Editor,\n    range: Range,\n    options: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    } = {}\n  ): RangeRef {\n    const { affinity = 'forward' } = options\n    const ref: RangeRef = {\n      current: range,\n      affinity,\n      unref() {\n        const { current } = ref\n        const rangeRefs = Editor.rangeRefs(editor)\n        rangeRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.rangeRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked range refs of the editor.\n   */\n\n  rangeRefs(editor: Editor): Set<RangeRef> {\n    let refs = RANGE_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      RANGE_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Call a function, deferring normalization until after it completes.\n   */\n\n  withoutNormalizing(editor: Editor, fn: () => void): void {\n    const value = Editor.isNormalizing(editor)\n    NORMALIZING.set(editor, false)\n    fn()\n    NORMALIZING.set(editor, value)\n    Editor.normalize(editor)\n  },\n}\n","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import warning from 'tiny-warning'\nimport { reverse as reverseText } from 'esrever'\n\nimport {\n  Ancestor,\n  AncestorEntry,\n  Descendant,\n  Editor,\n  Element,\n  ElementEntry,\n  Location,\n  Mark,\n  MarkEntry,\n  Node,\n  NodeEntry,\n  NodeMatch,\n  Path,\n  Point,\n  Range,\n  Span,\n  Text,\n  TextEntry,\n} from '../../..'\nimport { MarkMatch } from '../../mark'\n\nexport const LocationQueries = {\n  /**\n   * Get the marks that are \"active\" at a location. These are the\n   * marks that will be added to any text that is inserted.\n   *\n   * The `union: true` option can be passed to create a union of marks across\n   * the text nodes in the selection, instead of creating an intersection, which\n   * is the default.\n   *\n   * Note: to obey common rich text behavior, if the selection is collapsed at\n   * the start of a text node and there are previous text nodes in the same\n   * block, it will carry those marks forward from the previous text node. This\n   * allows for continuation of marks from previous words.\n   */\n\n  activeMarks(\n    editor: Editor,\n    options: {\n      at?: Location\n      union?: boolean\n      hanging?: boolean\n    } = {}\n  ): Mark[] {\n    warning(\n      false,\n      'The `Editor.activeMarks` helper is deprecated, use `Editor.marks` instead.'\n    )\n\n    return Array.from(\n      Editor.marks(editor, {\n        at: options.at,\n        mode: options.union ? 'distinct' : 'universal',\n        continuing: true,\n      }),\n      ([m]) => m\n    )\n  },\n\n  /**\n   * Get the point after a location.\n   */\n\n  after(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.point(editor, at, { edge: 'end' })\n    const focus = Editor.end(editor, [])\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, { ...options, at: range })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Get the common ancestor node of a location.\n   */\n\n  ancestor(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): AncestorEntry {\n    if (Path.isPath(at) || Point.isPoint(at)) {\n      return Editor.parent(editor, at, options)\n    }\n\n    const path = Editor.path(editor, at, options)\n    const ancestorPath = Path.equals(at.anchor.path, at.focus.path)\n      ? Path.parent(path)\n      : path\n\n    const ancestor = Node.get(editor, ancestorPath) as Ancestor\n    return [ancestor, ancestorPath]\n  },\n\n  /**\n   * Get the point before a location.\n   */\n\n  before(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.start(editor, [])\n    const focus = Editor.point(editor, at, { edge: 'start' })\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n      reverse: true,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Get the start and end points of a location.\n   */\n\n  edges(editor: Editor, at: Location): [Point, Point] {\n    return [Editor.start(editor, at), Editor.end(editor, at)]\n  },\n\n  /**\n   * Iterate through all of the elements in the Editor.\n   */\n\n  *elements(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch\n      mode?: 'all' | 'highest'\n      reverse?: boolean\n    } = {}\n  ): Iterable<ElementEntry> {\n    for (const [node, path] of this.nodes(editor, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  },\n\n  /**\n   * Get the end point of a location.\n   */\n\n  end(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'end' })\n  },\n\n  /**\n   * Get the first node at a location.\n   */\n\n  first(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'start' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the fragment at a location.\n   */\n\n  fragment(editor: Editor, at: Location): Descendant[] {\n    const range = Editor.range(editor, at)\n    const fragment = Node.fragment(editor, range)\n    return fragment\n  },\n\n  /**\n   * Check if a point the start point of a location.\n   */\n\n  isStart(editor: Editor, point: Point, at: Location): boolean {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false\n    }\n\n    const start = Editor.start(editor, at)\n    return Point.equals(point, start)\n  },\n\n  /**\n   * Check if a point is the end point of a location.\n   */\n\n  isEnd(editor: Editor, point: Point, at: Location): boolean {\n    const end = Editor.end(editor, at)\n    return Point.equals(point, end)\n  },\n\n  /**\n   * Check if a point is an edge of a location.\n   */\n\n  isEdge(editor: Editor, point: Point, at: Location): boolean {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at)\n  },\n\n  /**\n   * Get the last node at a location.\n   */\n\n  last(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'end' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the leaf text node at a location.\n   */\n\n  leaf(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): TextEntry {\n    const path = Editor.path(editor, at, options)\n    const node = Node.leaf(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the levels at a location.\n   */\n\n  *levels(\n    editor: Editor,\n    options: {\n      at?: Location\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    const { at = editor.selection, reverse = false } = options\n\n    if (!at) {\n      return\n    }\n\n    const levels: NodeEntry[] = []\n    const path = Editor.path(editor, at)\n\n    for (const [n, p] of Node.levels(editor, path)) {\n      levels.push([n, p])\n\n      if (Element.isElement(n) && editor.isVoid(n)) {\n        break\n      }\n    }\n\n    if (reverse) {\n      levels.reverse()\n    }\n\n    yield* levels\n  },\n\n  /**\n   * Iterate through all of the text nodes in the Editor.\n   */\n\n  *marks(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: MarkMatch\n      mode?: 'all' | 'first' | 'distinct' | 'universal'\n      reverse?: boolean\n      continuing?: boolean\n    } = {}\n  ): Iterable<MarkEntry> {\n    const { match, mode = 'all', reverse = false, continuing = false } = options\n    let { at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    // If the range is collapsed at the start of a text node, it should continue\n    // the marks from the previous text node in the same block.\n    if (\n      continuing &&\n      Range.isRange(at) &&\n      Range.isCollapsed(at) &&\n      at.anchor.offset === 0\n    ) {\n      const { anchor } = at\n      const prev = Editor.previous(editor, anchor, 'text')\n\n      if (prev && Path.isSibling(anchor.path, prev[1])) {\n        const [, prevPath] = prev\n        at = Editor.range(editor, prevPath)\n      }\n    }\n\n    const universalMarks: Mark[] = []\n    const distinctMarks: Mark[] = []\n    let universalEntries: MarkEntry[] = []\n    let first = true\n\n    for (const entry of Editor.texts(editor, { reverse, at })) {\n      const [node, path] = entry\n\n      if (mode === 'universal') {\n        if (first) {\n          universalMarks.push(...node.marks)\n          universalEntries = node.marks.map((m, i) => [m, i, node, path])\n          first = false\n          continue\n        }\n\n        // PERF: If we're in universal mode and the eligible marks hits zero\n        // it can never increase again, so we can exit early.\n        if (universalMarks.length === 0) {\n          return\n        }\n\n        for (let i = universalMarks.length - 1; i >= 0; i--) {\n          const existing = universalMarks[i]\n\n          if (!Mark.exists(existing, node.marks)) {\n            universalMarks.splice(i, 1)\n          }\n        }\n      } else {\n        for (let index = 0; index < node.marks.length; index++) {\n          const mark = node.marks[index]\n          const markEntry: MarkEntry = [mark, index, node, path]\n\n          if (match != null && !Editor.isMarkMatch(editor, markEntry, match)) {\n            continue\n          }\n\n          if (mode === 'distinct') {\n            if (Mark.exists(mark, distinctMarks)) {\n              continue\n            } else {\n              distinctMarks.push(mark)\n            }\n          }\n\n          yield markEntry\n\n          // After matching a mark, if we're in first mode skip to the next text.\n          if (mode === 'first') {\n            break\n          }\n        }\n      }\n    }\n\n    // In universal mode, the marks are collected while iterating and we can\n    // only be certain of which are universal when we've finished.\n    if (mode === 'universal') {\n      yield* universalEntries\n    }\n  },\n\n  /**\n   * Get the first matching node in a single branch of the document.\n   */\n\n  match(editor: Editor, at: Location, match: NodeMatch): NodeEntry | undefined {\n    const path = Editor.path(editor, at)\n\n    for (const entry of Editor.levels(editor, { at: path })) {\n      if (Editor.isMatch(editor, entry, match)) {\n        return entry\n      }\n    }\n  },\n\n  /**\n   * Iterate through all of the nodes that match.\n   */\n\n  *matches(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch\n      reverse?: boolean\n    }\n  ): Iterable<NodeEntry> {\n    warning(\n      false,\n      'The `Editor.matches` helper is deprecated, use `Editor.nodes` instead.'\n    )\n\n    const { at = editor.selection, reverse = false } = options\n    let { match } = options\n\n    if (!at) {\n      return\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const path = at\n        match = ([, p]) => Path.equals(p, path)\n      } else {\n        match = () => true\n      }\n    }\n\n    let prevPath: Path | undefined\n\n    for (const [n, p] of Editor.nodes(editor, { at, reverse })) {\n      if (prevPath && Path.compare(p, prevPath) === 0) {\n        continue\n      }\n\n      if (Editor.isMatch(editor, [n, p], match)) {\n        prevPath = p\n        yield [n, p]\n      }\n    }\n  },\n\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n\n  next(editor: Editor, at: Location, match: NodeMatch): NodeEntry | undefined {\n    const [, from] = Editor.last(editor, at)\n    const [, to] = Editor.last(editor, [])\n    const span: Span = [from, to]\n    let i = 0\n\n    for (const entry of Editor.nodes(editor, {\n      at: span,\n      match,\n      mode: 'highest',\n    })) {\n      if (i === 1) {\n        return entry\n      }\n\n      i++\n    }\n  },\n\n  /**\n   * Get the node at a location.\n   */\n\n  node(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry {\n    const path = Editor.path(editor, at, options)\n    const node = Node.get(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the nodes in the Editor.\n   */\n\n  *nodes(\n    editor: Editor,\n    options: {\n      at?: Location | Span\n      match?: NodeMatch\n      mode?: 'all' | 'highest'\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    const {\n      at = editor.selection,\n      match,\n      mode = 'all',\n      reverse = false,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    let from\n    let to\n\n    if (Span.isSpan(at)) {\n      from = at[0]\n      to = at[1]\n    } else {\n      const first = Editor.path(editor, at, { edge: 'start' })\n      const last = Editor.path(editor, at, { edge: 'end' })\n      from = reverse ? last : first\n      to = reverse ? first : last\n    }\n\n    const iterable = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: ([n]) => Element.isElement(n) && editor.isVoid(n),\n    })\n\n    let prev: NodeEntry | undefined\n\n    for (const entry of iterable) {\n      if (match != null) {\n        if (mode === 'highest' && prev) {\n          const [, prevPath] = prev\n          const [, path] = entry\n\n          if (Path.compare(path, prevPath) === 0) {\n            continue\n          }\n        }\n\n        if (!Editor.isMatch(editor, entry, match)) {\n          continue\n        }\n\n        prev = entry\n      }\n\n      yield entry\n    }\n  },\n\n  /**\n   * Get the parent node of a location.\n   */\n\n  parent(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): AncestorEntry {\n    const path = Editor.path(editor, at, options)\n    const parentPath = Path.parent(path)\n    const entry = Editor.node(editor, parentPath)\n    return entry as AncestorEntry\n  },\n\n  /**\n   * Get the path of a location.\n   */\n\n  path(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): Path {\n    const { depth, edge } = options\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        const [, firstPath] = Node.first(editor, at)\n        at = firstPath\n      } else if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        at = lastPath\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at)\n      } else if (edge === 'end') {\n        at = Range.end(at)\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path)\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth)\n    }\n\n    return at\n  },\n\n  /**\n   * Get the start or end point of a location.\n   */\n\n  point(\n    editor: Editor,\n    at: Location,\n    options: {\n      edge?: 'start' | 'end'\n    } = {}\n  ): Point {\n    const { edge = 'start' } = options\n\n    if (Path.isPath(at)) {\n      let path\n\n      if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        path = lastPath\n      } else {\n        const [, firstPath] = Node.first(editor, at)\n        path = firstPath\n      }\n\n      const node = Node.get(editor, path)\n\n      if (!Text.isText(node)) {\n        throw new Error(\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\n        )\n      }\n\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\n    }\n\n    if (Range.isRange(at)) {\n      const [start, end] = Range.edges(at)\n      return edge === 'start' ? start : end\n    }\n\n    return at\n  },\n\n  /**\n   * Iterate through all of the positions in the document where a `Point` can be\n   * placed.\n   *\n   * By default it will move forward by individual offsets at a time,  but you\n   * can pass the `unit: 'character'` option to moved forward one character, word,\n   * or line at at time.\n   *\n   * Note: void nodes are treated as a single point, and iteration will not\n   * happen inside their content.\n   */\n\n  *positions(\n    editor: Editor,\n    options: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n    } = {}\n  ): Iterable<Point> {\n    const { at = editor.selection, unit = 'offset', reverse = false } = options\n\n    if (!at) {\n      return\n    }\n\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    const first = reverse ? end : start\n    let string = ''\n    let available = 0\n    let offset = 0\n    let distance: number | null = null\n    let isNewBlock = false\n\n    const advance = () => {\n      if (distance == null) {\n        if (unit === 'character') {\n          distance = getCharacterDistance(string)\n        } else if (unit === 'word') {\n          distance = getWordDistance(string)\n        } else if (unit === 'line' || unit === 'block') {\n          distance = string.length\n        } else {\n          distance = 1\n        }\n\n        string = string.slice(distance)\n      }\n\n      // Add or substract the offset.\n      offset = reverse ? offset - distance : offset + distance\n      // Subtract the distance traveled from the available text.\n      available = available - distance!\n      // If the available had room to spare, reset the distance so that it will\n      // advance again next time. Otherwise, set it to the overflow amount.\n      distance = available >= 0 ? null : 0 - available\n    }\n\n    for (const [node, path] of Editor.nodes(editor, { at, reverse })) {\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, since we don't want to iterate over\n        // their content. We instead always just yield their first point.\n        if (editor.isVoid(node)) {\n          yield Editor.start(editor, path)\n          continue\n        }\n\n        if (editor.isInline(node)) {\n          continue\n        }\n\n        if (Editor.hasInlines(editor, node)) {\n          const e = Path.isAncestor(path, end.path)\n            ? end\n            : Editor.end(editor, path)\n          const s = Path.isAncestor(path, start.path)\n            ? start\n            : Editor.start(editor, path)\n\n          const text = Editor.text(editor, { anchor: s, focus: e })\n          string = reverse ? reverseText(text) : text\n          isNewBlock = true\n        }\n      }\n\n      if (Text.isText(node)) {\n        const isFirst = Path.equals(path, first.path)\n        available = node.text.length\n        offset = reverse ? available : 0\n\n        if (isFirst) {\n          available = reverse ? first.offset : available - first.offset\n          offset = first.offset\n        }\n\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield { path, offset }\n        }\n\n        while (true) {\n          // If there's no more string, continue to the next block.\n          if (string === '') {\n            break\n          } else {\n            advance()\n          }\n\n          // If the available space hasn't overflow, we have another point to\n          // yield in the current text node.\n          if (available >= 0) {\n            yield { path, offset }\n          } else {\n            break\n          }\n        }\n\n        isNewBlock = false\n      }\n    }\n  },\n\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n\n  previous(\n    editor: Editor,\n    at: Location,\n    match: NodeMatch\n  ): NodeEntry | undefined {\n    const [, from] = Editor.first(editor, at)\n    const [, to] = Editor.first(editor, [])\n    const span: Span = [from, to]\n    let i = 0\n\n    for (const entry of Editor.nodes(editor, {\n      match,\n      at: span,\n      reverse: true,\n      mode: 'highest',\n    })) {\n      if (i === 1) {\n        return entry\n      }\n\n      i++\n    }\n  },\n\n  /**\n   * Get a range of a location.\n   */\n\n  range(editor: Editor, at: Location, to?: Location): Range {\n    if (Range.isRange(at) && !to) {\n      return at\n    }\n\n    const start = Editor.start(editor, at)\n    const end = Editor.end(editor, to || at)\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Get the start point of a location.\n   */\n\n  start(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'start' })\n  },\n\n  /**\n   * Get the text content of a location.\n   *\n   * Note: the text of void nodes is presumed to be an empty string, regardless\n   * of what their actual content is.\n   */\n\n  text(editor: Editor, at: Location): string {\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    let text = ''\n\n    for (const [node, path] of Editor.texts(editor, { at: range })) {\n      let t = node.text\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset)\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset)\n      }\n\n      text += t\n    }\n\n    return text\n  },\n\n  /**\n   * Iterate through all of the text nodes in the Editor.\n   */\n\n  *texts(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch\n      mode?: 'all' | 'highest'\n      reverse?: boolean\n    } = {}\n  ): Iterable<TextEntry> {\n    for (const [node, path] of this.nodes(editor, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  },\n}\n\n/**\n * Constants for string distance checking.\n */\n\nconst SPACE = /\\s/\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\nconst CHAMELEON = /['\\u2018\\u2019]/\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\n\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\n\nconst isWordCharacter = (char: string, remaining: string): boolean => {\n  if (SPACE.test(char)) {\n    return false\n  }\n\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharacterDistance(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n\n    if (isWordCharacter(next, rest)) {\n      return true\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Get the distance to the end of the first character in a string of text.\n */\n\nconst getCharacterDistance = (text: string): number => {\n  const code = text.charCodeAt(0)\n  const isSurrogate = SURROGATE_START <= code && code <= SURROGATE_END\n  return isSurrogate ? 2 : 1\n}\n\n/**\n * Get the distance to the end of the first word in a string of text.\n */\n\nconst getWordDistance = (text: string): number => {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharacterDistance(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWordCharacter(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n","import { Editor, Mark, Location, Range } from '../../..'\n\nexport const MarkTransforms = {\n  /**\n   * Add a set of marks to the text nodes at a location.\n   */\n\n  addMarks(\n    editor: Editor,\n    mark: Mark | Mark[],\n    options: {\n      at?: Location\n      hanging?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const at = splitLocation(editor, options)\n\n      if (!at) {\n        return\n      }\n\n      // De-dupe the marks being added to ensure the set is unique.\n      const marks = Array.isArray(mark) ? mark : [mark]\n      const set: Mark[] = []\n\n      for (const m of marks) {\n        if (!Mark.exists(m, set)) {\n          set.push(m)\n        }\n      }\n\n      for (const [node, path] of Editor.texts(editor, { at })) {\n        for (const m of set) {\n          if (!Mark.exists(m, node.marks)) {\n            editor.apply({ type: 'add_mark', path, mark: m })\n          }\n        }\n      }\n    })\n  },\n\n  removeMarks(\n    editor: Editor,\n    mark: Mark | Mark[],\n    options: {\n      at?: Location\n      hanging?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const at = splitLocation(editor, options)\n\n      if (at) {\n        const marks = Array.isArray(mark) ? mark : [mark]\n        for (const [m, i, node, path] of Editor.marks(editor, { at })) {\n          if (Mark.exists(m, marks)) {\n            editor.apply({ type: 'remove_mark', path, mark: m })\n          }\n        }\n      }\n    })\n  },\n\n  setMarks(\n    editor: Editor,\n    mark: Mark | Mark[],\n    props: Partial<Mark>,\n    options: {\n      at?: Location\n      hanging?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const at = splitLocation(editor, options)\n\n      if (at) {\n        const marks = Array.isArray(mark) ? mark : [mark]\n        for (const [m, i, node, path] of Editor.marks(editor, { at })) {\n          if (Mark.exists(m, marks)) {\n            const newProps = {}\n\n            for (const k in props) {\n              if (props[k] !== m[k]) {\n                newProps[k] = props[k]\n              }\n            }\n\n            if (Object.keys(newProps).length > 0) {\n              editor.apply({\n                type: 'set_mark',\n                path,\n                properties: m,\n                newProperties: newProps,\n              })\n            }\n          }\n        }\n      }\n    })\n  },\n}\n\n/**\n * Split the text nodes at a range's edges to prepare for adding/removing marks.\n */\n\nconst splitLocation = (\n  editor: Editor,\n  options: {\n    at?: Location\n    hanging?: boolean\n  } = {}\n): Location | undefined => {\n  let { at = editor.selection, hanging = false } = options\n\n  if (!at) {\n    return\n  }\n\n  if (Range.isRange(at)) {\n    if (!hanging) {\n      at = Editor.unhangRange(editor, at)\n    }\n\n    const rangeRef = Editor.rangeRef(editor, at, { affinity: 'inward' })\n    const [start, end] = Range.edges(at)\n    Editor.splitNodes(editor, { at: end, match: 'text' })\n    Editor.splitNodes(editor, { at: start, match: 'text' })\n    const range = rangeRef.unref()!\n\n    if (options.at == null) {\n      Editor.select(editor, range)\n    }\n\n    return range\n  }\n\n  return at\n}\n","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  NodeMatch,\n  Path,\n  Point,\n  Range,\n  Text,\n} from '../../..'\n\nexport const NodeTransforms = {\n  /**\n   * Insert nodes at a specific location in the Editor.\n   */\n\n  insertNodes(\n    editor: Editor,\n    nodes: Node | Node[],\n    options: {\n      at?: Location\n      match?: NodeMatch\n      hanging?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { selection } = editor\n      const { hanging = false } = options\n      let { at, match } = options\n      let select = false\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes]\n      }\n\n      if (nodes.length === 0) {\n        return\n      }\n\n      const [node] = nodes\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const path = at\n          match = ([, p]) => Path.equals(p, path)\n        } else if (Text.isText(node)) {\n          match = 'text'\n        } else if (editor.isInline(node)) {\n          match = ['inline', 'text']\n        } else {\n          match = 'block'\n        }\n      }\n\n      // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n      if (!at) {\n        at = selection || Editor.end(editor, []) || [editor.children.length]\n        select = true\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Editor.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        const atMatch = Editor.match(editor, at.path, match)\n\n        if (atMatch) {\n          const [, matchPath] = atMatch\n          const pathRef = Editor.pathRef(editor, matchPath)\n          const isAtEnd = Editor.isEnd(editor, at, matchPath)\n          Editor.splitNodes(editor, { at, match })\n          const path = pathRef.unref()!\n          at = isAtEnd ? Path.next(path) : path\n        } else {\n          return\n        }\n      }\n\n      const parentPath = Path.parent(at)\n      let index = at[at.length - 1]\n\n      if (Editor.match(editor, parentPath, 'void')) {\n        return\n      }\n\n      for (const node of nodes) {\n        const path = parentPath.concat(index)\n        index++\n        editor.apply({ type: 'insert_node', path, node })\n      }\n\n      if (select) {\n        const point = Editor.end(editor, at)\n\n        if (point) {\n          Editor.select(editor, point)\n        }\n      }\n    })\n  },\n\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n\n  liftNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { at = editor.selection } = options\n      let { match } = options\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const path = at\n          match = ([, p]) => Path.equals(p, path)\n        } else {\n          match = 'block'\n        }\n      }\n\n      if (!at) {\n        return\n      }\n\n      const matches = Editor.nodes(editor, { at, match, mode: 'highest' })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path.length < 2) {\n          throw new Error(\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\n          )\n        }\n\n        const [parent, parentPath] = Editor.node(editor, Path.parent(path))\n        const index = path[path.length - 1]\n        const { length } = parent.children\n\n        if (length === 1) {\n          Editor.moveNodes(editor, { at: path, to: Path.next(parentPath) })\n          Editor.removeNodes(editor, { at: parentPath })\n        } else if (index === 0) {\n          Editor.moveNodes(editor, { at: path, to: parentPath })\n        } else if (index === length - 1) {\n          Editor.moveNodes(editor, { at: path, to: Path.next(parentPath) })\n        } else {\n          Editor.splitNodes(editor, { at: Path.next(path) })\n          Editor.moveNodes(editor, { at: path, to: Path.next(parentPath) })\n        }\n      }\n    })\n  },\n\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n\n  mergeNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch\n      hanging?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const { hanging = false } = options\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const path = at\n          match = ([, p]) => Path.equals(p, path)\n        } else {\n          match = 'block'\n        }\n      }\n\n      if (!at) {\n        return\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Editor.delete(editor, { at })\n          at = pointRef.unref()!\n\n          if (options.at == null) {\n            Editor.select(editor, at)\n          }\n        }\n      }\n\n      const current = Editor.match(editor, at, match)\n\n      if (!current) {\n        return\n      }\n\n      let prevMatch: NodeMatch = 'block'\n      const [node, path] = current\n\n      if (Editor.isEditor(node)) {\n        return\n      } else if (Text.isText(node)) {\n        prevMatch = 'text'\n      } else if (editor.isInline(node)) {\n        prevMatch = 'inline'\n      }\n\n      const prev = Editor.previous(editor, at, prevMatch)\n\n      if (!prev) {\n        return\n      }\n\n      const [prevNode, prevPath] = prev\n      const newPath = Path.next(prevPath)\n      const commonPath = Path.common(path, prevPath)\n      const isPreviousSibling = Path.isSibling(path, prevPath)\n\n      // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n      const emptyAncestor = Node.furthest(editor, path, ([n, p]) => {\n        return (\n          Path.isDescendant(p, commonPath) &&\n          Path.isAncestor(p, path) &&\n          Element.isElement(n) &&\n          n.children.length === 1\n        )\n      })\n\n      const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n      let properties\n      let position\n\n      // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        const { text, marks, ...rest } = node\n        position = prevNode.text.length\n        properties = rest as Partial<Text>\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        const { children, ...rest } = node\n        position = prevNode.children.length\n        properties = rest as Partial<Element>\n      } else {\n        throw new Error(\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n            node\n          )} ${JSON.stringify(prevNode)}`\n        )\n      }\n\n      // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n      if (!isPreviousSibling) {\n        Editor.moveNodes(editor, { at: path, to: newPath })\n      }\n\n      // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n      if (emptyRef) {\n        Editor.removeNodes(editor, { at: emptyRef.current! })\n      }\n\n      // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      if (\n        (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n        (Text.isText(prevNode) && prevNode.text === '')\n      ) {\n        Editor.removeNodes(editor, { at: prevPath })\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          target: null,\n          properties,\n        })\n      }\n\n      if (emptyRef) {\n        emptyRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Move the nodes at a location to a new location.\n   */\n\n  moveNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch\n      to: Path\n    }\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { to, at = editor.selection } = options\n      let { match } = options\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const path = at\n          match = ([, p]) => Path.equals(p, path)\n        } else {\n          match = 'block'\n        }\n      }\n\n      if (!at) {\n        return\n      }\n\n      const toRef = Editor.pathRef(editor, to)\n      const targets = Editor.nodes(editor, { at, match, mode: 'highest' })\n      const pathRefs = Array.from(targets, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const newPath = toRef.current!\n\n        if (path.length !== 0) {\n          editor.apply({ type: 'move_node', path, newPath })\n        }\n      }\n\n      toRef.unref()\n    })\n  },\n\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n\n  removeNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch\n      hanging?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const { hanging = false } = options\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const path = at\n          match = ([, p]) => Path.equals(p, path)\n        } else {\n          match = 'block'\n        }\n      }\n\n      if (!at) {\n        return\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      const depths = Editor.nodes(editor, { at, match, mode: 'highest' })\n      const pathRefs = Array.from(depths, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const [node] = Editor.node(editor, path)\n        editor.apply({ type: 'remove_node', path, node })\n      }\n    })\n  },\n\n  /**\n   * Set new properties on the nodes ...\n   */\n\n  setNodes(\n    editor: Editor,\n    props: Partial<Node>,\n    options: {\n      at?: Location\n      match?: NodeMatch\n      hanging?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const { hanging = false } = options\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const path = at\n          match = ([, p]) => Path.equals(p, path)\n        } else {\n          match = 'block'\n        }\n      }\n\n      if (!at) {\n        return\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      for (const [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode: 'highest',\n      })) {\n        const properties: Partial<Node> = {}\n        const newProperties: Partial<Node> = {}\n\n        for (const k in props) {\n          if (\n            k === 'marks' ||\n            k === 'children' ||\n            k === 'selection' ||\n            k === 'text'\n          ) {\n            continue\n          }\n\n          if (props[k] !== node[k]) {\n            properties[k] = node[k]\n            newProperties[k] = props[k]\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties,\n          })\n        }\n      }\n    })\n  },\n\n  /**\n   * Split the nodes at a specific location.\n   */\n\n  splitNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch\n      always?: boolean\n      height?: number\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection, height = 0, always = false } = options\n\n      if (match == null) {\n        match = 'block'\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at)\n      }\n\n      // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n      if (Path.isPath(at)) {\n        const path = at\n        const point = Editor.point(editor, path)\n        match = ([, p]) => p.length === path.length - 1\n        height = point.path.length - path.length + 1\n        at = point\n        always = true\n      }\n\n      if (!at) {\n        return\n      }\n\n      const beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward',\n      })\n      const highest = Editor.match(editor, at, match)\n\n      if (!highest) {\n        return\n      }\n\n      const voidMatch = Editor.match(editor, at, 'void')\n      const nudge = 0\n\n      if (voidMatch) {\n        const [voidNode, voidPath] = voidMatch\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          let after = Editor.after(editor, voidPath)\n\n          if (!after) {\n            const text = { text: '', marks: [] }\n            const afterPath = Path.next(voidPath)\n            Editor.insertNodes(editor, text, { at: afterPath })\n            after = Editor.point(editor, afterPath)!\n          }\n\n          at = after\n          always = true\n        }\n\n        const siblingHeight = at.path.length - voidPath.length\n        height = siblingHeight + 1\n        always = true\n      }\n\n      const afterRef = Editor.pointRef(editor, at)\n      const depth = at.path.length - height\n      const [, highestPath] = highest\n      const lowestPath = at.path.slice(0, depth)\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\n      let target: number | null = null\n\n      for (const [node, path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n      })) {\n        let split = false\n\n        if (\n          path.length < highestPath.length ||\n          path.length === 0 ||\n          (Element.isElement(node) && editor.isVoid(node))\n        ) {\n          break\n        }\n\n        const point = beforeRef.current!\n        const isEnd = Editor.isEnd(editor, point, path)\n\n        if (always || !beforeRef || !Editor.isEdge(editor, point, path)) {\n          split = true\n          const { text, marks, children, ...properties } = node\n          editor.apply({\n            type: 'split_node',\n            path,\n            position,\n            target,\n            properties,\n          })\n        }\n\n        target = position\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\n      }\n\n      if (options.at == null) {\n        const point = afterRef.current || Editor.end(editor, [])\n        Editor.select(editor, point)\n      }\n\n      beforeRef.unref()\n      afterRef.unref()\n    })\n  },\n\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n\n  unwrapNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch\n      split?: boolean\n    }\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { at = editor.selection, split = false } = options\n      let { match } = options\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const path = at\n          match = ([, p]) => Path.equals(p, path)\n        } else {\n          match = 'block'\n        }\n      }\n\n      if (!at) {\n        return\n      }\n\n      const matches = Editor.nodes(editor, { at, match, mode: 'highest' })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const depth = path.length + 1\n        let range = Editor.range(editor, path)\n\n        if (split && Range.isRange(at)) {\n          range = Range.intersection(at, range)!\n        }\n\n        Editor.liftNodes(editor, {\n          at: range,\n          match: ([, p]) => p.length === depth,\n        })\n      }\n    })\n  },\n\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n\n  wrapNodes(\n    editor: Editor,\n    element: Element,\n    options: {\n      at?: Location\n      match?: NodeMatch\n      split?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { split = false } = options\n      let { match, at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const path = at\n          match = ([, p]) => Path.equals(p, path)\n        } else if (editor.isInline(element)) {\n          match = ['inline', 'text']\n        } else {\n          match = 'block'\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        const [start, end] = Range.edges(at)\n        const rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward',\n        })\n        Editor.splitNodes(editor, { at: end, match })\n        Editor.splitNodes(editor, { at: start, match })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Editor.select(editor, at)\n        }\n      }\n\n      const roots: NodeEntry[] = editor.isInline(element)\n        ? Array.from(\n            Editor.nodes(editor, {\n              ...options,\n              at,\n              match: 'block',\n              mode: 'highest',\n            })\n          )\n        : [[editor, []]]\n\n      for (const [, rootPath] of roots) {\n        const a = Range.isRange(at)\n          ? Range.intersection(at, Editor.range(editor, rootPath))\n          : at\n\n        if (!a) {\n          continue\n        }\n\n        const matches = Array.from(\n          Editor.nodes(editor, { ...options, at: a, match, mode: 'highest' })\n        )\n\n        if (matches.length > 0) {\n          const [first] = matches\n          const last = matches[matches.length - 1]\n          const [, firstPath] = first\n          const [, lastPath] = last\n          const commonPath = Path.equals(firstPath, lastPath)\n            ? Path.parent(firstPath)\n            : Path.common(firstPath, lastPath)\n\n          const range = Editor.range(editor, firstPath, lastPath)\n          const depth = commonPath.length + 1\n          const wrapperPath = Path.next(lastPath).slice(0, depth)\n          const wrapper = { ...element, children: [] }\n          Editor.insertNodes(editor, wrapper, { at: wrapperPath })\n\n          Editor.moveNodes(editor, {\n            at: range,\n            match: ([, p]) => p.length === depth,\n            to: wrapperPath.concat(0),\n          })\n        }\n      }\n    })\n  },\n}\n\n/**\n * Convert a range into a point by deleting it's content.\n */\n\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor\n  } else {\n    const [, end] = Range.edges(range)\n    const pointRef = Editor.pointRef(editor, end)\n    Editor.delete(editor, { at: range })\n    return pointRef.unref()\n  }\n}\n","import { Command, Element, Operation, Range, Node, NodeEntry } from '../..'\n\nimport { ElementQueries } from './queries/element'\nimport { GeneralTransforms } from './transforms/general'\nimport { GeneralQueries } from './queries/general'\nimport { LocationQueries } from './queries/location'\nimport { MarkQueries } from './queries/mark'\nimport { MarkTransforms } from './transforms/mark'\nimport { NodeTransforms } from './transforms/node'\nimport { NodeQueries } from './queries/node'\nimport { RangeQueries } from './queries/range'\nimport { SelectionTransforms } from './transforms/selection'\nimport { TextTransforms } from './transforms/text'\n\n/**\n * The `Editor` interface stores all the state of a Slate editor. It is extended\n * by plugins that wish to add their own helpers and implement new behaviors.\n */\n\nexport interface Editor {\n  apply: (operation: Operation) => void\n  children: Node[]\n  exec: (command: Command) => void\n  isInline: (element: Element) => boolean\n  isVoid: (element: Element) => boolean\n  normalizeNode: (entry: NodeEntry) => void\n  onChange: (children: Node[], operations: Operation[]) => void\n  operations: Operation[]\n  selection: Range | null\n  [key: string]: any\n}\n\nexport const Editor = {\n  ...ElementQueries,\n  ...GeneralQueries,\n  ...GeneralTransforms,\n  ...LocationQueries,\n  ...MarkQueries,\n  ...MarkTransforms,\n  ...NodeQueries,\n  ...NodeTransforms,\n  ...RangeQueries,\n  ...SelectionTransforms,\n  ...TextTransforms,\n}\n","import { Editor, Mark, MarkEntry, MarkMatch } from '../../..'\n\nexport const MarkQueries = {\n  /**\n   * Check if a mark entry is a match.\n   */\n\n  isMarkMatch(editor: Editor, entry: MarkEntry, match: MarkMatch): boolean {\n    if (Array.isArray(match)) {\n      return match.some(m => Editor.isMarkMatch(editor, entry, m))\n    } else if (typeof match === 'function') {\n      return match(entry)\n    } else {\n      return Mark.matches(entry[0], match)\n    }\n  },\n}\n","import { Editor, Element, Node, NodeEntry, NodeMatch, Text } from '../../..'\n\nexport const NodeQueries = {\n  /**\n   * Check if a node entry is a match.\n   */\n\n  isMatch(editor: Editor, entry: NodeEntry, match: NodeMatch): boolean {\n    if (Array.isArray(match)) {\n      return match.some(m => Editor.isMatch(editor, entry, m))\n    }\n\n    const [node] = entry\n\n    switch (match) {\n      case 'text':\n        return Text.isText(node)\n      case 'editor':\n        return Editor.isEditor(node)\n      case 'element':\n        return Element.isElement(node)\n      case 'inline':\n        return Element.isElement(node) && editor.isInline(node)\n      case 'block':\n        return (\n          Element.isElement(node) &&\n          !editor.isInline(node) &&\n          Editor.hasInlines(editor, node)\n        )\n      case 'void':\n        return Element.isElement(node) && editor.isVoid(node)\n    }\n\n    if (typeof match === 'function') {\n      return match(entry)\n    } else {\n      return Node.matches(node, match)\n    }\n  },\n}\n","import { Editor, Path, Range } from '../../..'\n\nexport const RangeQueries = {\n  /**\n   * Convert a range into a non-hanging one.\n   */\n\n  unhangRange(editor: Editor, range: Range): Range {\n    let [start, end] = Range.edges(range)\n\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range\n    }\n\n    const closestBlock = Editor.match(editor, end.path, 'block')\n    const blockPath = closestBlock ? closestBlock[1] : []\n    const first = Editor.start(editor, [])\n    const before = { anchor: first, focus: end }\n    let skip = true\n\n    for (const [node, path] of Editor.texts(editor, {\n      at: before,\n      reverse: true,\n    })) {\n      if (skip) {\n        skip = false\n        continue\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = { path, offset: node.text.length }\n        break\n      }\n    }\n\n    return { anchor: start, focus: end }\n  },\n}\n","import { Editor, Location, Point, Range } from '../../..'\n\nexport const SelectionTransforms = {\n  /**\n   * Collapse the selection.\n   */\n\n  collapse(\n    editor: Editor,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { edge = 'anchor' } = options\n    const { selection } = editor\n\n    if (!selection) {\n      return\n    } else if (edge === 'anchor') {\n      Editor.select(editor, selection.anchor)\n    } else if (edge === 'focus') {\n      Editor.select(editor, selection.focus)\n    } else if (edge === 'start') {\n      const [start] = Range.edges(selection)\n      Editor.select(editor, start)\n    } else if (edge === 'end') {\n      const [, end] = Range.edges(selection)\n      Editor.select(editor, end)\n    }\n  },\n\n  /**\n   * Unset the selection.\n   */\n\n  deselect(editor: Editor) {\n    const { selection } = editor\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null,\n      })\n    }\n  },\n\n  /**\n   * Move the selection's point forward or backward.\n   */\n\n  move(\n    editor: Editor,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { selection } = editor\n    const { distance = 1, unit = 'character', reverse = false } = options\n    let { edge = null } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const opts = { distance, unit }\n    const props: Partial<Range> = {}\n\n    if (edge == null || edge === 'anchor') {\n      const point = reverse\n        ? Editor.before(editor, anchor, opts)\n        : Editor.after(editor, anchor, opts)\n\n      if (point) {\n        props.anchor = point\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      const point = reverse\n        ? Editor.before(editor, focus, opts)\n        : Editor.after(editor, focus, opts)\n\n      if (point) {\n        props.focus = point\n      }\n    }\n\n    Editor.setSelection(editor, props)\n  },\n\n  /**\n   * Set the selection to a new value.\n   */\n\n  select(editor: Editor, target: Location) {\n    const { selection } = editor\n    target = Editor.range(editor, target)\n\n    if (selection) {\n      Editor.setSelection(editor, target)\n      return\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\n          target\n        )}`\n      )\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target,\n    })\n  },\n\n  /**\n   * Set new properties on one of the selection's points.\n   */\n\n  setPoint(\n    editor: Editor,\n    props: Partial<Point>,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) {\n    const { selection } = editor\n    let { edge = 'both' } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const point = edge === 'anchor' ? anchor : focus\n    const newPoint = Object.assign(point, props)\n\n    if (edge === 'anchor') {\n      Editor.setSelection(editor, { anchor: newPoint })\n    } else {\n      Editor.setSelection(editor, { focus: newPoint })\n    }\n  },\n\n  /**\n   * Set new properties on the selection.\n   */\n\n  setSelection(editor: Editor, props: Partial<Range>) {\n    const { selection } = editor\n    const oldProps: Partial<Range> | null = {}\n    const newProps: Partial<Range> = {}\n\n    if (!selection) {\n      return\n    }\n\n    for (const k in props) {\n      if (\n        (k === 'anchor' &&\n          props.anchor != null &&\n          !Point.equals(props.anchor, selection.anchor)) ||\n        (k === 'focus' &&\n          props.focus != null &&\n          !Point.equals(props.focus, selection.focus)) ||\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\n      ) {\n        oldProps[k] = selection[k]\n        newProps[k] = props[k]\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps,\n      })\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Path,\n  Point,\n  Range,\n} from '../../..'\n\nexport const TextTransforms = {\n  /**\n   * Delete content in the editor.\n   */\n\n  delete(\n    editor: Editor,\n    options: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { reverse = false, unit = 'character', distance = 1 } = options\n      let { at = editor.selection, hanging = false } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor\n      }\n\n      if (Point.isPoint(at)) {\n        const furthestVoid = Editor.match(editor, at.path, 'void')\n\n        if (furthestVoid) {\n          const [, voidPath] = furthestVoid\n          at = voidPath\n        } else {\n          const opts = { unit, distance }\n          const target = reverse\n            ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n            : Editor.after(editor, at, opts) || Editor.end(editor, [])\n          at = { anchor: at, focus: target }\n          hanging = true\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Editor.removeNodes(editor, { at })\n        return\n      }\n\n      if (Range.isCollapsed(at)) {\n        return\n      }\n\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      let [start, end] = Range.edges(at)\n      const [ancestor] = Editor.ancestor(editor, at)\n      const isSingleText = Path.equals(start.path, end.path)\n      const startVoid = Editor.match(editor, start.path, 'void')\n      const endVoid = Editor.match(editor, end.path, 'void')\n\n      // If the start or end points are inside an inline void, nudge them out.\n      if (startVoid) {\n        const block = Editor.match(editor, start.path, 'block')\n        const before = Editor.before(editor, start)\n\n        if (before && block && Path.isAncestor(block[1], before.path)) {\n          start = before\n        }\n      }\n\n      if (endVoid) {\n        const block = Editor.match(editor, end.path, 'block')\n        const after = Editor.after(editor, end)\n\n        if (after && block && Path.isAncestor(block[1], after.path)) {\n          end = after\n        }\n      }\n\n      // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n      const matches = Editor.nodes(editor, {\n        at,\n        mode: 'highest',\n        match: ([n, p]) =>\n          (Element.isElement(n) && editor.isVoid(n)) ||\n          (!Path.isCommon(p, start.path) && !Path.isCommon(p, end.path)),\n      })\n\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n      const startRef = Editor.pointRef(editor, start)\n      const endRef = Editor.pointRef(editor, end)\n\n      if (!isSingleText && !startVoid) {\n        const point = startRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const { offset } = start\n        const text = node.text.slice(offset)\n        editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        Editor.removeNodes(editor, { at: path })\n      }\n\n      if (!endVoid) {\n        const point = endRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const offset = isSingleText ? start.offset : 0\n        const text = node.text.slice(offset, end.offset)\n        editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      const isBlockAncestor =\n        Editor.isEditor(ancestor) ||\n        (Element.isElement(ancestor) && !editor.isInline(ancestor))\n\n      if (\n        !isSingleText &&\n        isBlockAncestor &&\n        endRef.current &&\n        startRef.current\n      ) {\n        Editor.mergeNodes(editor, { at: endRef.current, hanging: true })\n      }\n\n      const point = endRef.unref() || startRef.unref()\n\n      if (options.at == null && point) {\n        Editor.select(editor, point)\n      }\n    })\n  },\n\n  /**\n   * Insert a fragment at a specific location in the editor.\n   */\n\n  insertFragment(\n    editor: Editor,\n    fragment: Node[],\n    options: {\n      at?: Location\n      hanging?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { at = editor.selection } = options\n      const { hanging = false } = options\n\n      if (!fragment.length) {\n        return\n      }\n\n      if (!at) {\n        return\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Editor.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at)\n      }\n\n      if (Editor.match(editor, at.path, 'void')) {\n        return\n      }\n\n      // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n      const inlineElementMatch = Editor.match(editor, at, 'inline')\n\n      if (inlineElementMatch) {\n        const [, inlinePath] = inlineElementMatch\n\n        if (Editor.isEnd(editor, at, inlinePath)) {\n          const after = Editor.after(editor, inlinePath)!\n          at = after\n        } else if (Editor.isStart(editor, at, inlinePath)) {\n          const before = Editor.before(editor, inlinePath)!\n          at = before\n        }\n      }\n\n      const blockMatch = Editor.match(editor, at, 'block')!\n      const [, blockPath] = blockMatch\n      const isBlockStart = Editor.isStart(editor, at, blockPath)\n      const isBlockEnd = Editor.isEnd(editor, at, blockPath)\n      const mergeStart = !isBlockStart || (isBlockStart && isBlockEnd)\n      const mergeEnd = !isBlockEnd\n      const [, firstPath] = Node.first({ children: fragment }, [])\n      const [, lastPath] = Node.last({ children: fragment }, [])\n\n      // TODO: convert into a proper `Nodes.matches` iterable\n      const matches: NodeEntry[] = []\n\n      const matcher = ([n, p]: NodeEntry) => {\n        if (\n          mergeStart &&\n          Path.isAncestor(p, firstPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        if (\n          mergeEnd &&\n          Path.isAncestor(p, lastPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        return true\n      }\n\n      for (const entry of Node.nodes(\n        { children: fragment },\n        { pass: matcher }\n      )) {\n        if (entry[1].length > 0 && matcher(entry)) {\n          matches.push(entry)\n        }\n      }\n\n      const starts = []\n      const middles = []\n      const ends = []\n      let starting = true\n      let hasBlocks = false\n\n      for (const [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false\n          hasBlocks = true\n          middles.push(node)\n        } else if (starting) {\n          starts.push(node)\n        } else {\n          ends.push(node)\n        }\n      }\n\n      const inlineMatch = Editor.match(editor, at, ['inline', 'text'])!\n      const [, inlinePath] = inlineMatch\n      const isInlineStart = Editor.isStart(editor, at, inlinePath)\n      const isInlineEnd = Editor.isEnd(editor, at, inlinePath)\n\n      const middleRef = Editor.pathRef(\n        editor,\n        isBlockEnd ? Path.next(blockPath) : blockPath\n      )\n\n      const endRef = Editor.pathRef(\n        editor,\n        isInlineEnd ? Path.next(inlinePath) : inlinePath\n      )\n\n      Editor.splitNodes(editor, {\n        at,\n        match: hasBlocks ? 'block' : ['inline', 'text'],\n      })\n\n      const startRef = Editor.pathRef(\n        editor,\n        !isInlineStart || (isInlineStart && isInlineEnd)\n          ? Path.next(inlinePath)\n          : inlinePath\n      )\n\n      Editor.insertNodes(editor, starts, {\n        at: startRef.current!,\n        match: ['inline', 'text'],\n      })\n\n      Editor.insertNodes(editor, middles, {\n        at: middleRef.current!,\n        match: 'block',\n      })\n\n      Editor.insertNodes(editor, ends, {\n        at: endRef.current!,\n        match: ['inline', 'text'],\n      })\n\n      if (!options.at) {\n        let path\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current!)\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current!)\n        } else {\n          path = Path.previous(startRef.current!)\n        }\n\n        const end = Editor.end(editor, path)\n        Editor.select(editor, end)\n      }\n\n      startRef.unref()\n      middleRef.unref()\n      endRef.unref()\n    })\n  },\n\n  /**\n   * Insert a string of text in the Editor.\n   */\n\n  insertText(\n    editor: Editor,\n    text: string,\n    options: {\n      at?: Location\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const pointRef = Editor.pointRef(editor, Range.end(at))\n          Editor.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Editor.match(editor, at.path, 'void')) {\n        return\n      }\n\n      const { path, offset } = at\n      editor.apply({ type: 'insert_text', path, offset, text })\n    })\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { Editor, Node, Path } from '..'\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's schema.\n */\n\nexport interface Element {\n  children: Node[]\n  [key: string]: any\n}\n\nexport const Element = {\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n\n  isElement(value: any): value is Element {\n    return (\n      isPlainObject(value) &&\n      Node.isNodeList(value.children) &&\n      !Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n\n  isElementList(value: any): value is Element[] {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Element.isElement(value[0]))\n    )\n  },\n\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n\n  matches(element: Element, props: Partial<Element>): boolean {\n    for (const key in props) {\n      if (key === 'children') {\n        continue\n      }\n\n      if (element[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n\nexport type ElementEntry = [Element, Path]\n","import { Path, Point, Range } from '..'\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\n\nexport type Location = Path | Point | Range\n\nexport const Location = {\n  /**\n   * Check if a value implements the `Location` interface.\n   */\n\n  isLocation(value: any): value is Location {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\n  },\n}\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\n\nexport type Span = [Path, Path]\n\nexport const Span = {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n\n  isSpan(value: any): value is Span {\n    return (\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\n    )\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { Path, Text } from '..'\n\n/**\n * `Mark` objects represent formatting that is applied to text in a Slate\n * document. They appear in leaf text nodes in the document.\n */\n\nexport interface Mark {\n  [key: string]: any\n}\n\nexport const Mark = {\n  /**\n   * Check if a mark exists in a set of marks.\n   */\n\n  exists(mark: Mark, marks: Mark[]): boolean {\n    return !!marks.find(f => Mark.matches(f, mark))\n  },\n\n  /**\n   * Check if a value implements the `Mark` interface.\n   */\n\n  isMark(value: any): value is Mark {\n    return isPlainObject(value)\n  },\n\n  /**\n   * Check if a value is an array of `Mark` objects.\n   */\n\n  isMarkSet(value: any): value is Mark[] {\n    return Array.isArray(value) && (value.length === 0 || Mark.isMark(value[0]))\n  },\n\n  /**\n   * Check if a mark matches set of properties.\n   */\n\n  matches(mark: Mark, props: Partial<Mark>): boolean {\n    for (const key in props) {\n      if (mark[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `MarkEntry` tuples are returned when iterating through the marks in a text\n * node. They include the index of the mark in the text node's marks array, as\n * well as the text node and its path in the root node.\n */\n\nexport type MarkEntry = [Mark, number, Text, Path]\n\n/**\n * `MarkMatch` values are used as shorthands for matching mark objects.\n */\n\nexport type MarkMatch =\n  | Partial<Mark>\n  | ((entry: MarkEntry) => boolean)\n  | MarkMatch[]\n","import { produce } from 'immer'\nimport {\n  Editor,\n  Element,\n  ElementEntry,\n  MarkEntry,\n  Path,\n  Range,\n  Text,\n  TextEntry,\n} from '..'\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\n\nexport type Node = Editor | Element | Text\n\nexport const Node = {\n  matches(node: Node, props: Partial<Node>): boolean {\n    return (\n      (Element.isElement(node) && Element.matches(node, props)) ||\n      (Text.isText(node) && Text.matches(node, props))\n    )\n  },\n\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n\n  ancestor(root: Node, path: Path): Ancestor {\n    const node = Node.get(root, path)\n\n    if (Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return an iterable of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go top-down.\n   */\n\n  *ancestors(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Iterable<AncestorEntry> {\n    for (const p of Path.ancestors(path, options)) {\n      const n = Node.ancestor(root, p)\n      const entry: AncestorEntry = [n, p]\n      yield entry\n    }\n  },\n\n  /**\n   * Get the child of a node at a specific index.\n   */\n\n  child(root: Node, index: number): Descendant {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\n      )\n    }\n\n    const c = root.children[index] as Descendant\n\n    if (c == null) {\n      throw new Error(\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    return c\n  },\n\n  /**\n   * Find the closest matching node entry starting from a specific path.\n   */\n\n  closest(\n    root: Node,\n    path: Path,\n    predicate: (entry: NodeEntry) => boolean\n  ): NodeEntry | undefined {\n    for (const entry of Node.levels(root, path, { reverse: true })) {\n      if (predicate(entry)) {\n        return entry\n      }\n    }\n  },\n\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n\n  common(root: Node, path: Path, another: Path): NodeEntry {\n    const p = Path.common(path, another)\n    const n = Node.get(root, p)\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n\n  descendant(root: Node, path: Path): Descendant {\n    const node = Node.get(root, path)\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\n        `Cannot get the descendant node at path [${path}] because it refers to the root editor node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return an iterable of all the descendant node entries inside a root node.\n   */\n\n  *descendants(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<DescendantEntry> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path] as DescendantEntry\n      }\n    }\n  },\n\n  /**\n   * Return an iterable of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n\n  *elements(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<ElementEntry> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  },\n\n  /**\n   * Get the first node entry in a root node from a path.\n   */\n\n  first(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        n = n.children[0]\n        p.push(0)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n\n  fragment(root: Node, range: Range): Descendant[] {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    const newRoot = produce(root, r => {\n      const [start, end] = Range.edges(range)\n      const iterable = Node.nodes(r, {\n        reverse: true,\n        pass: ([, path]) => !Range.includes(range, path),\n      })\n\n      for (const [, path] of iterable) {\n        if (!Range.includes(range, path)) {\n          const parent = Node.parent(r, path)\n          const index = path[path.length - 1]\n          parent.children.splice(index, 1)\n        }\n\n        if (Path.equals(path, end.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(0, end.offset)\n        }\n\n        if (Path.equals(path, start.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(start.offset)\n        }\n      }\n\n      delete r.selection\n    })\n\n    return newRoot.children\n  },\n\n  /**\n   * Find the furthest matching node entry starting from a specific path.\n   */\n\n  furthest(\n    root: Node,\n    path: Path,\n    predicate: (entry: NodeEntry) => boolean\n  ): NodeEntry | undefined {\n    for (const entry of Node.levels(root, path)) {\n      if (predicate(entry)) {\n        return entry\n      }\n    }\n  },\n\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n\n  get(root: Node, path: Path): Node {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\n            root\n          )}`\n        )\n      }\n\n      node = node.children[p]\n    }\n\n    return node\n  },\n\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n\n  has(root: Node, path: Path): boolean {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false\n      }\n\n      node = node.children[p]\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n\n  isNode(value: any): value is Node {\n    return (\n      Text.isText(value) || Element.isElement(value) || Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n\n  isNodeList(value: any): value is Node[] {\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]))\n  },\n\n  /**\n   * Get the lash node entry in a root node from a path.\n   */\n\n  last(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        const i = n.children.length - 1\n        n = n.children[i]\n        p.push(i)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n\n  leaf(root: Node, path: Path): Text {\n    const node = Node.get(root, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return an iterable of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from lowest to highest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n\n  *levels(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    for (const p of Path.levels(path, options)) {\n      const n = Node.get(root, p)\n      yield [n, p]\n    }\n  },\n\n  /**\n   * Return an iterable of all the marks in all of the text nodes in a root node.\n   */\n\n  *marks(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<MarkEntry> {\n    for (const [node, path] of Node.texts(root, options)) {\n      for (let i = 0; i < node.marks.length; i++) {\n        const mark = node.marks[i]\n        yield [mark, i, node, path]\n      }\n    }\n  },\n\n  /**\n   * Return an iterable of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n\n  *nodes(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    const { pass, reverse = false } = options\n    const { from = [], to } = options\n    const visited = new Set()\n    let p: Path = []\n    let n = root\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p]\n      }\n\n      // If we're allowed to go downward and we haven't decsended yet, do.\n      if (\n        !visited.has(n) &&\n        !Text.isText(n) &&\n        n.children.length !== 0 &&\n        (pass == null || pass([n, p]) === false)\n      ) {\n        visited.add(n)\n        let nextIndex = reverse ? n.children.length - 1 : 0\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length]\n        }\n\n        p = p.concat(nextIndex)\n        n = Node.get(root, p)\n        continue\n      }\n\n      // If we're at the root and we can't go down, we're done.\n      if (p.length === 0) {\n        break\n      }\n\n      // If we're going forward...\n      if (!reverse) {\n        const newPath = Path.next(p)\n\n        if (Node.has(root, newPath)) {\n          p = newPath\n          n = Node.get(root, p)\n          continue\n        }\n      }\n\n      // If we're going backward...\n      if (reverse && p[p.length - 1] !== 0) {\n        const newPath = Path.previous(p)\n        p = newPath\n        n = Node.get(root, p)\n        continue\n      }\n\n      // Otherwise we're going upward...\n      p = Path.parent(p)\n      n = Node.get(root, p)\n      visited.add(n)\n    }\n  },\n\n  /**\n   * Get the parent of a node at a specific path.\n   */\n\n  parent(root: Node, path: Path): Ancestor {\n    const parentPath = Path.parent(path)\n    const p = Node.get(root, parentPath)\n\n    if (Text.isText(p)) {\n      throw new Error(\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\n      )\n    }\n\n    return p\n  },\n\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n\n  text(node: Node): string {\n    if (Text.isText(node)) {\n      return node.text\n    } else {\n      return node.children.map(Node.text).join('')\n    }\n  },\n\n  /**\n   * Return an iterable of all leaf text nodes in a root node.\n   */\n\n  *texts(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<TextEntry> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  },\n}\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = Element | Text\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\n * It is returned as a convenience in certain cases to narrow a value further\n * than the more generic `Node` union.\n */\n\nexport type Ancestor = Editor | Element\n\n/**\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\n * document tree. They consist of the node and its `Path` relative to the root\n * node in the document.\n */\n\nexport type NodeEntry = [Node, Path]\n\n/**\n * `DescendantEntry` objects are returned when iterating over the descendants in\n * a Slate document tree.\n */\n\nexport type DescendantEntry = [Descendant, Path]\n\n/**\n * `AncestorEntry` objects are returned when iterating over the ancestors in a\n * Slate document tree.\n */\n\nexport type AncestorEntry = [Ancestor, Path]\n\n/**\n * `NodeMatch` values are used as shorthands for matching a node by either its\n * kind, its location, its behavior or its properties.\n */\n\nexport type NodeMatch =\n  | 'block'\n  | 'element'\n  | 'inline'\n  | 'text'\n  | 'editor'\n  | 'void'\n  | Partial<Node>\n  | ((entry: NodeEntry) => boolean)\n  | NodeMatch[]\n","import { Mark, Node, Path, Range } from '..'\nimport isPlainObject from 'is-plain-object'\n\ntype AddMarkOperation = {\n  type: 'add_mark'\n  path: Path\n  mark: Mark\n  [key: string]: any\n}\n\ntype InsertNodeOperation = {\n  type: 'insert_node'\n  path: Path\n  node: Node\n  [key: string]: any\n}\n\ntype InsertTextOperation = {\n  type: 'insert_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: any\n}\n\ntype MergeNodeOperation = {\n  type: 'merge_node'\n  path: Path\n  position: number\n  target: number | null\n  properties: Partial<Node>\n  [key: string]: any\n}\n\ntype MoveNodeOperation = {\n  type: 'move_node'\n  path: Path\n  newPath: Path\n  [key: string]: any\n}\n\ntype RemoveMarkOperation = {\n  type: 'remove_mark'\n  path: Path\n  mark: Mark\n  [key: string]: any\n}\n\ntype RemoveNodeOperation = {\n  type: 'remove_node'\n  path: Path\n  node: Node\n  [key: string]: any\n}\n\ntype RemoveTextOperation = {\n  type: 'remove_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: any\n}\n\ntype SetMarkOperation = {\n  type: 'set_mark'\n  path: Path\n  properties: Partial<Mark>\n  newProperties: Partial<Mark>\n  [key: string]: any\n}\n\ntype SetNodeOperation = {\n  type: 'set_node'\n  path: Path\n  properties: Partial<Node>\n  newProperties: Partial<Node>\n  [key: string]: any\n}\n\ntype SetSelectionOperation =\n  | {\n      type: 'set_selection'\n      [key: string]: any\n      properties: null\n      newProperties: Range\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: any\n      properties: Partial<Range>\n      newProperties: Partial<Range>\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: any\n      properties: Range\n      newProperties: null\n    }\n\ntype SplitNodeOperation = {\n  type: 'split_node'\n  path: Path\n  position: number\n  target: number | null\n  properties: Partial<Node>\n  [key: string]: any\n}\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\n\ntype Operation =\n  | NodeOperation\n  | MarkOperation\n  | SelectionOperation\n  | TextOperation\n\ntype NodeOperation =\n  | InsertNodeOperation\n  | MergeNodeOperation\n  | MoveNodeOperation\n  | RemoveNodeOperation\n  | SetNodeOperation\n  | SplitNodeOperation\n\ntype MarkOperation = AddMarkOperation | RemoveMarkOperation | SetMarkOperation\n\ntype SelectionOperation = SetSelectionOperation\n\ntype TextOperation = InsertTextOperation | RemoveTextOperation\n\nconst Operation = {\n  /**\n   * Check of a value is a `NodeOperation` object.\n   */\n\n  isNodeOperation(value: any): value is NodeOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_node')\n  },\n\n  /**\n   * Check of a value is a `MarkOperation` object.\n   */\n\n  isMarkOperation(value: any): value is MarkOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_mark')\n  },\n\n  /**\n   * Check of a value is an `Operation` object.\n   */\n\n  isOperation(value: any): value is Operation {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    switch (value.type) {\n      case 'add_mark': {\n        return Path.isPath(value.path) && Mark.isMark(value.mark)\n      }\n\n      case 'insert_node': {\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      }\n\n      case 'insert_text': {\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      }\n\n      case 'merge_node': {\n        return (\n          typeof value.position === 'number' &&\n          (typeof value.target === 'number' || value.target === null) &&\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties)\n        )\n      }\n\n      case 'move_node': {\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\n      }\n\n      case 'remove_mark': {\n        return Path.isPath(value.path) && Mark.isMark(value.mark)\n      }\n\n      case 'remove_node': {\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      }\n\n      case 'remove_text': {\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      }\n\n      case 'set_mark': {\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      }\n\n      case 'set_node': {\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      }\n\n      case 'set_selection': {\n        return (\n          (value.properties === null && Range.isRange(value.newProperties)) ||\n          (value.newProperties === null && Range.isRange(value.properties)) ||\n          (isPlainObject(value.properties) &&\n            isPlainObject(value.newProperties))\n        )\n      }\n\n      case 'set_value': {\n        return (\n          isPlainObject(value.properties) && isPlainObject(value.newProperties)\n        )\n      }\n\n      case 'split_node': {\n        return (\n          Path.isPath(value.path) &&\n          typeof value.position === 'number' &&\n          (typeof value.target === 'number' || value.target === null) &&\n          isPlainObject(value.properties)\n        )\n      }\n\n      default: {\n        return false\n      }\n    }\n  },\n\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n\n  isOperationList(value: any): value is Operation[] {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Operation.isOperation(value[0]))\n    )\n  },\n\n  /**\n   * Check of a value is a `SelectionOperation` object.\n   */\n\n  isSelectionOperation(value: any): value is SelectionOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\n  },\n\n  /**\n   * Check of a value is a `TextOperation` object.\n   */\n\n  isTextOperation(value: any): value is TextOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_text')\n  },\n\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n\n  inverse(op: Operation): Operation {\n    switch (op.type) {\n      case 'add_mark': {\n        return { ...op, type: 'remove_mark' }\n      }\n\n      case 'insert_node': {\n        return { ...op, type: 'remove_node' }\n      }\n\n      case 'insert_text': {\n        return { ...op, type: 'remove_text' }\n      }\n\n      case 'merge_node': {\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\n      }\n\n      case 'move_node': {\n        const { newPath, path } = op\n\n        // PERF: in this case the move operation is a no-op anyways.\n        if (Path.equals(newPath, path)) {\n          return op\n        }\n\n        // We need to get the original path here, but sometimes the `newPath`\n        // is a younger sibling of (or ends before) the original, and this\n        // accounts for it.\n        const inversePath = Path.transform(path, op)!\n        const inverseNewPath = Path.transform(Path.next(path), op)!\n        return { ...op, path: inversePath, newPath: inverseNewPath }\n      }\n\n      case 'remove_mark': {\n        return { ...op, type: 'add_mark' }\n      }\n\n      case 'remove_node': {\n        return { ...op, type: 'insert_node' }\n      }\n\n      case 'remove_text': {\n        return { ...op, type: 'insert_text' }\n      }\n\n      case 'set_mark':\n      case 'set_node': {\n        const { properties, newProperties } = op\n        return { ...op, properties: newProperties, newProperties: properties }\n      }\n\n      case 'set_selection': {\n        const { properties, newProperties } = op\n\n        if (properties == null) {\n          return {\n            ...op,\n            properties: newProperties as Range,\n            newProperties: null,\n          }\n        } else if (newProperties == null) {\n          return {\n            ...op,\n            properties: null,\n            newProperties: properties as Range,\n          }\n        } else {\n          return { ...op, properties: newProperties, newProperties: properties }\n        }\n      }\n\n      case 'split_node': {\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\n      }\n    }\n  },\n}\n\nexport {\n  AddMarkOperation,\n  InsertNodeOperation,\n  InsertTextOperation,\n  MergeNodeOperation,\n  MoveNodeOperation,\n  RemoveMarkOperation,\n  RemoveNodeOperation,\n  RemoveTextOperation,\n  SetMarkOperation,\n  SetNodeOperation,\n  SetSelectionOperation,\n  SplitNodeOperation,\n  Operation,\n}\n","import { produce } from 'immer'\nimport { Operation } from '..'\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\n\nexport type Path = number[]\n\nexport const Path = {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n\n  ancestors(path: Path, options: { reverse?: boolean } = {}): Path[] {\n    const { reverse = false } = options\n    let paths = Path.levels(path, options)\n\n    if (reverse) {\n      paths = paths.slice(1)\n    } else {\n      paths = paths.slice(0, -1)\n    }\n\n    return paths\n  },\n\n  /**\n   * Get the common ancestor path of two paths.\n   */\n\n  common(path: Path, another: Path): Path {\n    const common: Path = []\n\n    for (let i = 0; i < path.length && i < another.length; i++) {\n      const av = path[i]\n      const bv = another[i]\n\n      if (av !== bv) {\n        break\n      }\n\n      common.push(av)\n    }\n\n    return common\n  },\n\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n\n  compare(path: Path, another: Path): -1 | 0 | 1 {\n    const min = Math.min(path.length, another.length)\n\n    for (let i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1\n      if (path[i] > another[i]) return 1\n    }\n\n    return 0\n  },\n\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n\n  endsAfter(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av > bv\n  },\n\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n\n  endsAt(path: Path, another: Path): boolean {\n    const i = path.length\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    return Path.equals(as, bs)\n  },\n\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n\n  endsBefore(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av < bv\n  },\n\n  /**\n   * Check if a path is exactly equal to another.\n   */\n\n  equals(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length && path.every((n, i) => n === another[i])\n    )\n  },\n\n  /**\n   * Check if a path is after another.\n   */\n\n  isAfter(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === 1\n  },\n\n  /**\n   * Check if a path is an ancestor of another.\n   */\n\n  isAncestor(path: Path, another: Path): boolean {\n    return path.length < another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is before another.\n   */\n\n  isBefore(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === -1\n  },\n\n  /**\n   * Check if a path is a child of another.\n   */\n\n  isChild(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length + 1 && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n\n  isCommon(path: Path, another: Path): boolean {\n    return path.length <= another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is a descendant of another.\n   */\n\n  isDescendant(path: Path, another: Path): boolean {\n    return path.length > another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is the parent of another.\n   */\n\n  isParent(path: Path, another: Path): boolean {\n    return (\n      path.length + 1 === another.length && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n\n  isPath(value: any): value is Path {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || typeof value[0] === 'number')\n    )\n  },\n\n  /**\n   * Check if a path is a sibling of another.\n   */\n\n  isSibling(path: Path, another: Path): boolean {\n    if (path.length !== another.length) {\n      return false\n    }\n\n    const as = path.slice(0, -1)\n    const bs = another.slice(0, -1)\n    const al = path[path.length - 1]\n    const bl = another[another.length - 1]\n    return al !== bl && Path.equals(as, bs)\n  },\n\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n\n  levels(\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Path[] {\n    const { reverse = false } = options\n    const list: Path[] = []\n\n    for (let i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i))\n    }\n\n    if (reverse) {\n      list.reverse()\n    }\n\n    return list\n  },\n\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n\n  next(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n    return path.slice(0, -1).concat(last + 1)\n  },\n\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n\n  parent(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\n    }\n\n    return path.slice(0, -1)\n  },\n\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n\n  previous(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n\n    if (last <= 0) {\n      throw new Error(\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\n      )\n    }\n\n    return path.slice(0, -1).concat(last - 1)\n  },\n\n  /**\n   * Get a path relative to an ancestor.\n   */\n\n  relative(path: Path, ancestor: Path): Path {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\n      )\n    }\n\n    return path.slice(ancestor.length)\n  },\n\n  /**\n   * Transform a path by an operation.\n   */\n\n  transform(\n    path: Path,\n    operation: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Path | null {\n    return produce(path, p => {\n      const { affinity = 'forward' } = options\n\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\n      if (path.length === 0) {\n        return\n      }\n\n      switch (operation.type) {\n        case 'insert_node': {\n          const { path: op } = operation\n\n          if (\n            Path.equals(op, p) ||\n            Path.endsBefore(op, p) ||\n            Path.isAncestor(op, p)\n          ) {\n            p[op.length - 1] += 1\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          const { path: op } = operation\n\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n            return null\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          } else if (Path.isAncestor(op, p)) {\n            p[op.length - 1] -= 1\n            p[op.length] += position\n          }\n\n          break\n        }\n\n        case 'split_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1\n            } else if (affinity === 'backward') {\n              // Nothing, because it still refers to the right path.\n            } else {\n              return null\n            }\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] += 1\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\n            p[op.length - 1] += 1\n            p[op.length] -= position\n          }\n\n          break\n        }\n\n        case 'move_node': {\n          const { path: op, newPath: onp } = operation\n\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(op, onp)) {\n            return\n          }\n\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n            const copy = onp.slice()\n\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\n              const i = Math.min(onp.length, op.length) - 1\n              copy[i] -= 1\n            }\n\n            return copy.concat(p.slice(op.length))\n          } else if (\n            Path.endsBefore(onp, p) ||\n            Path.equals(onp, p) ||\n            Path.isAncestor(onp, p)\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            }\n\n            p[onp.length - 1] += 1\n          } else if (Path.endsBefore(op, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1\n            }\n\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n","import { Operation, Path } from '..'\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\n\nexport interface PathRef {\n  current: Path | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Path | null\n}\n\nexport const PathRef = {\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n\n  transform(ref: PathRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Path.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { produce } from 'immer'\nimport { Operation, Path } from '..'\n\n/**\n * `Point` objects refer to a specific location in a text node in a Slate\n * document. Its path refers to the location of the node in the tree, and its\n * offset refers to the distance into the node's string of text. Points can\n * only refer to `Text` nodes.\n */\n\nexport interface Point {\n  path: Path\n  offset: number\n  [key: string]: any\n}\n\nexport const Point = {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n\n  compare(point: Point, another: Point): -1 | 0 | 1 {\n    const result = Path.compare(point.path, another.path)\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1\n      if (point.offset > another.offset) return 1\n      return 0\n    }\n\n    return result\n  },\n\n  /**\n   * Check if a point is after another.\n   */\n\n  isAfter(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === 1\n  },\n\n  /**\n   * Check if a point is before another.\n   */\n\n  isBefore(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === -1\n  },\n\n  /**\n   * Check if a point is exactly equal to another.\n   */\n\n  equals(point: Point, another: Point): boolean {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return (\n      point.offset === another.offset && Path.equals(point.path, another.path)\n    )\n  },\n\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n\n  isPoint(value: any): value is Point {\n    return (\n      isPlainObject(value) &&\n      typeof value.offset === 'number' &&\n      Path.isPath(value.path)\n    )\n  },\n\n  /**\n   * Transform a point by an operation.\n   */\n\n  transform(\n    point: Point,\n    op: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Point | null {\n    return produce(point, p => {\n      const { affinity = 'forward' } = options\n      const { path, offset } = p\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node': {\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'insert_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset += op.text.length\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          if (Path.equals(op.path, path)) {\n            p.offset += op.position\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'remove_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset -= Math.min(offset - op.offset, op.text.length)\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'split_node': {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset && affinity == null) {\n              return null\n            } else if (\n              op.position < offset ||\n              (op.position === offset && affinity === 'forward')\n            ) {\n              p.offset -= op.position\n\n              p.path = Path.transform(path, op, {\n                ...options,\n                affinity: 'forward',\n              })!\n            }\n          } else {\n            p.path = Path.transform(path, op, options)!\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport type PointEntry = [Point, 'anchor' | 'focus']\n","import { Operation, Point } from '..'\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date point value.\n */\n\nexport interface PointRef {\n  current: Point | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Point | null\n}\n\nexport const PointRef = {\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n\n  transform(ref: PointRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const point = Point.transform(current, op, { affinity })\n    ref.current = point\n\n    if (point == null) {\n      ref.unref()\n    }\n  },\n}\n","import { produce } from 'immer'\nimport isPlainObject from 'is-plain-object'\nimport { Operation, Path, Point, PointEntry } from '..'\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\n\nexport interface Range {\n  anchor: Point\n  focus: Point\n  [key: string]: any\n}\n\nexport const Range = {\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n\n  edges(\n    range: Range,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): [Point, Point] {\n    const { reverse = false } = options\n    const { anchor, focus } = range\n    return Range.isBackward(range) === reverse\n      ? [anchor, focus]\n      : [focus, anchor]\n  },\n\n  /**\n   * Get the end point of a range.\n   */\n\n  end(range: Range): Point {\n    const [, end] = Range.edges(range)\n    return end\n  },\n\n  /**\n   * Check if a range is exactly equal to another.\n   */\n\n  equals(range: Range, another: Range): boolean {\n    return (\n      Point.equals(range.anchor, another.anchor) &&\n      Point.equals(range.focus, another.focus)\n    )\n  },\n\n  /**\n   * Check if a range exists in a list or map of ranges.\n   */\n\n  exists(range: Range, target: Range[] | Record<string, Range>): boolean {\n    if (Range.isRangeList(target)) {\n      return !!target.find(r => Range.equals(r, range))\n    }\n\n    if (Range.isRangeMap(target)) {\n      for (const key in target) {\n        if (Range.equals(range, target[key])) {\n          return true\n        }\n      }\n    }\n\n    return false\n  },\n\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n\n  includes(range: Range, target: Path | Point | Range): boolean {\n    if (Range.isRange(target)) {\n      if (\n        Range.includes(range, target.anchor) ||\n        Range.includes(range, target.focus)\n      ) {\n        return true\n      }\n\n      const [rs, re] = Range.edges(range)\n      const [ts, te] = Range.edges(target)\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\n    }\n\n    const [start, end] = Range.edges(range)\n    let isAfterStart = false\n    let isBeforeEnd = false\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0\n      isBeforeEnd = Point.compare(target, end) <= 0\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0\n      isBeforeEnd = Path.compare(target, end.path) <= 0\n    }\n\n    return isAfterStart && isBeforeEnd\n  },\n\n  /**\n   * Get the intersection of a range with another.\n   */\n\n  intersection(range: Range, another: Range): Range | null {\n    const { anchor, focus, ...rest } = range\n    const [s1, e1] = Range.edges(range)\n    const [s2, e2] = Range.edges(another)\n    const start = Point.isBefore(s1, s2) ? s2 : s1\n    const end = Point.isBefore(e1, e2) ? e1 : e2\n\n    if (Point.isBefore(end, start)) {\n      return null\n    } else {\n      return { anchor: start, focus: end, ...rest }\n    }\n  },\n\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n\n  isBackward(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.isAfter(anchor, focus)\n  },\n\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n\n  isCollapsed(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.equals(anchor, focus)\n  },\n\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n\n  isExpanded(range: Range): boolean {\n    return !Range.isCollapsed(range)\n  },\n\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n\n  isForward(range: Range): boolean {\n    return !Range.isBackward(range)\n  },\n\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n\n  isRange(value: any): value is Range {\n    return (\n      isPlainObject(value) &&\n      Point.isPoint(value.anchor) &&\n      Point.isPoint(value.focus)\n    )\n  },\n\n  /**\n   * Check if a value is an array of `Range` objects.\n   */\n\n  isRangeList(value: any): value is Range[] {\n    return (\n      Array.isArray(value) && (value.length === 0 || Range.isRange(value[0]))\n    )\n  },\n\n  /**\n   * Check if a value is a map of `Range` objects.\n   */\n\n  isRangeMap(value: any): value is Record<string, Range> {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    for (const key in value) {\n      return Range.isRange(value[key])\n    }\n\n    return true\n  },\n\n  /**\n   * Iterate through all of the point entries in a range.\n   */\n\n  *points(range: Range): Iterable<PointEntry> {\n    yield [range.anchor, 'anchor']\n    yield [range.focus, 'focus']\n  },\n\n  /**\n   * Get the start point of a range.\n   */\n\n  start(range: Range): Point {\n    const [start] = Range.edges(range)\n    return start\n  },\n\n  /**\n   * Transform a range by an operation.\n   */\n\n  transform(\n    range: Range,\n    op: Operation,\n    options: { affinity: 'forward' | 'backward' | 'outward' | 'inward' | null }\n  ): Range | null {\n    const { affinity = 'inward' } = options\n    let affinityAnchor: 'forward' | 'backward' | null\n    let affinityFocus: 'forward' | 'backward' | null\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      } else {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      } else {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      }\n    } else {\n      affinityAnchor = affinity\n      affinityFocus = affinity\n    }\n\n    return produce(range, r => {\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\n\n      if (!anchor || !focus) {\n        return null\n      }\n\n      r.anchor = anchor\n      r.focus = focus\n    })\n  },\n}\n","import { Operation, Range } from '..'\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date range value.\n */\n\nexport interface RangeRef {\n  current: Range | null\n  affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n  unref(): Range | null\n}\n\nexport const RangeRef = {\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n\n  transform(ref: RangeRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Range.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { Mark, Path } from '..'\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting marks. They are always leaf nodes in\n * the document tree as they cannot contain any children.\n */\n\nexport interface Text {\n  text: string\n  marks: Mark[]\n  [key: string]: any\n}\n\nexport const Text = {\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n\n  isText(value: any): value is Text {\n    return (\n      isPlainObject(value) &&\n      typeof value.text === 'string' &&\n      Array.isArray(value.marks)\n    )\n  },\n\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n\n  isTextList(value: any): value is Text[] {\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]))\n  },\n\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal. However, if `marks` are passed it\n   * will ensure that the set of marks is exactly equal.\n   */\n\n  matches(text: Text, props: Partial<Text>): boolean {\n    for (const key in props) {\n      if (key === 'text') {\n        continue\n      }\n\n      if (key === 'marks' && props.marks != null) {\n        const existing = text.marks\n        const { marks } = props\n\n        // PERF: If the lengths aren't the same, we know it's not a match.\n        if (existing.length !== marks.length) {\n          return false\n        }\n\n        for (const m of existing) {\n          if (!Mark.exists(m, marks)) {\n            return false\n          }\n        }\n\n        for (const m of marks) {\n          if (!Mark.exists(m, existing)) {\n            return false\n          }\n        }\n\n        continue\n      }\n\n      if (text[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `TextEntry` objects refer to an `Text` and the `Path` where it can be\n * found inside a root node.\n */\n\nexport type TextEntry = [Text, Path]\n","function isElement(el) {\n  return el != null && typeof el === 'object' && el.nodeType === 1;\n}\n\nfunction canOverflow(overflow, skipOverflowHiddenElements) {\n  if (skipOverflowHiddenElements && overflow === 'hidden') {\n    return false;\n  }\n\n  return overflow !== 'visible' && overflow !== 'clip';\n}\n\nfunction isScrollable(el, skipOverflowHiddenElements) {\n  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {\n    var style = getComputedStyle(el, null);\n    return canOverflow(style.overflowY, skipOverflowHiddenElements) || canOverflow(style.overflowX, skipOverflowHiddenElements);\n  }\n\n  return false;\n}\n\nfunction alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {\n  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {\n    return 0;\n  }\n\n  if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {\n    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;\n  }\n\n  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {\n    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;\n  }\n\n  return 0;\n}\n\nexport default (function (target, options) {\n  var scrollMode = options.scrollMode,\n      block = options.block,\n      inline = options.inline,\n      boundary = options.boundary,\n      skipOverflowHiddenElements = options.skipOverflowHiddenElements;\n  var checkBoundary = typeof boundary === 'function' ? boundary : function (node) {\n    return node !== boundary;\n  };\n\n  if (!isElement(target)) {\n    throw new TypeError('Invalid target');\n  }\n\n  var scrollingElement = document.scrollingElement || document.documentElement;\n  var frames = [];\n  var cursor = target;\n\n  while (isElement(cursor) && checkBoundary(cursor)) {\n    cursor = cursor.parentNode;\n\n    if (cursor === scrollingElement) {\n      frames.push(cursor);\n      break;\n    }\n\n    if (cursor === document.body && isScrollable(cursor) && !isScrollable(document.documentElement)) {\n      continue;\n    }\n\n    if (isScrollable(cursor, skipOverflowHiddenElements)) {\n      frames.push(cursor);\n    }\n  }\n\n  var viewportWidth = window.visualViewport ? visualViewport.width : innerWidth;\n  var viewportHeight = window.visualViewport ? visualViewport.height : innerHeight;\n  var viewportX = window.scrollX || pageXOffset;\n  var viewportY = window.scrollY || pageYOffset;\n\n  var _target$getBoundingCl = target.getBoundingClientRect(),\n      targetHeight = _target$getBoundingCl.height,\n      targetWidth = _target$getBoundingCl.width,\n      targetTop = _target$getBoundingCl.top,\n      targetRight = _target$getBoundingCl.right,\n      targetBottom = _target$getBoundingCl.bottom,\n      targetLeft = _target$getBoundingCl.left;\n\n  var targetBlock = block === 'start' || block === 'nearest' ? targetTop : block === 'end' ? targetBottom : targetTop + targetHeight / 2;\n  var targetInline = inline === 'center' ? targetLeft + targetWidth / 2 : inline === 'end' ? targetRight : targetLeft;\n  var computations = [];\n\n  for (var index = 0; index < frames.length; index++) {\n    var frame = frames[index];\n\n    var _frame$getBoundingCli = frame.getBoundingClientRect(),\n        _height = _frame$getBoundingCli.height,\n        _width = _frame$getBoundingCli.width,\n        _top = _frame$getBoundingCli.top,\n        right = _frame$getBoundingCli.right,\n        bottom = _frame$getBoundingCli.bottom,\n        _left = _frame$getBoundingCli.left;\n\n    if (scrollMode === 'if-needed' && targetTop >= 0 && targetLeft >= 0 && targetBottom <= viewportHeight && targetRight <= viewportWidth && targetTop >= _top && targetBottom <= bottom && targetLeft >= _left && targetRight <= right) {\n      return computations;\n    }\n\n    var frameStyle = getComputedStyle(frame);\n    var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);\n    var borderTop = parseInt(frameStyle.borderTopWidth, 10);\n    var borderRight = parseInt(frameStyle.borderRightWidth, 10);\n    var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);\n    var blockScroll = 0;\n    var inlineScroll = 0;\n    var scrollbarWidth = 'offsetWidth' in frame ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight : 0;\n    var scrollbarHeight = 'offsetHeight' in frame ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom : 0;\n\n    if (scrollingElement === frame) {\n      if (block === 'start') {\n        blockScroll = targetBlock;\n      } else if (block === 'end') {\n        blockScroll = targetBlock - viewportHeight;\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);\n      } else {\n        blockScroll = targetBlock - viewportHeight / 2;\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline;\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - viewportWidth / 2;\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - viewportWidth;\n      } else {\n        inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);\n      }\n\n      blockScroll = Math.max(0, blockScroll + viewportY);\n      inlineScroll = Math.max(0, inlineScroll + viewportX);\n    } else {\n      if (block === 'start') {\n        blockScroll = targetBlock - _top - borderTop;\n      } else if (block === 'end') {\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(_top, bottom, _height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);\n      } else {\n        blockScroll = targetBlock - (_top + _height / 2) + scrollbarHeight / 2;\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline - _left - borderLeft;\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - (_left + _width / 2) + scrollbarWidth / 2;\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth;\n      } else {\n        inlineScroll = alignNearest(_left, right, _width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);\n      }\n\n      var scrollLeft = frame.scrollLeft,\n          scrollTop = frame.scrollTop;\n      blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - _height + scrollbarHeight));\n      inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - _width + scrollbarWidth));\n      targetBlock += scrollTop - blockScroll;\n      targetInline += scrollLeft - inlineScroll;\n    }\n\n    computations.push({\n      el: frame,\n      top: blockScroll,\n      left: inlineScroll\n    });\n  }\n\n  return computations;\n});","import compute from 'compute-scroll-into-view';\n\nfunction isOptionsObject(options) {\n  return options === Object(options) && Object.keys(options).length !== 0;\n}\n\nfunction defaultBehavior(actions, behavior) {\n  if (behavior === void 0) {\n    behavior = 'auto';\n  }\n\n  var canSmoothScroll = 'scrollBehavior' in document.body.style;\n  actions.forEach(function (_ref) {\n    var el = _ref.el,\n        top = _ref.top,\n        left = _ref.left;\n\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({\n        top: top,\n        left: left,\n        behavior: behavior\n      });\n    } else {\n      el.scrollTop = top;\n      el.scrollLeft = left;\n    }\n  });\n}\n\nfunction getOptions(options) {\n  if (options === false) {\n    return {\n      block: 'end',\n      inline: 'nearest'\n    };\n  }\n\n  if (isOptionsObject(options)) {\n    return options;\n  }\n\n  return {\n    block: 'start',\n    inline: 'nearest'\n  };\n}\n\nfunction scrollIntoView(target, options) {\n  var targetIsDetached = !target.ownerDocument.documentElement.contains(target);\n\n  if (isOptionsObject(options) && typeof options.behavior === 'function') {\n    return options.behavior(targetIsDetached ? [] : compute(target, options));\n  }\n\n  if (targetIsDetached) {\n    return;\n  }\n\n  var computeOptions = getOptions(options);\n  return defaultBehavior(compute(target, computeOptions), computeOptions.behavior);\n}\n\nexport default scrollIntoView;","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nimport isObject from 'isobject';\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport default function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nexport default function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","import React from 'react'\nimport { Editor, Text, Path, Element, Node } from 'slate'\n\nimport { ReactEditor, useEditor } from '..'\nimport { Leaf } from '../utils/leaf'\n\n/**\n * Leaf content strings.\n */\n\nconst String = (props: {\n  isLast: boolean\n  leaf: Leaf\n  parent: Element\n  text: Text\n}) => {\n  const { isLast, leaf, parent, text } = props\n  const editor = useEditor()\n  const path = ReactEditor.findPath(editor, text)\n  const parentPath = Path.parent(path)\n\n  // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n  if (editor.isVoid(parent)) {\n    return <ZeroWidthString length={Node.text(parent).length} />\n  }\n\n  // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n  if (\n    leaf.text === '' &&\n    parent.children[parent.children.length - 1] === text &&\n    !editor.isInline(parent) &&\n    Editor.text(editor, parentPath) === ''\n  ) {\n    return <ZeroWidthString isLineBreak />\n  }\n\n  // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n  if (leaf.text === '') {\n    return <ZeroWidthString />\n  }\n\n  // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return <TextString isTrailing text={leaf.text} />\n  }\n\n  return <TextString text={leaf.text} />\n}\n\n/**\n * Leaf strings with text in them.\n */\n\nconst TextString = (props: { text: string; isTrailing?: boolean }) => {\n  const { text, isTrailing = false } = props\n  return (\n    <span data-slate-string>\n      {text}\n      {isTrailing ? '\\n' : null}\n    </span>\n  )\n}\n\n/**\n * Leaf strings without text, render as zero-width strings.\n */\n\nconst ZeroWidthString = (props: { length?: number; isLineBreak?: boolean }) => {\n  const { length = 0, isLineBreak = false } = props\n  return (\n    <span\n      data-slate-zero-width={isLineBreak ? 'n' : 'z'}\n      data-slate-length={length}\n    >\n      {'\\uFEFF'}\n      {isLineBreak ? <br /> : null}\n    </span>\n  )\n}\n\nexport default String\n","import isPlainObject from 'is-plain-object'\nimport { Range, Mark } from 'slate'\n\n/**\n * The `Leaf` interface represents the individual leaves inside a text node,\n * once decorations have been applied.\n */\n\ninterface Leaf {\n  decorations: Range[]\n  marks: Mark[]\n  text: string\n}\n\nnamespace Leaf {\n  /**\n   * Check if two leaves are equal.\n   */\n\n  export const equals = (leaf: Leaf, another: Leaf): boolean => {\n    return (\n      leaf.text === another.text &&\n      leaf.decorations.length === another.decorations.length &&\n      leaf.marks.length === another.marks.length &&\n      leaf.marks.every(m => Mark.exists(m, another.marks)) &&\n      another.marks.every(m => Mark.exists(m, leaf.marks)) &&\n      isRangeListEqual(leaf.decorations, another.decorations)\n    )\n  }\n\n  /**\n   * Check if a value is a `Leaf` object.\n   */\n\n  export const isLeaf = (value: any): value is Leaf => {\n    return (\n      isPlainObject(value) &&\n      typeof value.text === 'string' &&\n      Mark.isMarkSet(value.marks) &&\n      Range.isRangeList(value.decorations)\n    )\n  }\n\n  /**\n   * Split a leaf into two at an offset.\n   */\n\n  export const split = (leaf: Leaf, offset: number): [Leaf, Leaf] => {\n    return [\n      {\n        text: leaf.text.slice(0, offset),\n        marks: leaf.marks,\n        decorations: [...leaf.decorations],\n      },\n      {\n        text: leaf.text.slice(offset),\n        marks: leaf.marks,\n        decorations: [...leaf.decorations],\n      },\n    ]\n  }\n}\n\n/**\n * Check if a list of ranges is equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\n\nconst isRangeListEqual = (list: Range[], another: Range[]): boolean => {\n  if (list.length !== another.length) {\n    return false\n  }\n\n  for (let i = 0; i < list.length; i++) {\n    const range = list[i]\n    const other = another[i]\n\n    if (!Range.equals(range, other)) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Check if a map of ranges is equal to another.\n */\n\nconst isRangeMapEqual = (\n  map: Record<string, Range>,\n  another: Record<string, Range>\n): boolean => {\n  if (Object.keys(map).length !== Object.keys(another).length) {\n    return false\n  }\n\n  for (const key in map) {\n    const range = map[key]\n    const other = another[key]\n\n    if (!Range.equals(range, other)) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport { Leaf, isRangeListEqual, isRangeMapEqual }\n","import { Node, Ancestor, Editor } from 'slate'\n\nimport { Key } from './key'\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\n\nexport const NODE_TO_INDEX: WeakMap<Node, number> = new WeakMap()\nexport const NODE_TO_PARENT: WeakMap<Node, Ancestor> = new WeakMap()\n\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\n\nexport const EDITOR_TO_ELEMENT: WeakMap<Editor, HTMLElement> = new WeakMap()\nexport const NODE_TO_ELEMENT: WeakMap<Node, HTMLElement> = new WeakMap()\nexport const ELEMENT_TO_NODE: WeakMap<HTMLElement, Node> = new WeakMap()\nexport const NODE_TO_KEY: WeakMap<Node, Key> = new WeakMap()\nexport const KEY_TO_ELEMENT: WeakMap<Key, HTMLElement> = new WeakMap()\n\n/**\n * Weak maps for storing editor-related state.\n */\n\nexport const IS_READ_ONLY: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_FOCUSED: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_DRAGGING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_CLICKING: WeakMap<Editor, boolean> = new WeakMap()\n\n/**\n * Symbols.\n */\n\nexport const PLACEHOLDER_SYMBOL = Symbol('placeholder')\n","import React from 'react'\nimport { Text, Element } from 'slate'\n\nimport String from './string'\nimport { Leaf as SlateLeaf } from '../utils/leaf'\nimport { PLACEHOLDER_SYMBOL } from '../utils/weak-maps'\nimport { RenderDecorationProps, RenderMarkProps } from './editable'\n\n/**\n * Individual leaves in a text node with unique formatting.\n */\n\nconst Leaf = (props: {\n  isLast: boolean\n  leaf: SlateLeaf\n  parent: Element\n  renderDecoration?: (props: RenderDecorationProps) => JSX.Element\n  renderMark?: (props: RenderMarkProps) => JSX.Element\n  text: Text\n}) => {\n  const {\n    leaf,\n    isLast,\n    text,\n    parent,\n    renderDecoration = (props: RenderDecorationProps) => (\n      <DefaultDecoration {...props} />\n    ),\n    renderMark = (props: RenderMarkProps) => <DefaultMark {...props} />,\n  } = props\n\n  let children = (\n    <String isLast={isLast} leaf={leaf} parent={parent} text={text} />\n  )\n\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  for (const mark of leaf.marks) {\n    const ret = renderMark({\n      children,\n      leaf,\n      mark,\n      text,\n      attributes: {\n        'data-slate-mark': true,\n      },\n    })\n\n    if (ret) {\n      children = ret\n    }\n  }\n\n  for (const decoration of leaf.decorations) {\n    const p = {\n      children,\n      decoration,\n      leaf,\n      text,\n      attributes: {\n        'data-slate-decoration': true,\n      },\n    }\n\n    if (PLACEHOLDER_SYMBOL in decoration) {\n      // @ts-ignore\n      children = <PlaceholderDecoration {...p} />\n    } else {\n      // @ts-ignore\n      const ret = renderDecoration(p)\n\n      if (ret) {\n        children = ret\n      }\n    }\n  }\n\n  return <span data-slate-leaf>{children}</span>\n}\n\nconst MemoizedLeaf = React.memo(Leaf, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    next.isLast === prev.isLast &&\n    next.renderDecoration === prev.renderDecoration &&\n    next.renderMark === prev.renderMark &&\n    next.text === prev.text &&\n    SlateLeaf.equals(next.leaf, prev.leaf)\n  )\n})\n\n/**\n * The default custom decoration renderer.\n */\n\nexport const DefaultDecoration = (props: RenderDecorationProps) => {\n  const { attributes, children } = props\n  return <span {...attributes}>{children}</span>\n}\n\n/**\n * The default custom mark renderer.\n */\n\nexport const DefaultMark = (props: RenderMarkProps) => {\n  const { attributes, children } = props\n  return <span {...attributes}>{children}</span>\n}\n\n/**\n * A custom decoration for the default placeholder behavior.\n */\n\nconst PlaceholderDecoration = (props: RenderDecorationProps) => {\n  const { decoration, attributes, children } = props\n  const { placeholder } = decoration\n  return (\n    <span {...attributes}>\n      <span\n        contentEditable={false}\n        style={{\n          pointerEvents: 'none',\n          display: 'inline-block',\n          verticalAlign: 'text-top',\n          width: '0',\n          maxWidth: '100%',\n          whiteSpace: 'nowrap',\n          opacity: '0.333',\n        }}\n      >\n        {placeholder}\n      </span>\n      {children}\n    </span>\n  )\n}\n\nexport default MemoizedLeaf\n","import React, { useLayoutEffect, useRef } from 'react'\nimport { Range, Element, Text as SlateText } from 'slate'\n\nimport Leaf from './leaf'\nimport { Leaf as SlateLeaf } from '../utils/leaf'\nimport { ReactEditor, useEditor } from '..'\nimport { RenderDecorationProps, RenderMarkProps } from './editable'\nimport {\n  KEY_TO_ELEMENT,\n  NODE_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n} from '../utils/weak-maps'\n\n/**\n * Text.\n */\n\nconst Text = (props: {\n  decorations: Range[]\n  isLast: boolean\n  parent: Element\n  renderDecoration?: (props: RenderDecorationProps) => JSX.Element\n  renderMark?: (props: RenderMarkProps) => JSX.Element\n  text: SlateText\n}) => {\n  const {\n    decorations,\n    isLast,\n    parent,\n    renderDecoration,\n    renderMark,\n    text,\n  } = props\n  const editor = useEditor()\n  const ref = useRef<HTMLSpanElement>(null)\n  const leaves = getLeaves(text, decorations)\n  const key = ReactEditor.findKey(editor, text)\n  const children = []\n\n  for (let i = 0; i < leaves.length; i++) {\n    const leaf = leaves[i]\n\n    children.push(\n      <Leaf\n        isLast={isLast && i === leaves.length - 1}\n        key={`${key.id}-${i}`}\n        leaf={leaf}\n        text={text}\n        parent={parent}\n        renderDecoration={renderDecoration}\n        renderMark={renderMark}\n      />\n    )\n  }\n\n  // Update element-related weak maps with the DOM element ref.\n  useLayoutEffect(() => {\n    if (ref.current) {\n      KEY_TO_ELEMENT.set(key, ref.current)\n      NODE_TO_ELEMENT.set(text, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, text)\n    } else {\n      KEY_TO_ELEMENT.delete(key)\n      NODE_TO_ELEMENT.delete(text)\n    }\n  })\n\n  return (\n    <span data-slate-node=\"text\" ref={ref}>\n      {children}\n    </span>\n  )\n}\n\n/**\n * Get the leaves for a text node given decorations.\n */\n\nconst getLeaves = (node: SlateText, decorations: Range[]): SlateLeaf[] => {\n  const { text, marks } = node\n  let leaves: SlateLeaf[] = [{ text, marks, decorations: [] }]\n\n  const compile = (range: Range, key?: string) => {\n    const [start, end] = Range.edges(range)\n    const next = []\n    let o = 0\n\n    for (const leaf of leaves) {\n      const { length } = leaf.text\n      const offset = o\n      o += length\n\n      // If the range encompases the entire leaf, add the range.\n      if (start.offset <= offset && end.offset >= offset + length) {\n        leaf.decorations.push(range)\n        next.push(leaf)\n        continue\n      }\n\n      // If the range starts after the leaf, or ends before it, continue.\n      if (\n        start.offset > offset + length ||\n        end.offset < offset ||\n        (end.offset === offset && offset !== 0)\n      ) {\n        next.push(leaf)\n        continue\n      }\n\n      // Otherwise we need to split the leaf, at the start, end, or both,\n      // and add the range to the middle intersecting section. Do the end\n      // split first since we don't need to update the offset that way.\n      let middle = leaf\n      let before\n      let after\n\n      if (end.offset < offset + length) {\n        ;[middle, after] = SlateLeaf.split(middle, end.offset - offset)\n      }\n\n      if (start.offset > offset) {\n        ;[before, middle] = SlateLeaf.split(middle, start.offset - offset)\n      }\n\n      middle.decorations.push(range)\n\n      if (before) {\n        next.push(before)\n      }\n\n      next.push(middle)\n\n      if (after) {\n        next.push(after)\n      }\n    }\n\n    leaves = next\n  }\n\n  for (const range of decorations) {\n    compile(range)\n  }\n\n  return leaves\n}\n\nconst MemoizedText = React.memo(Text, (prev, next) => {\n  if (\n    next.parent === prev.parent &&\n    next.isLast === prev.isLast &&\n    next.renderDecoration === prev.renderDecoration &&\n    next.renderMark === prev.renderMark &&\n    next.text === prev.text\n  ) {\n    return SlateLeaf.equals(\n      { ...next.text, decorations: next.decorations },\n      { ...prev.text, decorations: prev.decorations }\n    )\n  }\n\n  return false\n})\n\nexport default MemoizedText\n","import { createContext, useContext } from 'react'\n\n/**\n * A React context for sharing the `selected` state of an element.\n */\n\nexport const SelectedContext = createContext(false)\n\n/**\n * Get the current `selected` state of an element.\n */\n\nexport const useSelected = (): boolean => {\n  return useContext(SelectedContext)\n}\n","import React, { useLayoutEffect, useRef } from 'react'\nimport getDirection from 'direction'\nimport { Editor, Node, Range, NodeEntry, Element as SlateElement } from 'slate'\n\nimport Text from './text'\nimport Children from './children'\nimport { ReactEditor, useEditor, useReadOnly } from '..'\nimport { SelectedContext } from '../hooks/use-selected'\nimport {\n  NODE_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_PARENT,\n  NODE_TO_INDEX,\n  KEY_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport {\n  RenderDecorationProps,\n  RenderElementProps,\n  RenderMarkProps,\n} from './editable'\nimport { isRangeListEqual } from '../utils/leaf'\n\n/**\n * Element.\n */\n\nconst Element = (props: {\n  decorate: (entry: NodeEntry) => Range[]\n  decorations: Range[]\n  element: SlateElement\n  renderDecoration?: (props: RenderDecorationProps) => JSX.Element\n  renderElement?: (props: RenderElementProps) => JSX.Element\n  renderMark?: (props: RenderMarkProps) => JSX.Element\n  selection: Range | null\n}) => {\n  const {\n    decorate,\n    decorations,\n    element,\n    renderDecoration,\n    renderElement = (p: RenderElementProps) => <DefaultElement {...p} />,\n    renderMark,\n    selection,\n  } = props\n  const ref = useRef<HTMLElement>(null)\n  const editor = useEditor()\n  const readOnly = useReadOnly()\n  const isInline = editor.isInline(element)\n  const key = ReactEditor.findKey(editor, element)\n\n  let children: JSX.Element | null = (\n    <Children\n      decorate={decorate}\n      decorations={decorations}\n      node={element}\n      renderDecoration={renderDecoration}\n      renderElement={renderElement}\n      renderMark={renderMark}\n      selection={selection}\n    />\n  )\n\n  // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n  const attributes: {\n    'data-slate-node': 'element'\n    'data-slate-void'?: true\n    'data-slate-inline'?: true\n    contentEditable?: false\n    dir?: 'rtl'\n    ref: any\n  } = {\n    'data-slate-node': 'element',\n    ref,\n  }\n\n  if (isInline) {\n    attributes['data-slate-inline'] = true\n  }\n\n  // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    const text = Node.text(element)\n    const dir = getDirection(text)\n\n    if (dir === 'rtl') {\n      attributes.dir = dir\n    }\n  }\n\n  // If it's a void node, wrap the children in extra void-specific elements.\n  if (editor.isVoid(element)) {\n    attributes['data-slate-void'] = true\n\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false\n    }\n\n    const Tag = isInline ? 'span' : 'div'\n    const [[text]] = Node.texts(element)\n\n    children = readOnly ? null : (\n      <Tag\n        data-slate-spacer\n        style={{\n          height: '0',\n          color: 'transparent',\n          outline: 'none',\n          position: 'absolute',\n        }}\n      >\n        <Text decorations={[]} isLast={false} parent={element} text={text} />\n      </Tag>\n    )\n\n    NODE_TO_INDEX.set(text, 0)\n    NODE_TO_PARENT.set(text, element)\n  }\n\n  // Update element-related weak maps with the DOM element ref.\n  useLayoutEffect(() => {\n    if (ref.current) {\n      KEY_TO_ELEMENT.set(key, ref.current)\n      NODE_TO_ELEMENT.set(element, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, element)\n    } else {\n      KEY_TO_ELEMENT.delete(key)\n      NODE_TO_ELEMENT.delete(element)\n    }\n  })\n\n  return (\n    <SelectedContext.Provider value={!!selection}>\n      {renderElement({ attributes, children, element })}\n    </SelectedContext.Provider>\n  )\n}\n\nconst MemoizedElement = React.memo(Element, (prev, next) => {\n  return (\n    prev.decorate === next.decorate &&\n    prev.element === next.element &&\n    prev.renderDecoration === next.renderDecoration &&\n    prev.renderElement === next.renderElement &&\n    prev.renderMark === next.renderMark &&\n    isRangeListEqual(prev.decorations, next.decorations) &&\n    (prev.selection === next.selection ||\n      (!!prev.selection &&\n        !!next.selection &&\n        Range.equals(prev.selection, next.selection)))\n  )\n})\n\n/**\n * The default element renderer.\n */\n\nexport const DefaultElement = (props: RenderElementProps) => {\n  const { attributes, children, element } = props\n  const editor = useEditor()\n  const Tag = editor.isInline(element) ? 'span' : 'div'\n  return (\n    <Tag {...attributes} style={{ position: 'relative' }}>\n      {children}\n    </Tag>\n  )\n}\n\nexport default MemoizedElement\n","import { Editor } from 'slate'\nimport { createContext, useContext } from 'react'\n\n/**\n * A React context for sharing the `Editor` class.\n */\n\nexport const EditorContext = createContext<Editor | null>(null)\n\n/**\n * Get the current `Editor` class that the component lives under.\n */\n\nexport const useEditor = () => {\n  const editor = useContext(EditorContext)\n\n  if (!editor) {\n    throw new Error(\n      `The \\`useEditor\\` hook must be used inside the <Slate> component's context.`\n    )\n  }\n\n  return editor\n}\n","import React from 'react'\nimport { Editor, Range, Element, NodeEntry, Ancestor, Descendant } from 'slate'\n\nimport ElementComponent from './element'\nimport TextComponent from './text'\nimport { ReactEditor } from '..'\nimport { useEditor } from '../hooks/use-editor'\nimport { NODE_TO_INDEX, NODE_TO_PARENT } from '../utils/weak-maps'\nimport {\n  RenderDecorationProps,\n  RenderElementProps,\n  RenderMarkProps,\n} from './editable'\n\n/**\n * Children.\n */\n\nconst Children = (props: {\n  decorate: (entry: NodeEntry) => Range[]\n  decorations: Range[]\n  node: Ancestor\n  renderDecoration?: (props: RenderDecorationProps) => JSX.Element\n  renderElement?: (props: RenderElementProps) => JSX.Element\n  renderMark?: (props: RenderMarkProps) => JSX.Element\n  selection: Range | null\n}) => {\n  const {\n    decorate,\n    decorations,\n    node,\n    renderDecoration,\n    renderElement,\n    renderMark,\n    selection,\n  } = props\n  const editor = useEditor()\n  const path = ReactEditor.findPath(editor, node)\n  const children = []\n  const isLeafBlock =\n    Element.isElement(node) &&\n    !editor.isInline(node) &&\n    Editor.hasInlines(editor, node)\n\n  for (let i = 0; i < node.children.length; i++) {\n    const p = path.concat(i)\n    const n = node.children[i] as Descendant\n    const key = ReactEditor.findKey(editor, n)\n    const range = Editor.range(editor, p)\n    const sel = selection && Range.intersection(range, selection)\n    const ds = decorate([n, p])\n\n    for (const dec of decorations) {\n      const d = Range.intersection(dec, range)\n\n      if (d) {\n        ds.push(d)\n      }\n    }\n\n    if (Element.isElement(n)) {\n      children.push(\n        <ElementComponent\n          decorate={decorate}\n          decorations={ds}\n          element={n}\n          key={key.id}\n          renderDecoration={renderDecoration}\n          renderElement={renderElement}\n          renderMark={renderMark}\n          selection={sel}\n        />\n      )\n    } else {\n      children.push(\n        <TextComponent\n          decorations={ds}\n          key={key.id}\n          isLast={isLeafBlock && i === node.children.length}\n          parent={node}\n          renderDecoration={renderDecoration}\n          renderMark={renderMark}\n          text={n}\n        />\n      )\n    }\n\n    NODE_TO_INDEX.set(n, i)\n    NODE_TO_PARENT.set(n, node)\n  }\n\n  return <React.Fragment>{children}</React.Fragment>\n}\n\nexport default Children\n","export const IS_IOS =\n  typeof navigator !== 'undefined' &&\n  typeof window !== 'undefined' &&\n  /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n  !window.MSStream\n\nexport const IS_APPLE =\n  typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent)\n\nexport const IS_FIREFOX =\n  typeof navigator !== 'undefined' &&\n  /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent)\n\nexport const IS_SAFARI =\n  typeof navigator !== 'undefined' &&\n  /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent)\n","import { isKeyHotkey } from 'is-hotkey'\nimport { IS_APPLE } from './environment'\n\n/**\n * Hotkey mappings for each platform.\n */\n\nconst HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  splitBlock: 'shift?+enter',\n  undo: 'mod+z',\n}\n\nconst APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t',\n}\n\nconst WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z'],\n}\n\n/**\n * Create a platform-aware hotkey checker.\n */\n\nconst create = (key: string) => {\n  const generic = HOTKEYS[key]\n  const apple = APPLE_HOTKEYS[key]\n  const windows = WINDOWS_HOTKEYS[key]\n  const isGeneric = generic && isKeyHotkey(generic)\n  const isApple = apple && isKeyHotkey(apple)\n  const isWindows = windows && isKeyHotkey(windows)\n\n  return (event: KeyboardEvent) => {\n    if (isGeneric && isGeneric(event)) return true\n    if (IS_APPLE && isApple && isApple(event)) return true\n    if (!IS_APPLE && isWindows && isWindows(event)) return true\n    return false\n  }\n}\n\n/**\n * Hotkeys.\n */\n\nexport default {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo'),\n}\n","import { createContext, useContext } from 'react'\n\n/**\n * A React context for sharing the `readOnly` state of the editor.\n */\n\nexport const ReadOnlyContext = createContext(false)\n\n/**\n * Get the current `readOnly` state of the editor.\n */\n\nexport const useReadOnly = (): boolean => {\n  return useContext(ReadOnlyContext)\n}\n","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","/**\n * An auto-incrementing identifier for keys.\n */\n\nlet n = 0\n\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */\n\nexport class Key {\n  id: string\n\n  constructor() {\n    this.id = `${n++}`\n  }\n}\n","/**\n * Types.\n */\n\n// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nimport DOMNode = globalThis.Node\nimport DOMComment = globalThis.Comment\nimport DOMElement = globalThis.Element\nimport DOMText = globalThis.Text\nimport DOMRange = globalThis.Range\nimport DOMSelection = globalThis.Selection\nimport DOMStaticRange = globalThis.StaticRange\nexport {\n  DOMNode,\n  DOMComment,\n  DOMElement,\n  DOMText,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n}\n\nexport type DOMPoint = [Node, number]\n\n/**\n * Check if a DOM node is a comment node.\n */\n\nexport const isDOMComment = (value: any): value is DOMComment => {\n  return isDOMNode(value) && value.nodeType === 8\n}\n\n/**\n * Check if a DOM node is an element node.\n */\n\nexport const isDOMElement = (value: any): value is DOMElement => {\n  return isDOMNode(value) && value.nodeType === 1\n}\n\n/**\n * Check if a value is a DOM node.\n */\n\nexport const isDOMNode = (value: any): value is DOMNode => {\n  return value instanceof Node\n}\n\n/**\n * Check if a DOM node is an element node.\n */\n\nexport const isDOMText = (value: any): value is DOMText => {\n  return isDOMNode(value) && value.nodeType === 3\n}\n\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\n\nexport const normalizeDOMPoint = (domPoint: DOMPoint): DOMPoint => {\n  let [node, offset] = domPoint\n\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    const isLast = offset === node.childNodes.length\n    const direction = isLast ? 'backward' : 'forward'\n    const index = isLast ? offset - 1 : offset\n    node = getEditableChild(node, index, direction)\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, direction)\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return [node, offset]\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChild = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward'\n): DOMNode => {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    isDOMComment(child) ||\n    (isDOMElement(child) && child.childNodes.length === 0) ||\n    (isDOMElement(child) && child.getAttribute('contenteditable') === 'false')\n  ) {\n    if (triedForward && triedBackward) {\n      break\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    i += direction === 'forward' ? 1 : -1\n  }\n\n  return child\n}\n","import { Editor, Element, Node, Path, Point, Range } from 'slate'\n\nimport { Key } from './utils/key'\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  IS_FOCUSED,\n  IS_READ_ONLY,\n  KEY_TO_ELEMENT,\n  NODE_TO_INDEX,\n  NODE_TO_KEY,\n  NODE_TO_PARENT,\n  PLACEHOLDER_SYMBOL,\n} from './utils/weak-maps'\nimport {\n  DOMElement,\n  DOMNode,\n  DOMPoint,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n  isDOMElement,\n  normalizeDOMPoint,\n} from './utils/dom'\n\nexport interface ReactEditor extends Editor {}\n\nexport const ReactEditor = {\n  /**\n   * Find a key for a Slate node.\n   */\n\n  findKey(editor: ReactEditor, node: Node): Key {\n    let key = NODE_TO_KEY.get(node)\n\n    if (!key) {\n      key = new Key()\n      NODE_TO_KEY.set(node, key)\n    }\n\n    return key\n  },\n\n  /**\n   * Find the path of Slate node.\n   */\n\n  findPath(editor: ReactEditor, node: Node): Path {\n    const path: Path = []\n    let child = node\n\n    while (true) {\n      const parent = NODE_TO_PARENT.get(child)\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path\n        } else {\n          break\n        }\n      }\n\n      const i = NODE_TO_INDEX.get(child)\n\n      if (i == null) {\n        break\n      }\n\n      path.unshift(i)\n      child = parent\n    }\n\n    throw new Error(\n      `Unable to find the path for Slate node: ${JSON.stringify(node)}`\n    )\n  },\n\n  /**\n   * Check if the editor is focused.\n   */\n\n  isFocused(editor: ReactEditor): boolean {\n    return !!IS_FOCUSED.get(editor)\n  },\n\n  /**\n   * Check if the editor is in read-only mode.\n   */\n\n  isReadOnly(editor: ReactEditor): boolean {\n    return !!IS_READ_ONLY.get(editor)\n  },\n\n  /**\n   * Blur the editor.\n   */\n\n  blur(editor: ReactEditor): void {\n    const el = ReactEditor.toDOMNode(editor, editor)\n    IS_FOCUSED.set(editor, false)\n\n    if (window.document.activeElement === el) {\n      el.blur()\n    }\n  },\n\n  /**\n   * Focus the editor.\n   */\n\n  focus(editor: ReactEditor): void {\n    const el = ReactEditor.toDOMNode(editor, editor)\n    IS_FOCUSED.set(editor, true)\n\n    if (window.document.activeElement !== el) {\n      el.focus({ preventScroll: true })\n    }\n  },\n\n  /**\n   * Deselect the editor.\n   */\n\n  deselect(editor: ReactEditor): void {\n    const { selection } = editor\n    const domSelection = window.getSelection()\n\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges()\n    }\n\n    if (selection) {\n      Editor.deselect(editor)\n    }\n  },\n\n  /**\n   * Check if a DOM node is within the editor.\n   */\n\n  hasDOMNode(\n    editor: ReactEditor,\n    target: DOMNode,\n    options: { editable?: boolean } = {}\n  ): boolean {\n    const { editable = false } = options\n    const el = ReactEditor.toDOMNode(editor, editor)\n    let element\n\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      element = isDOMElement(target) ? target : target.parentElement\n    } catch (err) {\n      if (\n        !err.message.includes('Permission denied to access property \"nodeType\"')\n      ) {\n        throw err\n      }\n    }\n\n    if (!element) {\n      return false\n    }\n\n    return (\n      element.closest(`[data-slate-editor]`) === el &&\n      (!editable || el.isContentEditable)\n    )\n  },\n\n  /**\n   * Find the native DOM element from a Slate node.\n   */\n\n  toDOMNode(editor: ReactEditor, node: Node): HTMLElement {\n    const domNode = Editor.isEditor(node)\n      ? EDITOR_TO_ELEMENT.get(editor)\n      : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node))\n\n    if (!domNode) {\n      throw new Error(\n        `Cannot resolve a DOM node from Slate node: ${JSON.stringify(node)}`\n      )\n    }\n\n    return domNode\n  },\n\n  /**\n   * Find a native DOM selection point from a Slate point.\n   */\n\n  toDOMPoint(editor: ReactEditor, point: Point): DOMPoint {\n    const [node] = Editor.node(editor, point.path)\n    const el = ReactEditor.toDOMNode(editor, node)\n    let domPoint: DOMPoint | undefined\n\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    const selector = `[data-slate-string], [data-slate-zero-width]`\n    const texts = Array.from(el.querySelectorAll(selector))\n    let start = 0\n\n    for (const text of texts) {\n      const domNode = text.childNodes[0] as HTMLElement\n\n      if (domNode == null || domNode.textContent == null) {\n        continue\n      }\n\n      const { length } = domNode.textContent\n      const attr = text.getAttribute('data-slate-length')\n      const trueLength = attr == null ? length : parseInt(attr, 10)\n      const end = start + trueLength\n\n      if (point.offset <= end) {\n        const offset = Math.min(length, Math.max(0, point.offset - start))\n        domPoint = [domNode, offset]\n        break\n      }\n\n      start = end\n    }\n\n    if (!domPoint) {\n      throw new Error(\n        `Cannot resolve a DOM point from Slate point: ${JSON.stringify(point)}`\n      )\n    }\n\n    return domPoint\n  },\n\n  /**\n   * Find a native DOM range from a Slate `range`.\n   */\n\n  toDOMRange(editor: ReactEditor, range: Range): DOMRange {\n    const { anchor, focus } = range\n    const domAnchor = ReactEditor.toDOMPoint(editor, anchor)\n    const domFocus = Range.isCollapsed(range)\n      ? domAnchor\n      : ReactEditor.toDOMPoint(editor, focus)\n\n    const domRange = window.document.createRange()\n    const start = Range.isBackward(range) ? domFocus : domAnchor\n    const end = Range.isBackward(range) ? domAnchor : domFocus\n    domRange.setStart(start[0], start[1])\n    domRange.setEnd(end[0], end[1])\n    return domRange\n  },\n\n  /**\n   * Find a Slate node from a native DOM `element`.\n   */\n\n  toSlateNode(editor: ReactEditor, domNode: DOMNode): Node {\n    let domEl = isDOMElement(domNode) ? domNode : domNode.parentElement\n\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(`[data-slate-node]`)\n    }\n\n    const node = domEl ? ELEMENT_TO_NODE.get(domEl as HTMLElement) : null\n\n    if (!node) {\n      throw new Error(`Cannot resolve a Slate node from DOM node: ${domEl}`)\n    }\n\n    return node\n  },\n\n  /**\n   * Get the target range from a DOM `event`.\n   */\n\n  findEventRange(editor: ReactEditor, event: any): Range {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent\n    }\n\n    const { clientX: x, clientY: y, target } = event\n\n    if (x == null || y == null) {\n      throw new Error(`Cannot resolve a Slate range from a DOM event: ${event}`)\n    }\n\n    const node = ReactEditor.toSlateNode(editor, event.target)\n    const path = ReactEditor.findPath(editor, node)\n\n    // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n    if (Element.isElement(node) && editor.isVoid(node)) {\n      const rect = target.getBoundingClientRect()\n      const isPrev = editor.isInline(node)\n        ? x - rect.left < rect.left + rect.width - x\n        : y - rect.top < rect.top + rect.height - y\n\n      const edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end',\n      })\n      const point = isPrev\n        ? Editor.before(editor, edge)\n        : Editor.after(editor, edge)\n\n      if (point) {\n        const range = Editor.range(editor, point)\n        return range\n      }\n    }\n\n    // Else resolve a range from the caret position where the drop occured.\n    let domRange\n    const { document } = window\n\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y)\n    } else {\n      const position = document.caretPositionFromPoint(x, y)\n\n      if (position) {\n        domRange = document.createRange()\n        domRange.setStart(position.offsetNode, position.offset)\n        domRange.setEnd(position.offsetNode, position.offset)\n      }\n    }\n\n    if (!domRange) {\n      throw new Error(`Cannot resolve a Slate range from a DOM event: ${event}`)\n    }\n\n    // Resolve a Slate range from the DOM range.\n    const range = ReactEditor.toSlateRange(editor, domRange)\n    return range\n  },\n\n  /**\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\n   */\n\n  toSlatePoint(editor: ReactEditor, domPoint: DOMPoint): Point {\n    const [nearestNode, nearestOffset] = normalizeDOMPoint(domPoint)\n    const parentNode = nearestNode.parentNode as DOMElement\n    let textNode: DOMElement | null = null\n    let offset = 0\n\n    if (parentNode) {\n      const voidNode = parentNode.closest('[data-slate-void=\"true\"]')\n      let leafNode = parentNode.closest('[data-slate-leaf]')\n      let domNode: DOMElement | null = null\n\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]')!\n        const range = window.document.createRange()\n        range.setStart(textNode, 0)\n        range.setEnd(nearestNode, nearestOffset)\n        const contents = range.cloneContents()\n        const removals = [\n          ...contents.querySelectorAll('[data-slate-zero-width]'),\n          ...contents.querySelectorAll('[contenteditable=false]'),\n        ]\n\n        removals.forEach(el => {\n          el!.parentNode!.removeChild(el)\n        })\n\n        // COMPAT: Edge has a bug where Range.prototype.toString() will\n        // convert \\n into \\r\\n. The bug causes a loop when slate-react\n        // attempts to reposition its cursor to match the native position. Use\n        // textContent.length instead.\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n        offset = contents.textContent!.length\n        domNode = textNode\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent.\n\n        leafNode = voidNode.querySelector('[data-slate-leaf]')!\n        textNode = leafNode.closest('[data-slate-node=\"text\"]')!\n        domNode = leafNode\n        offset = domNode.textContent!.length\n      }\n\n      // COMPAT: If the parent node is a Slate zero-width space, editor is\n      // because the text node should have no characters. However, during IME\n      // composition the ASCII characters will be prepended to the zero-width\n      // space, so subtract 1 from the offset to account for the zero-width\n      // space character.\n      if (\n        domNode &&\n        offset === domNode.textContent!.length &&\n        parentNode.hasAttribute('data-slate-zero-width')\n      ) {\n        offset--\n      }\n    }\n\n    if (!textNode) {\n      throw new Error(\n        `Cannot resolve a Slate point from DOM point: ${domPoint}`\n      )\n    }\n\n    // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    const slateNode = ReactEditor.toSlateNode(editor, textNode!)\n    const path = ReactEditor.findPath(editor, slateNode)\n    return { path, offset }\n  },\n\n  /**\n   * Find a Slate range from a DOM range or selection.\n   */\n\n  toSlateRange(\n    editor: ReactEditor,\n    domRange: DOMRange | DOMStaticRange | DOMSelection\n  ): Range {\n    const el =\n      domRange instanceof Selection\n        ? domRange.anchorNode\n        : domRange.startContainer\n    let anchorNode\n    let anchorOffset\n    let focusNode\n    let focusOffset\n    let isCollapsed\n\n    if (el) {\n      if (domRange instanceof Selection) {\n        anchorNode = domRange.anchorNode\n        anchorOffset = domRange.anchorOffset\n        focusNode = domRange.focusNode\n        focusOffset = domRange.focusOffset\n        isCollapsed = domRange.isCollapsed\n      } else {\n        anchorNode = domRange.startContainer\n        anchorOffset = domRange.startOffset\n        focusNode = domRange.endContainer\n        focusOffset = domRange.endOffset\n        isCollapsed = domRange.collapsed\n      }\n    }\n\n    if (\n      anchorNode == null ||\n      focusNode == null ||\n      anchorOffset == null ||\n      focusOffset == null\n    ) {\n      throw new Error(\n        `Cannot resolve a Slate range from DOM range: ${domRange}`\n      )\n    }\n\n    const anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset])\n    const focus = isCollapsed\n      ? anchor\n      : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset])\n\n    return { anchor, focus }\n  },\n}\n","import { createContext, useContext } from 'react'\n\n/**\n * A React context for sharing the `focused` state of the editor.\n */\n\nexport const FocusedContext = createContext(false)\n\n/**\n * Get the current `focused` state of the editor.\n */\n\nexport const useFocused = (): boolean => {\n  return useContext(FocusedContext)\n}\n","import React, { useState, useMemo } from 'react'\nimport { Editor, Node, Operation } from 'slate'\nimport { createContext, useContext } from 'react'\nimport { ReactEditor } from '../react-editor'\nimport { FocusedContext } from './use-focused'\nimport { EditorContext } from './use-editor'\n\n/**\n * Associate the context change listener with the editor.\n */\n\nexport const EDITOR_TO_CONTEXT_LISTENER = new WeakMap<\n  Editor,\n  (children: Node[], operations: Operation[]) => void\n>()\n\n/**\n * A React context for sharing the `Editor` class, in a way that re-renders the\n * context whenever changes occur.\n */\n\nexport const SlateContext = createContext<[Editor] | null>(null)\n\n/**\n * A wrapper around the provider to handle `onChange` events, because the editor\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\n */\n\nexport const Slate = (props: {\n  editor: Editor\n  children: React.ReactNode\n  defaultValue?: Node[]\n  onChange?: (children: Node[], operations: Operation[]) => void\n}) => {\n  const { editor, children, defaultValue = [], onChange = () => {} } = props\n  const [context, setContext] = useState([editor])\n  const value: [Editor] = useMemo(() => [editor], [context, editor])\n  const listener = useMemo(() => {\n    editor.children = defaultValue\n\n    return (children: Node[], operations: Operation[]) => {\n      onChange(children, operations)\n      setContext([editor])\n    }\n  }, [editor])\n\n  EDITOR_TO_CONTEXT_LISTENER.set(editor, listener)\n\n  return (\n    <SlateContext.Provider value={value}>\n      <EditorContext.Provider value={editor}>\n        <FocusedContext.Provider value={ReactEditor.isFocused(editor)}>\n          {children}\n        </FocusedContext.Provider>\n      </EditorContext.Provider>\n    </SlateContext.Provider>\n  )\n}\n\n/**\n * Get the current `Editor` class that the component lives under.\n */\n\nexport const useSlate = () => {\n  const context = useContext(SlateContext)\n\n  if (!context) {\n    throw new Error(\n      `The \\`useSlate\\` hook must be used inside the <SlateProvider> component's context.`\n    )\n  }\n\n  const [editor] = context\n  return editor\n}\n","import React, { useLayoutEffect, useRef, useMemo, useCallback } from 'react'\nimport { Editor, Element, NodeEntry, Node, Range, Text, Mark } from 'slate'\nimport debounce from 'debounce'\nimport scrollIntoView from 'scroll-into-view-if-needed'\n\nimport Children from './children'\nimport Hotkeys from '../utils/hotkeys'\nimport { IS_FIREFOX, IS_SAFARI } from '../utils/environment'\nimport { ReactEditor } from '..'\nimport { ReadOnlyContext } from '../hooks/use-read-only'\nimport { useSlate } from '../hooks/use-slate'\nimport { Leaf } from '../utils/leaf'\nimport {\n  DOMElement,\n  DOMNode,\n  DOMRange,\n  isDOMElement,\n  isDOMNode,\n  isDOMText,\n  DOMStaticRange,\n} from '../utils/dom'\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  IS_READ_ONLY,\n  NODE_TO_ELEMENT,\n  IS_FOCUSED,\n  PLACEHOLDER_SYMBOL,\n} from '../utils/weak-maps'\n\n/**\n * `RenderDecorationProps` are passed to the `renderDecoration` handler.\n */\n\nexport interface RenderDecorationProps {\n  children: any\n  decoration: Range\n  leaf: Leaf\n  text: Text\n  attributes: {\n    'data-slate-decoration': true\n  }\n}\n\n/**\n * `RenderElementProps` are passed to the `renderElement` handler.\n */\n\nexport interface RenderElementProps {\n  children: any\n  element: Element\n  attributes: {\n    'data-slate-inline'?: true\n    'data-slate-node': 'element'\n    'data-slate-void'?: true\n    dir?: 'rtl'\n    ref: any\n  }\n}\n\n/**\n * `RenderMarkProps` are passed to the `renderMark` handler.\n */\n\nexport interface RenderMarkProps {\n  children: any\n  mark: Mark\n  leaf: Leaf\n  text: Text\n  attributes: {\n    'data-slate-mark': true\n  }\n}\n\n/**\n * Editable.\n */\n\nexport const Editable = (\n  props: {\n    decorate?: (entry: NodeEntry) => Range[]\n    onDOMBeforeInput?: (event: Event) => void\n    placeholder?: string\n    readOnly?: boolean\n    role?: string\n    style?: React.CSSProperties\n    renderDecoration?: (props: RenderDecorationProps) => JSX.Element\n    renderElement?: (props: RenderElementProps) => JSX.Element\n    renderMark?: (props: RenderMarkProps) => JSX.Element\n  } & React.TextareaHTMLAttributes<HTMLDivElement>\n) => {\n  const {\n    decorate = defaultDecorate,\n    placeholder,\n    readOnly = false,\n    renderDecoration,\n    renderElement,\n    renderMark,\n    style = {},\n    onDOMBeforeInput: propsOnDOMBeforeInput,\n    ...attributes\n  } = props\n  const editor = useSlate()\n  const ref = useRef<HTMLDivElement>(null)\n\n  // Update internal state on each render.\n  IS_READ_ONLY.set(editor, readOnly)\n\n  // Keep track of some state for the event handler logic.\n  const state = useMemo(\n    () => ({\n      isComposing: false,\n      isUpdatingSelection: false,\n      latestElement: null as DOMElement | null,\n    }),\n    []\n  )\n\n  // Update element-related weak maps with the DOM element ref.\n  useLayoutEffect(() => {\n    if (ref.current) {\n      EDITOR_TO_ELEMENT.set(editor, ref.current)\n      NODE_TO_ELEMENT.set(editor, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, editor)\n    } else {\n      NODE_TO_ELEMENT.delete(editor)\n    }\n  })\n\n  // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n  useLayoutEffect(() => {\n    window.document.addEventListener('selectionchange', onDOMSelectionChange)\n\n    return () => {\n      window.document.removeEventListener(\n        'selectionchange',\n        onDOMSelectionChange\n      )\n    }\n  }, [])\n\n  // Attach a native DOM event handler for `beforeinput` events, because React's\n  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n  // real `beforeinput` events sadly... (2019/11/04)\n  // https://github.com/facebook/react/issues/11211\n  useLayoutEffect(() => {\n    if (ref.current) {\n      // @ts-ignore The `beforeinput` event isn't recognized.\n      ref.current.addEventListener('beforeinput', onDOMBeforeInput)\n    }\n\n    return () => {\n      if (ref.current) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput)\n      }\n    }\n  }, [])\n\n  // Whenever the editor updates, make sure the DOM selection state is in sync.\n  useLayoutEffect(() => {\n    const { selection } = editor\n    const domSelection = window.getSelection()\n\n    if (state.isComposing || !domSelection || !ReactEditor.isFocused(editor)) {\n      return\n    }\n\n    const hasDomSelection = domSelection.type !== 'None'\n\n    // If the DOM selection is properly unset, we're done.\n    if (!selection && !hasDomSelection) {\n      return\n    }\n\n    const newDomRange = selection && ReactEditor.toDOMRange(editor, selection)\n\n    // If the DOM selection is already correct, we're done.\n    if (\n      hasDomSelection &&\n      newDomRange &&\n      isRangeEqual(domSelection.getRangeAt(0), newDomRange)\n    ) {\n      return\n    }\n\n    // Otherwise the DOM selection is out of sync, so update it.\n    const el = ReactEditor.toDOMNode(editor, editor)\n    state.isUpdatingSelection = true\n    domSelection.removeAllRanges()\n\n    if (newDomRange) {\n      domSelection.addRange(newDomRange!)\n      const leafEl = newDomRange.startContainer.parentElement!\n      scrollIntoView(leafEl, { scrollMode: 'if-needed' })\n    }\n\n    setTimeout(() => {\n      // COMPAT: In Firefox, it's not enough to create a range, you also need\n      // to focus the contenteditable element too. (2016/11/16)\n      if (newDomRange && IS_FIREFOX) {\n        el.focus()\n      }\n\n      state.isUpdatingSelection = false\n    })\n  })\n\n  // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n  const onDOMBeforeInput = useCallback(\n    (\n      event: Event & {\n        data: string | null\n        dataTransfer: DataTransfer | null\n        getTargetRanges(): DOMStaticRange[]\n        inputType: string\n        isComposing: boolean\n      }\n    ) => {\n      if (\n        !readOnly &&\n        hasEditableTarget(editor, event.target) &&\n        !isDOMEventHandled(event, propsOnDOMBeforeInput)\n      ) {\n        const { selection } = editor\n        const { inputType: type } = event\n        const data = event.dataTransfer || event.data || undefined\n\n        // These two types occur while a user is composing text and can't be\n        // cancelled. Let them through and wait for the composition to end.\n        if (\n          type === 'insertCompositionText' ||\n          type === 'deleteCompositionText'\n        ) {\n          return\n        }\n\n        event.preventDefault()\n\n        // COMPAT: For the deleting forward/backward input types we don't want\n        // to change the selection because it is the range that will be deleted,\n        // and those commands determine that for themselves.\n        if (!type.startsWith('delete') || type.startsWith('deleteBy')) {\n          const [targetRange] = event.getTargetRanges()\n\n          if (targetRange) {\n            const range = ReactEditor.toSlateRange(editor, targetRange)\n\n            if (!selection || !Range.equals(selection, range)) {\n              Editor.select(editor, range)\n            }\n          }\n        }\n\n        // COMPAT: If the selection is expanded, even if the command seems like\n        // a delete forward/backward command it should delete the selection.\n        if (\n          selection &&\n          Range.isExpanded(selection) &&\n          type.startsWith('delete')\n        ) {\n          editor.exec({ type: 'delete_fragment' })\n          return\n        }\n\n        switch (type) {\n          case 'deleteByComposition':\n          case 'deleteByCut':\n          case 'deleteByDrag': {\n            editor.exec({ type: 'delete_fragment' })\n            break\n          }\n\n          case 'deleteContent':\n          case 'deleteContentForward': {\n            editor.exec({ type: 'delete_forward', unit: 'character' })\n            break\n          }\n\n          case 'deleteContentBackward': {\n            editor.exec({ type: 'delete_backward', unit: 'character' })\n            break\n          }\n\n          case 'deleteEntireSoftLine': {\n            editor.exec({ type: 'delete_backward', unit: 'line' })\n            editor.exec({ type: 'delete_forward', unit: 'line' })\n            break\n          }\n\n          case 'deleteHardLineBackward': {\n            editor.exec({ type: 'delete_backward', unit: 'block' })\n            break\n          }\n\n          case 'deleteSoftLineBackward': {\n            editor.exec({ type: 'delete_backward', unit: 'line' })\n            break\n          }\n\n          case 'deleteHardLineForward': {\n            editor.exec({ type: 'delete_forward', unit: 'block' })\n            break\n          }\n\n          case 'deleteSoftLineForward': {\n            editor.exec({ type: 'delete_forward', unit: 'line' })\n            break\n          }\n\n          case 'deleteWordBackward': {\n            editor.exec({ type: 'delete_backward', unit: 'word' })\n            break\n          }\n\n          case 'deleteWordForward': {\n            editor.exec({ type: 'delete_forward', unit: 'word' })\n            break\n          }\n\n          case 'insertLineBreak':\n          case 'insertParagraph': {\n            editor.exec({ type: 'insert_break' })\n            break\n          }\n\n          case 'insertFromComposition':\n          case 'insertFromDrop':\n          case 'insertFromPaste':\n          case 'insertFromYank':\n          case 'insertReplacementText':\n          case 'insertText': {\n            if (data instanceof DataTransfer) {\n              editor.exec({ type: 'insert_data', data })\n            } else if (typeof data === 'string') {\n              editor.exec({ type: 'insert_text', text: data })\n            }\n\n            break\n          }\n        }\n      }\n    },\n    []\n  )\n\n  // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n  const onDOMSelectionChange = useCallback(\n    debounce(() => {\n      if (!readOnly && !state.isComposing && !state.isUpdatingSelection) {\n        const { activeElement } = window.document\n        const el = ReactEditor.toDOMNode(editor, editor)\n        const domSelection = window.getSelection()\n        const domRange =\n          domSelection &&\n          domSelection.rangeCount > 0 &&\n          domSelection.getRangeAt(0)\n\n        if (activeElement === el) {\n          state.latestElement = activeElement\n          IS_FOCUSED.set(editor, true)\n        } else {\n          IS_FOCUSED.delete(editor)\n        }\n\n        if (\n          domRange &&\n          hasEditableTarget(editor, domRange.startContainer) &&\n          hasEditableTarget(editor, domRange.endContainer)\n        ) {\n          const range = ReactEditor.toSlateRange(editor, domRange)\n          Editor.select(editor, range)\n        } else {\n          Editor.deselect(editor)\n        }\n      }\n    }, 100),\n    []\n  )\n\n  const decorations = decorate([editor, []])\n\n  if (\n    placeholder &&\n    editor.children.length === 1 &&\n    Array.from(Node.texts(editor)).length === 1 &&\n    Node.text(editor) === ''\n  ) {\n    const start = Editor.start(editor, [])\n    decorations.push({\n      [PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      anchor: start,\n      focus: start,\n    })\n  }\n\n  return (\n    <ReadOnlyContext.Provider value={readOnly}>\n      <div\n        // COMPAT: The Grammarly Chrome extension works by changing the DOM\n        // out from under `contenteditable` elements, which leads to weird\n        // behaviors so we have to disable it like editor. (2017/04/24)\n        data-gramm={false}\n        role={readOnly ? undefined : 'textbox'}\n        {...attributes}\n        // COMPAT: Firefox doesn't support the `beforeinput` event, so we'd\n        // have to use hacks to make these replacement-based features work.\n        spellCheck={IS_FIREFOX ? undefined : attributes.spellCheck}\n        autoCorrect={IS_FIREFOX ? undefined : attributes.autoCorrect}\n        autoCapitalize={IS_FIREFOX ? undefined : attributes.autoCapitalize}\n        data-slate-editor\n        data-slate-node=\"value\"\n        contentEditable={readOnly ? undefined : true}\n        suppressContentEditableWarning\n        ref={ref}\n        style={{\n          // Prevent the default outline styles.\n          outline: 'none',\n          // Preserve adjacent whitespace and new lines.\n          whiteSpace: 'pre-wrap',\n          // Allow words to break if they are too long.\n          wordWrap: 'break-word',\n          // Allow for passed-in styles to override anything.\n          ...style,\n        }}\n        onBeforeInput={useCallback((event: React.SyntheticEvent) => {\n          // COMPAT: Firefox doesn't support the `beforeinput` event, so we\n          // fall back to React's leaky polyfill instead just for it. It\n          // only works for the `insertText` input type.\n          if (IS_FIREFOX && !readOnly) {\n            event.preventDefault()\n            const text = (event as any).data as string\n            editor.exec({ type: 'insert_text', text })\n          }\n        }, [])}\n        onBlur={useCallback(\n          (event: React.FocusEvent<HTMLDivElement>) => {\n            if (\n              readOnly ||\n              state.isUpdatingSelection ||\n              !hasEditableTarget(editor, event.target) ||\n              isEventHandled(event, attributes.onBlur)\n            ) {\n              return\n            }\n\n            // COMPAT: If the current `activeElement` is still the previous\n            // one, this is due to the window being blurred when the tab\n            // itself becomes unfocused, so we want to abort early to allow to\n            // editor to stay focused when the tab becomes focused again.\n            if (state.latestElement === window.document.activeElement) {\n              return\n            }\n\n            const { relatedTarget } = event\n            const el = ReactEditor.toDOMNode(editor, editor)\n\n            // COMPAT: The event should be ignored if the focus is returning\n            // to the editor from an embedded editable element (eg. an <input>\n            // element inside a void node).\n            if (relatedTarget === el) {\n              return\n            }\n\n            // COMPAT: The event should be ignored if the focus is moving from\n            // the editor to inside a void node's spacer element.\n            if (\n              isDOMElement(relatedTarget) &&\n              relatedTarget.hasAttribute('data-slate-spacer')\n            ) {\n              return\n            }\n\n            // COMPAT: The event should be ignored if the focus is moving to a\n            // non- editable section of an element that isn't a void node (eg.\n            // a list item of the check list example).\n            if (\n              relatedTarget != null &&\n              isDOMNode(relatedTarget) &&\n              ReactEditor.hasDOMNode(editor, relatedTarget)\n            ) {\n              const node = ReactEditor.toSlateNode(editor, relatedTarget)\n\n              if (Element.isElement(node) && !editor.isVoid(node)) {\n                return\n              }\n            }\n\n            IS_FOCUSED.delete(editor)\n          },\n          [attributes.onBlur]\n        )}\n        onClick={useCallback(\n          (event: React.MouseEvent<HTMLDivElement>) => {\n            if (\n              !readOnly &&\n              hasTarget(editor, event.target) &&\n              !isEventHandled(event, attributes.onClick) &&\n              isDOMNode(event.target)\n            ) {\n              const node = ReactEditor.toSlateNode(editor, event.target)\n              const path = ReactEditor.findPath(editor, node)\n              const start = Editor.start(editor, path)\n\n              if (Editor.match(editor, start, 'void')) {\n                const range = Editor.range(editor, start)\n                Editor.select(editor, range)\n              }\n            }\n          },\n          [attributes.onClick]\n        )}\n        onCompositionEnd={useCallback(\n          (event: React.CompositionEvent<HTMLDivElement>) => {\n            if (\n              hasEditableTarget(editor, event.target) &&\n              !isEventHandled(event, attributes.onCompositionEnd)\n            ) {\n              state.isComposing = false\n\n              // COMPAT: In Chrome, `beforeinput` events for compositions\n              // aren't correct and never fire the \"insertFromComposition\"\n              // type that we need. So instead, insert whenever a composition\n              // ends since it will already have been committed to the DOM.\n              if (!IS_SAFARI && !IS_FIREFOX && event.data) {\n                editor.exec({ type: 'insert_text', text: event.data })\n              }\n            }\n          },\n          [attributes.onCompositionEnd]\n        )}\n        onCompositionStart={useCallback(\n          (event: React.CompositionEvent<HTMLDivElement>) => {\n            if (\n              hasEditableTarget(editor, event.target) &&\n              !isEventHandled(event, attributes.onCompositionStart)\n            ) {\n              state.isComposing = true\n            }\n          },\n          [attributes.onCompositionStart]\n        )}\n        onCopy={useCallback(\n          (event: React.ClipboardEvent<HTMLDivElement>) => {\n            if (\n              hasEditableTarget(editor, event.target) &&\n              !isEventHandled(event, attributes.onCopy)\n            ) {\n              event.preventDefault()\n              setFragmentData(event.clipboardData, editor)\n            }\n          },\n          [attributes.onCopy]\n        )}\n        onCut={useCallback(\n          (event: React.ClipboardEvent<HTMLDivElement>) => {\n            if (\n              !readOnly &&\n              hasEditableTarget(editor, event.target) &&\n              !isEventHandled(event, attributes.onCut)\n            ) {\n              event.preventDefault()\n              setFragmentData(event.clipboardData, editor)\n              const { selection } = editor\n\n              if (selection && Range.isExpanded(selection)) {\n                editor.exec({ type: 'delete_fragment' })\n              }\n            }\n          },\n          [attributes.onCut]\n        )}\n        onDragOver={useCallback(\n          (event: React.DragEvent<HTMLDivElement>) => {\n            if (\n              hasTarget(editor, event.target) &&\n              !isEventHandled(event, attributes.onDragOver)\n            ) {\n              // Only when the target is void, call `preventDefault` to signal\n              // that drops are allowed. Editable content is droppable by\n              // default, and calling `preventDefault` hides the cursor.\n              const node = ReactEditor.toSlateNode(editor, event.target)\n\n              if (Element.isElement(node) && editor.isVoid(node)) {\n                event.preventDefault()\n              }\n            }\n          },\n          [attributes.onDragOver]\n        )}\n        onDragStart={useCallback(\n          (event: React.DragEvent<HTMLDivElement>) => {\n            if (\n              hasTarget(editor, event.target) &&\n              !isEventHandled(event, attributes.onDragStart)\n            ) {\n              const node = ReactEditor.toSlateNode(editor, event.target)\n              const path = ReactEditor.findPath(editor, node)\n              const voidMatch = Editor.match(editor, path, 'void')\n\n              // If starting a drag on a void node, make sure it is selected\n              // so that it shows up in the selection's fragment.\n              if (voidMatch) {\n                const range = Editor.range(editor, path)\n                Editor.select(editor, range)\n              }\n\n              setFragmentData(event.dataTransfer, editor)\n            }\n          },\n          [attributes.onDragStart]\n        )}\n        onDrop={useCallback(\n          (event: React.DragEvent<HTMLDivElement>) => {\n            if (\n              hasTarget(editor, event.target) &&\n              !readOnly &&\n              !isEventHandled(event, attributes.onDrop)\n            ) {\n              // COMPAT: Firefox doesn't fire `beforeinput` events at all, and\n              // Chromium browsers don't properly fire them for files being\n              // dropped into a `contenteditable`. (2019/11/26)\n              // https://bugs.chromium.org/p/chromium/issues/detail?id=1028668\n              if (\n                IS_FIREFOX ||\n                (!IS_SAFARI && event.dataTransfer.files.length > 0)\n              ) {\n                event.preventDefault()\n                const range = ReactEditor.findEventRange(editor, event)\n                const data = event.dataTransfer\n                Editor.select(editor, range)\n                editor.exec({ type: 'insert_data', data })\n              }\n            }\n          },\n          [attributes.onDrop]\n        )}\n        onFocus={useCallback(\n          (event: React.FocusEvent<HTMLDivElement>) => {\n            if (\n              !readOnly &&\n              !state.isUpdatingSelection &&\n              hasEditableTarget(editor, event.target) &&\n              !isEventHandled(event, attributes.onFocus)\n            ) {\n              const el = ReactEditor.toDOMNode(editor, editor)\n              state.latestElement = window.document.activeElement\n\n              // COMPAT: If the editor has nested editable elements, the focus\n              // can go to them. In Firefox, this must be prevented because it\n              // results in issues with keyboard navigation. (2017/03/30)\n              if (IS_FIREFOX && event.target !== el) {\n                el.focus()\n                return\n              }\n\n              IS_FOCUSED.set(editor, true)\n            }\n          },\n          [attributes.onFocus]\n        )}\n        onKeyDown={useCallback(\n          (event: React.KeyboardEvent<HTMLDivElement>) => {\n            if (\n              !readOnly &&\n              hasEditableTarget(editor, event.target) &&\n              !isEventHandled(event, attributes.onKeyDown)\n            ) {\n              const { nativeEvent } = event\n              const { selection } = editor\n\n              // COMPAT: Since we prevent the default behavior on\n              // `beforeinput` events, the browser doesn't think there's ever\n              // any history stack to undo or redo, so we have to manage these\n              // hotkeys ourselves. (2019/11/06)\n              if (Hotkeys.isRedo(nativeEvent)) {\n                event.preventDefault()\n                editor.exec({ type: 'redo' })\n                return\n              }\n\n              if (Hotkeys.isUndo(nativeEvent)) {\n                event.preventDefault()\n                editor.exec({ type: 'undo' })\n                return\n              }\n\n              // COMPAT: Certain browsers don't handle the selection updates\n              // properly. In Chrome, the selection isn't properly extended.\n              // And in Firefox, the selection isn't properly collapsed.\n              // (2017/10/17)\n              if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n                event.preventDefault()\n                Editor.move(editor, { unit: 'line', reverse: true })\n                return\n              }\n\n              if (Hotkeys.isMoveLineForward(nativeEvent)) {\n                event.preventDefault()\n                Editor.move(editor, { unit: 'line' })\n                return\n              }\n\n              if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n                event.preventDefault()\n                Editor.move(editor, {\n                  unit: 'line',\n                  edge: 'focus',\n                  reverse: true,\n                })\n                return\n              }\n\n              if (Hotkeys.isExtendLineForward(nativeEvent)) {\n                event.preventDefault()\n                Editor.move(editor, { unit: 'line', edge: 'focus' })\n                return\n              }\n\n              // COMPAT: If a void node is selected, or a zero-width text node\n              // adjacent to an inline is selected, we need to handle these\n              // hotkeys manually because browsers won't be able to skip over\n              // the void node with the zero-width space not being an empty\n              // string.\n              if (Hotkeys.isMoveBackward(nativeEvent)) {\n                event.preventDefault()\n\n                if (selection && Range.isCollapsed(selection)) {\n                  Editor.move(editor, { reverse: true })\n                } else {\n                  Editor.collapse(editor, { edge: 'start' })\n                }\n\n                return\n              }\n\n              if (Hotkeys.isMoveForward(nativeEvent)) {\n                event.preventDefault()\n\n                if (selection && Range.isCollapsed(selection)) {\n                  Editor.move(editor)\n                } else {\n                  Editor.collapse(editor, { edge: 'end' })\n                }\n\n                return\n              }\n\n              if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n                event.preventDefault()\n                Editor.move(editor, { unit: 'word', reverse: true })\n                return\n              }\n\n              if (Hotkeys.isMoveWordForward(nativeEvent)) {\n                event.preventDefault()\n                Editor.move(editor, { unit: 'word' })\n                return\n              }\n\n              // COMPAT: Firefox doesn't support the `beforeinput` event, so we\n              // fall back to guessing at the input intention for hotkeys.\n              // COMPAT: In iOS, some of these hotkeys are handled in the\n              if (IS_FIREFOX) {\n                // We don't have a core behavior for these, but they change the\n                // DOM if we don't prevent them, so we have to.\n                if (\n                  Hotkeys.isBold(nativeEvent) ||\n                  Hotkeys.isItalic(nativeEvent) ||\n                  Hotkeys.isTransposeCharacter(nativeEvent)\n                ) {\n                  event.preventDefault()\n                  return\n                }\n\n                if (Hotkeys.isSplitBlock(nativeEvent)) {\n                  event.preventDefault()\n                  editor.exec({ type: 'insert_break' })\n                  return\n                }\n\n                if (Hotkeys.isDeleteBackward(nativeEvent)) {\n                  event.preventDefault()\n\n                  if (selection && Range.isExpanded(selection)) {\n                    editor.exec({ type: 'delete_fragment' })\n                  } else {\n                    editor.exec({ type: 'delete_backward', unit: 'character' })\n                  }\n\n                  return\n                }\n\n                if (Hotkeys.isDeleteForward(nativeEvent)) {\n                  event.preventDefault()\n\n                  if (selection && Range.isExpanded(selection)) {\n                    editor.exec({ type: 'delete_fragment' })\n                  } else {\n                    editor.exec({ type: 'delete_forward', unit: 'character' })\n                  }\n\n                  return\n                }\n\n                if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n                  event.preventDefault()\n\n                  if (selection && Range.isExpanded(selection)) {\n                    editor.exec({ type: 'delete_fragment' })\n                  } else {\n                    editor.exec({ type: 'delete_backward', unit: 'line' })\n                  }\n\n                  return\n                }\n\n                if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n                  event.preventDefault()\n\n                  if (selection && Range.isExpanded(selection)) {\n                    editor.exec({ type: 'delete_fragment' })\n                  } else {\n                    editor.exec({ type: 'delete_forward', unit: 'line' })\n                  }\n\n                  return\n                }\n\n                if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n                  event.preventDefault()\n\n                  if (selection && Range.isExpanded(selection)) {\n                    editor.exec({ type: 'delete_fragment' })\n                  } else {\n                    editor.exec({ type: 'delete_backward', unit: 'word' })\n                  }\n\n                  return\n                }\n\n                if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n                  event.preventDefault()\n\n                  if (selection && Range.isExpanded(selection)) {\n                    editor.exec({ type: 'delete_fragment' })\n                  } else {\n                    editor.exec({ type: 'delete_forward', unit: 'word' })\n                  }\n\n                  return\n                }\n              }\n            }\n          },\n          [attributes.onKeyDown]\n        )}\n        onPaste={useCallback(\n          (event: React.ClipboardEvent<HTMLDivElement>) => {\n            // COMPAT: Firefox doesn't support the `beforeinput` event, so we\n            // fall back to React's `onPaste` here instead.\n            if (\n              IS_FIREFOX &&\n              !readOnly &&\n              hasEditableTarget(editor, event.target) &&\n              !isEventHandled(event, attributes.onPaste)\n            ) {\n              event.preventDefault()\n              editor.exec({\n                type: 'insert_data',\n                data: event.clipboardData,\n              })\n            }\n          },\n          [attributes.onPaste]\n        )}\n      >\n        <Children\n          decorate={decorate}\n          decorations={decorations}\n          node={editor}\n          renderDecoration={renderDecoration}\n          renderElement={renderElement}\n          renderMark={renderMark}\n          selection={editor.selection}\n        />\n      </div>\n    </ReadOnlyContext.Provider>\n  )\n}\n\n/**\n * A default memoized decorate function.\n */\n\nconst defaultDecorate = () => []\n\n/**\n * Check if two DOM range objects are equal.\n */\n\nconst isRangeEqual = (a: DOMRange, b: DOMRange) => {\n  return (\n    (a.startContainer === b.startContainer &&\n      a.startOffset === b.startOffset &&\n      a.endContainer === b.endContainer &&\n      a.endOffset === b.endOffset) ||\n    (a.startContainer === b.endContainer &&\n      a.startOffset === b.endOffset &&\n      a.endContainer === b.startContainer &&\n      a.endOffset === b.startOffset)\n  )\n}\n\n/**\n * Check if the target is in the editor.\n */\n\nconst hasTarget = (\n  editor: ReactEditor,\n  target: EventTarget | null\n): target is DOMNode => {\n  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target)\n}\n\n/**\n * Check if the target is editable and in the editor.\n */\n\nconst hasEditableTarget = (\n  editor: ReactEditor,\n  target: EventTarget | null\n): target is DOMNode => {\n  return (\n    isDOMNode(target) &&\n    ReactEditor.hasDOMNode(editor, target, { editable: true })\n  )\n}\n\n/**\n * Check if an event is overrided by a handler.\n */\n\nconst isEventHandled = <\n  EventType extends React.SyntheticEvent<unknown, unknown>\n>(\n  event: EventType,\n  handler?: (event: EventType) => void\n) => {\n  if (!handler) {\n    return false\n  }\n\n  handler(event)\n  return event.isDefaultPrevented() || event.isPropagationStopped()\n}\n\n/**\n * Check if a DOM event is overrided by a handler.\n */\n\nconst isDOMEventHandled = (event: Event, handler?: (event: Event) => void) => {\n  if (!handler) {\n    return false\n  }\n\n  handler(event)\n  return event.defaultPrevented\n}\n\n/**\n * Set the currently selected fragment to the clipboard.\n */\n\nconst setFragmentData = (dataTransfer: DataTransfer, editor: Editor): void => {\n  const { selection } = editor\n\n  if (!selection) {\n    return\n  }\n\n  const [start, end] = Range.edges(selection)\n  const startVoid = Editor.match(editor, start.path, 'void')\n  const endVoid = Editor.match(editor, end.path, 'void')\n\n  if (Range.isCollapsed(selection) && !startVoid) {\n    return\n  }\n\n  // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n  const domRange = ReactEditor.toDOMRange(editor, selection)\n  let contents = domRange.cloneContents()\n  let attach = contents.childNodes[0] as HTMLElement\n\n  // Make sure attach is non-empty, since empty nodes will not get copied.\n  contents.childNodes.forEach(node => {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node as HTMLElement\n    }\n  })\n\n  // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n  if (endVoid) {\n    const [voidNode] = endVoid\n    const r = domRange.cloneRange()\n    const domNode = ReactEditor.toDOMNode(editor, voidNode)\n    r.setEndAfter(domNode)\n    contents = r.cloneContents()\n  }\n\n  // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n  if (startVoid) {\n    attach = contents.querySelector('[data-slate-spacer]')! as HTMLElement\n  }\n\n  // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n  Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(\n    zw => {\n      const isNewline = zw.getAttribute('data-slate-zero-width') === 'n'\n      zw.textContent = isNewline ? '\\n' : ''\n    }\n  )\n\n  // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n  if (isDOMText(attach)) {\n    const span = document.createElement('span')\n    // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n    span.style.whiteSpace = 'pre'\n    span.appendChild(attach)\n    contents.appendChild(span)\n    attach = span\n  }\n\n  const fragment = Node.fragment(editor, selection)\n  const string = JSON.stringify(fragment)\n  const encoded = window.btoa(encodeURIComponent(string))\n  attach.setAttribute('data-slate-fragment', encoded)\n  dataTransfer.setData('application/x-slate-fragment', encoded)\n\n  // Add the content to a <div> so that we can get its inner HTML.\n  const div = document.createElement('div')\n  div.appendChild(contents)\n  dataTransfer.setData('text/html', div.innerHTML)\n  dataTransfer.setData('text/plain', getPlainText(div))\n}\n\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n */\n\nconst getPlainText = (domNode: DOMNode) => {\n  let text = ''\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue\n  }\n\n  if (isDOMElement(domNode)) {\n    for (const childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode)\n    }\n\n    const display = getComputedStyle(domNode).getPropertyValue('display')\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n'\n    }\n  }\n\n  return text\n}\n","import { Command } from 'slate'\n\n/**\n * The `InsertDataCommand` inserts content from a `DataTransfer` object.\n */\n\nexport interface InsertDataCommand {\n  type: 'insert_data'\n  data: DataTransfer\n}\n\n/**\n * The `ReactCommand` union for all commands that the React plugins defines.\n */\n\nexport type ReactCommand = InsertDataCommand\n\nexport const ReactCommand = {\n  /**\n   * Check if a value is an `InsertDataCommand` object.\n   */\n\n  isInsertDataCommand(value: any): value is InsertDataCommand {\n    return (\n      Command.isCommand(value) &&\n      value.type === 'insert_data' &&\n      value.data instanceof DataTransfer\n    )\n  },\n\n  /**\n   * Check if a value is a `ReactCommand` object.\n   */\n\n  isReactCommand(value: any): value is InsertDataCommand {\n    return ReactCommand.isInsertDataCommand(value)\n  },\n}\n","import { Editor, Node, Path, Operation, Command } from 'slate'\n\nimport { ReactEditor, ReactCommand } from '.'\nimport { Key } from './utils/key'\nimport { NODE_TO_KEY } from './utils/weak-maps'\nimport { EDITOR_TO_CONTEXT_LISTENER } from './hooks/use-slate'\n\n/**\n * `withReact` adds React and DOM specific behaviors to the editor.\n */\n\nexport const withReact = (editor: Editor): Editor => {\n  const { apply, exec, onChange } = editor\n\n  editor.apply = (op: Operation) => {\n    const matches: [Path, Key][] = []\n\n    switch (op.type) {\n      case 'add_mark':\n      case 'insert_text':\n      case 'remove_mark':\n      case 'remove_text':\n      case 'set_mark':\n      case 'set_node': {\n        for (const [node, path] of Editor.levels(editor, { at: op.path })) {\n          const key = ReactEditor.findKey(editor, node)\n          matches.push([path, key])\n        }\n\n        break\n      }\n\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node': {\n        for (const [node, path] of Editor.levels(editor, {\n          at: Path.parent(op.path),\n        })) {\n          const key = ReactEditor.findKey(editor, node)\n          matches.push([path, key])\n        }\n\n        break\n      }\n\n      case 'move_node': {\n        // TODO\n        break\n      }\n    }\n\n    apply(op)\n\n    for (const [path, key] of matches) {\n      const [node] = Editor.node(editor, path)\n      NODE_TO_KEY.set(node, key)\n    }\n  }\n\n  editor.exec = (command: Command) => {\n    if (ReactCommand.isInsertDataCommand(command)) {\n      const { data } = command\n      const fragment = data.getData('application/x-slate-fragment')\n\n      if (fragment) {\n        const decoded = decodeURIComponent(window.atob(fragment))\n        const parsed = JSON.parse(decoded) as Node[]\n        Editor.insertFragment(editor, parsed)\n        return\n      }\n\n      const text = data.getData('text/plain')\n\n      if (text) {\n        const lines = text.split('\\n')\n        let split = false\n\n        for (const line of lines) {\n          if (split) {\n            Editor.splitNodes(editor)\n          }\n\n          Editor.insertText(editor, line)\n          split = true\n        }\n      }\n    } else {\n      exec(command)\n    }\n  }\n\n  editor.onChange = (children: Node[], operations: Operation[]) => {\n    const contextOnChange = EDITOR_TO_CONTEXT_LISTENER.get(editor)\n\n    if (contextOnChange) {\n      contextOnChange(children, operations)\n    }\n\n    onChange(children, operations)\n  }\n\n  return editor\n}\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nimport isObject from 'isobject';\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport default function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nexport default function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","import isPlainObject from 'is-plain-object'\nimport { Operation } from 'slate'\n\n/**\n * `History` objects hold all of the operations that are applied to a value, so\n * they can be undone or redone as necessary.\n */\n\nexport interface History {\n  redos: Operation[][]\n  undos: Operation[][]\n}\n\nexport const History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n\n  isHistory(value: any): value is History {\n    return (\n      isPlainObject(value) &&\n      Array.isArray(value.redos) &&\n      Array.isArray(value.undos) &&\n      (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) &&\n      (value.undos.length === 0 || Operation.isOperationList(value.undos[0]))\n    )\n  },\n}\n","import { Command } from 'slate'\n\nexport interface RedoCommand {\n  type: 'redo'\n}\n\nexport interface UndoCommand {\n  type: 'undo'\n}\n\nexport type HistoryCommand = RedoCommand | UndoCommand\n\nexport const HistoryCommand = {\n  /**\n   * Check if a value is a `HistoryCommand` object.\n   */\n\n  isHistoryCommand(value: any): value is HistoryCommand {\n    return (\n      HistoryCommand.isRedoCommand(value) || HistoryCommand.isUndoCommand(value)\n    )\n  },\n\n  /**\n   * Check if a value is a `RedoCommand` object.\n   */\n\n  isRedoCommand(value: any): value is RedoCommand {\n    return Command.isCommand(value) && value.type === 'redo'\n  },\n\n  /**\n   * Check if a value is an `UndoCommand` object.\n   */\n\n  isUndoCommand(value: any): value is UndoCommand {\n    return Command.isCommand(value) && value.type === 'undo'\n  },\n}\n","import { Editor } from 'slate'\nimport { History } from './history'\n\n/**\n * Weakmaps for attaching state to the editor.\n */\n\nexport const HISTORY = new WeakMap<Editor, History>()\nexport const SAVING = new WeakMap<Editor, boolean | undefined>()\nexport const MERGING = new WeakMap<Editor, boolean | undefined>()\n\n/**\n * `HistoryEditor` contains helpers for history-enabled editors.\n */\n\nexport interface HistoryEditor extends Editor {\n  history: History\n}\n\nexport const HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n\n  isHistoryEditor(value: any): value is HistoryEditor {\n    return Editor.isEditor(value) && History.isHistory(value.history)\n  },\n\n  /**\n   * Get the merge flag's current value.\n   */\n\n  isMerging(editor: Editor): boolean | undefined {\n    return MERGING.get(editor)\n  },\n\n  /**\n   * Get the saving flag's current value.\n   */\n\n  isSaving(editor: Editor): boolean | undefined {\n    return SAVING.get(editor)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n\n  withoutMerging(editor: Editor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, false)\n    fn()\n    MERGING.set(editor, prev)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n\n  withoutSaving(editor: Editor, fn: () => void): void {\n    const prev = HistoryEditor.isSaving(editor)\n    SAVING.set(editor, false)\n    fn()\n    SAVING.set(editor, prev)\n  },\n}\n","import { Editor, Command, Operation, Path } from 'slate'\n\nimport { HistoryCommand } from './history-command'\nimport { HistoryEditor } from './history-editor'\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n */\n\nexport const withHistory = (editor: Editor): HistoryEditor => {\n  const { apply, exec } = editor\n  editor.history = { undos: [], redos: [] }\n\n  editor.exec = (command: Command) => {\n    if (HistoryEditor.isHistoryEditor(editor)) {\n      const { history } = editor\n      const { undos, redos } = history\n\n      if (redos.length > 0 && HistoryCommand.isRedoCommand(command)) {\n        const batch = redos[redos.length - 1]\n\n        HistoryEditor.withoutSaving(editor, () => {\n          Editor.withoutNormalizing(editor, () => {\n            for (const op of batch) {\n              editor.apply(op)\n            }\n          })\n        })\n\n        history.redos.pop()\n        history.undos.push(batch)\n        return\n      }\n\n      if (undos.length > 0 && HistoryCommand.isUndoCommand(command)) {\n        const batch = undos[undos.length - 1]\n\n        HistoryEditor.withoutSaving(editor, () => {\n          Editor.withoutNormalizing(editor, () => {\n            const inverseOps = batch.map(Operation.inverse).reverse()\n\n            for (const op of inverseOps) {\n              // If the final operation is deselecting the editor, skip it. This is\n              if (\n                op === inverseOps[inverseOps.length - 1] &&\n                op.type === 'set_selection' &&\n                op.newProperties == null\n              ) {\n                continue\n              } else {\n                editor.apply(op)\n              }\n            }\n          })\n        })\n\n        history.redos.push(batch)\n        history.undos.pop()\n        return\n      }\n    }\n\n    exec(command)\n  }\n\n  editor.apply = (op: Operation) => {\n    if (HistoryEditor.isHistoryEditor(editor)) {\n      const { operations, history } = editor\n      const { undos } = history\n      const lastBatch = undos[undos.length - 1]\n      const lastOp = lastBatch && lastBatch[lastBatch.length - 1]\n      const overwrite = shouldOverwrite(op, lastOp)\n      let save = HistoryEditor.isSaving(editor)\n      let merge = HistoryEditor.isMerging(editor)\n\n      if (save == null) {\n        save = shouldSave(op, lastOp)\n      }\n\n      if (save) {\n        if (merge == null) {\n          if (lastBatch == null) {\n            merge = false\n          } else if (operations.length !== 0) {\n            merge = true\n          } else {\n            merge = shouldMerge(op, lastOp) || overwrite\n          }\n        }\n\n        if (lastBatch && merge) {\n          if (overwrite) {\n            lastBatch.pop()\n          }\n\n          lastBatch.push(op)\n        } else {\n          const batch = [op]\n          undos.push(batch)\n        }\n\n        while (undos.length > 100) {\n          undos.shift()\n        }\n\n        if (shouldClear(op)) {\n          history.redos = []\n        }\n      }\n    }\n\n    apply(op)\n  }\n\n  return editor as HistoryEditor\n}\n\n/**\n * Check whether to merge an operation into the previous operation.\n */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation needs to be saved to the history.\n */\n\nconst shouldSave = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection' && op.newProperties == null) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Check whether an operation should overwrite the previous one.\n */\n\nconst shouldOverwrite = (\n  op: Operation,\n  prev: Operation | undefined\n): boolean => {\n  if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation should clear the redos stack.\n */\n\nconst shouldClear = (op: Operation): boolean => {\n  if (op.type === 'set_selection') {\n    return false\n  }\n\n  return true\n}\n","/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\nfunction debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\n// Adds compatibility for ES modules\ndebounce.debounce = debounce;\n\nmodule.exports = debounce;\n","'use strict'\n\nmodule.exports = direction\n\nvar RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC'\nvar LTR =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n  '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n  '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'\n\nvar rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']')\nvar ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']')\n\nfunction direction(value) {\n  value = String(value || '')\n\n  if (rtl.test(value)) {\n    return 'rtl'\n  }\n\n  if (ltr.test(value)) {\n    return 'ltr'\n  }\n\n  return 'neutral'\n}\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Constants.\n */\n\nvar IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n\nvar MODIFIERS = {\n  alt: 'altKey',\n  control: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey'\n};\n\nvar ALIASES = {\n  add: '+',\n  break: 'pause',\n  cmd: 'meta',\n  command: 'meta',\n  ctl: 'control',\n  ctrl: 'control',\n  del: 'delete',\n  down: 'arrowdown',\n  esc: 'escape',\n  ins: 'insert',\n  left: 'arrowleft',\n  mod: IS_MAC ? 'meta' : 'control',\n  opt: 'alt',\n  option: 'alt',\n  return: 'enter',\n  right: 'arrowright',\n  space: ' ',\n  spacebar: ' ',\n  up: 'arrowup',\n  win: 'meta',\n  windows: 'meta'\n};\n\nvar CODES = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  ' ': 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  '\\'': 222\n};\n\nfor (var f = 1; f < 20; f++) {\n  CODES['f' + f] = 111 + f;\n}\n\n/**\n * Is hotkey?\n */\n\nfunction isHotkey(hotkey, options, event) {\n  if (options && !('byKey' in options)) {\n    event = options;\n    options = null;\n  }\n\n  if (!Array.isArray(hotkey)) {\n    hotkey = [hotkey];\n  }\n\n  var array = hotkey.map(function (string) {\n    return parseHotkey(string, options);\n  });\n  var check = function check(e) {\n    return array.some(function (object) {\n      return compareHotkey(object, e);\n    });\n  };\n  var ret = event == null ? check : check(event);\n  return ret;\n}\n\nfunction isCodeHotkey(hotkey, event) {\n  return isHotkey(hotkey, event);\n}\n\nfunction isKeyHotkey(hotkey, event) {\n  return isHotkey(hotkey, { byKey: true }, event);\n}\n\n/**\n * Parse.\n */\n\nfunction parseHotkey(hotkey, options) {\n  var byKey = options && options.byKey;\n  var ret = {};\n\n  // Special case to handle the `+` key since we use it as a separator.\n  hotkey = hotkey.replace('++', '+add');\n  var values = hotkey.split('+');\n  var length = values.length;\n\n  // Ensure that all the modifiers are set to false unless the hotkey has them.\n\n  for (var k in MODIFIERS) {\n    ret[MODIFIERS[k]] = false;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n\n      var optional = value.endsWith('?') && value.length > 1;\n\n      if (optional) {\n        value = value.slice(0, -1);\n      }\n\n      var name = toKeyName(value);\n      var modifier = MODIFIERS[name];\n\n      if (length === 1 || !modifier) {\n        if (byKey) {\n          ret.key = name;\n        } else {\n          ret.which = toKeyCode(value);\n        }\n      }\n\n      if (modifier) {\n        ret[modifier] = optional ? null : true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Compare.\n */\n\nfunction compareHotkey(object, event) {\n  for (var key in object) {\n    var expected = object[key];\n    var actual = void 0;\n\n    if (expected == null) {\n      continue;\n    }\n\n    if (key === 'key' && event.key != null) {\n      actual = event.key.toLowerCase();\n    } else if (key === 'which') {\n      actual = expected === 91 && event.which === 93 ? 91 : event.which;\n    } else {\n      actual = event[key];\n    }\n\n    if (actual == null && expected === false) {\n      continue;\n    }\n\n    if (actual !== expected) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Utils.\n */\n\nfunction toKeyCode(name) {\n  name = toKeyName(name);\n  var code = CODES[name] || name.toUpperCase().charCodeAt(0);\n  return code;\n}\n\nfunction toKeyName(name) {\n  name = name.toLowerCase();\n  name = ALIASES[name] || name;\n  return name;\n}\n\n/**\n * Export.\n */\n\nexports.default = isHotkey;\nexports.isHotkey = isHotkey;\nexports.isCodeHotkey = isCodeHotkey;\nexports.isKeyHotkey = isKeyHotkey;\nexports.parseHotkey = parseHotkey;\nexports.compareHotkey = compareHotkey;\nexports.toKeyCode = toKeyCode;\nexports.toKeyName = toKeyName;","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\n\nvar _a;\n/**\r\n * The sentinel value returned by producers to replace the draft with undefined.\r\n */\n\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : (_a = {}, _a[\"immer-nothing\"] = true, _a);\n/**\r\n * To let Immer treat your class instances as plain immutable objects\r\n * (albeit with a custom prototype), you must define either an instance property\r\n * or a static property on each of your custom classes.\r\n *\r\n * Otherwise, your class instance will never be drafted, which means it won't be\r\n * safe to mutate in a produce callback.\r\n */\n\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol[\"for\"] ? Symbol[\"for\"](\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol[\"for\"] ? Symbol[\"for\"](\"immer-state\") : \"__$immer_state\";\n/** Returns true if the given value is an Immer draft */\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n/** Returns true if the given value can be drafted by Immer */\n\nfunction isDraftable(value) {\n  if (!value) { return false; }\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") { return false; }\n  if (Array.isArray(value)) { return true; }\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\n/** Get the underlying object that is represented by the given draft */\n\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n} // We use Maps as `drafts` for Sets, not Objects\n// See proxy.js\n\nfunction assignSet(target, override) {\n  override.forEach(function (value) {\n    // When we add new drafts we have to remove their originals if present\n    var prev = original(value);\n    if (prev) { target[\"delete\"](prev); } // @ts-ignore TODO investigate\n\n    target.add(value);\n  });\n  return target;\n} // We use Maps as `drafts` for Maps, not Objects\n// See proxy.js\n\nfunction assignMap(target, override) {\n  override.forEach(function (value, key) {\n    return target.set(key, value);\n  });\n  return target;\n}\nvar assign = Object.assign || function (target) {\n  var arguments$1 = arguments;\n\n  var overrides = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    overrides[_i - 1] = arguments$1[_i];\n  }\n\n  overrides.forEach(function (override) {\n    if (typeof override === \"object\" && override !== null) { Object.keys(override).forEach(function (key) {\n      return target[key] = override[key];\n    }); }\n  });\n  return target;\n};\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if (invokeGetters === void 0) {\n    invokeGetters = false;\n  }\n\n  if (Array.isArray(base)) { return base.slice(); }\n  if (isMap(base)) { return new Map(base); }\n  if (isSet(base)) { return new Set(base); }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(obj, iter) {\n  if (Array.isArray(obj) || isMap(obj) || isSet(obj)) {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  } else {\n    ownKeys(obj).forEach(function (key) {\n      return iter(key, obj[key], obj);\n    });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return desc && desc.enumerable ? true : false;\n}\nfunction has(thing, prop) {\n  return isMap(thing) ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return isMap(thing) ? thing.get(prop) : thing[prop];\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\nvar hasSet = typeof Set !== \"undefined\";\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\nfunction makeIterable(next) {\n  var _a;\n\n  var self;\n  return self = (_a = {}, _a[Symbol.iterator] = function () {\n    return self;\n  }, _a.next = next, _a);\n}\n/** Map.prototype.values _-or-_ Map.prototype.entries */\n\nfunction iterateMapValues(state, prop, receiver) {\n  var isEntries = prop !== \"values\";\n  return function () {\n    var iterator = latest(state)[Symbol.iterator]();\n    return makeIterable(function () {\n      var result = iterator.next();\n\n      if (!result.done) {\n        var key = result.value[0];\n        var value = receiver.get(key);\n        result.value = isEntries ? [key, value] : value;\n      }\n\n      return result;\n    });\n  };\n}\nfunction makeIterateSetValues(createProxy) {\n  function iterateSetValues(state, prop) {\n    var isEntries = prop === \"entries\";\n    return function () {\n      var iterator = latest(state)[Symbol.iterator]();\n      return makeIterable(function () {\n        var result = iterator.next();\n\n        if (!result.done) {\n          var value = wrapSetValue(state, result.value);\n          result.value = isEntries ? [value, value] : value;\n        }\n\n        return result;\n      });\n    };\n  }\n\n  function wrapSetValue(state, value) {\n    var key = original(value) || value;\n    var draft = state.drafts.get(key);\n\n    if (!draft) {\n      if (state.finalized || !isDraftable(value) || state.finalizing) {\n        return value;\n      }\n\n      draft = createProxy(value, state);\n      state.drafts.set(key, draft);\n\n      if (state.modified) {\n        state.copy.add(draft);\n      }\n    }\n\n    return draft;\n  }\n\n  return iterateSetValues;\n}\n\nfunction latest(state) {\n  return state.copy || state.base;\n}\n\nfunction clone(obj) {\n  if (!isDraftable(obj)) { return obj; }\n  if (Array.isArray(obj)) { return obj.map(clone); }\n  if (isMap(obj)) { return new Map(obj); }\n  if (isSet(obj)) { return new Set(obj); }\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) { cloned[key] = clone(obj[key]); }\n\n  return cloned;\n}\nfunction freeze(obj, deep) {\n  if (deep === void 0) {\n    deep = false;\n  }\n\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }\n\n  if (isSet(obj)) {\n    obj.add = obj.clear = obj[\"delete\"] = dontMutateFrozenCollections;\n  } else if (isMap(obj)) {\n    obj.set = obj.clear = obj[\"delete\"] = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n  if (deep) { each(obj, function (_, value) {\n    return freeze(value, true);\n  }); }\n}\n\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope =\n/** @class */\nfunction () {\n  function ImmerScope(parent) {\n    this.drafts = [];\n    this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n\n    this.canAutoFreeze = true; // To avoid prototype lookups:\n\n    this.patches = null; // TODO:\n  }\n\n  ImmerScope.prototype.usePatches = function (patchListener) {\n    if (patchListener) {\n      this.patches = [];\n      this.inversePatches = [];\n      this.patchListener = patchListener;\n    }\n  };\n\n  ImmerScope.prototype.revoke = function () {\n    this.leave();\n    this.drafts.forEach(revoke); // @ts-ignore\n\n    this.drafts = null; // TODO: // Make draft-related methods throw.\n  };\n\n  ImmerScope.prototype.leave = function () {\n    if (this === ImmerScope.current) {\n      ImmerScope.current = this.parent;\n    }\n  };\n\n  ImmerScope.enter = function () {\n    var scope = new ImmerScope(ImmerScope.current);\n    ImmerScope.current = scope;\n    return scope;\n  };\n\n  return ImmerScope;\n}();\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n\n  if (isMap(base)) {\n    proxyMap(draft);\n  } else if (isSet(base)) {\n    proxySet(draft);\n  } else {\n    each(draft, function (prop) {\n      proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n    });\n  } // See \"proxy.js\" for property documentation.\n\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    finalized: false,\n    assigned: isMap(base) ? new Map() : {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    drafts: isSet(base) ? new Map() : null,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction latest$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(latest$1(state), prop);\n  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(latest$1(state), prop))) { return; }\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) { markChanged(state.parent); }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\n\nvar descriptors = {};\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n      get: function () {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n      set: function (value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction proxyMap(target) {\n  Object.defineProperties(target, mapTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, // @ts-ignore\n    proxyMethod(iterateMapValues) //TODO: , Symbol.iterator)\n    );\n  }\n}\n\nvar mapTraps = finalizeTraps({\n  size: function (state) {\n    return latest$1(state).size;\n  },\n  has: function (state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  set: function (state) {\n    return function (key, value) {\n      if (latest$1(state).get(key) !== value) {\n        prepareCopy(state);\n        markChanged(state);\n        state.assigned.set(key, true);\n        state.copy.set(key, value);\n      }\n\n      return state.draft;\n    };\n  },\n  \"delete\": function (state) {\n    return function (key) {\n      prepareCopy(state);\n      markChanged(state);\n      state.assigned.set(key, false);\n      state.copy[\"delete\"](key);\n      return false;\n    };\n  },\n  clear: function (state) {\n    return function () {\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      markChanged(state);\n      state.assigned = new Map();\n\n      for (var _i = 0, _a = latest$1(state).keys(); _i < _a.length; _i++) {\n        var key = _a[_i];\n        state.assigned.set(key, false);\n      }\n\n      return state.copy.clear();\n    };\n  },\n  forEach: function (state, key, reciever) {\n    return function (cb) {\n      latest$1(state).forEach(function (value, key, map) {\n        cb(reciever.get(key), key, map);\n      });\n    };\n  },\n  get: function (state) {\n    return function (key) {\n      var value = latest$1(state).get(key);\n\n      if (state.finalizing || state.finalized || !isDraftable(value)) {\n        return value;\n      }\n\n      if (value !== state.base.get(key)) {\n        return value;\n      }\n\n      var draft = createProxy(value, state);\n      prepareCopy(state);\n      state.copy.set(key, draft);\n      return draft;\n    };\n  },\n  keys: function (state) {\n    return function () {\n      return latest$1(state).keys();\n    };\n  },\n  values: iterateMapValues,\n  entries: iterateMapValues\n});\n\nfunction proxySet(target) {\n  Object.defineProperties(target, setTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, // @ts-ignore\n    proxyMethod(iterateSetValues) //TODO: , Symbol.iterator)\n    );\n  }\n}\n\nvar iterateSetValues = makeIterateSetValues(createProxy);\nvar setTraps = finalizeTraps({\n  size: function (state) {\n    return latest$1(state).size;\n  },\n  add: function (state) {\n    return function (value) {\n      if (!latest$1(state).has(value)) {\n        markChanged(state);\n\n        if (!state.copy) {\n          prepareCopy(state);\n        }\n\n        state.copy.add(value);\n      }\n\n      return state.draft;\n    };\n  },\n  \"delete\": function (state) {\n    return function (value) {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      return state.copy[\"delete\"](value);\n    };\n  },\n  has: function (state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  clear: function (state) {\n    return function () {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      return state.copy.clear();\n    };\n  },\n  keys: iterateSetValues,\n  entries: iterateSetValues,\n  values: iterateSetValues,\n  forEach: function (state) {\n    return function (cb, thisArg) {\n      var iterator = iterateSetValues(state)();\n      var result = iterator.next();\n\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, state.draft);\n        result = iterator.next();\n      }\n    };\n  }\n});\n\nfunction finalizeTraps(traps) {\n  return Object.keys(traps).reduce(function (acc, key) {\n    var builder = key === \"size\" ? proxyAttr : proxyMethod;\n    acc[key] = builder(traps[key], key);\n    return acc;\n  }, {});\n}\n\nfunction proxyAttr(fn) {\n  return {\n    get: function () {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      return fn(state);\n    }\n  };\n}\n\nfunction proxyMethod(trap, key) {\n  return {\n    get: function () {\n      return function () {\n        var arguments$1 = arguments;\n\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments$1[_i];\n        }\n\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        return trap(state, key, state.draft).apply(void 0, args);\n      };\n    }\n  };\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) { throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest$1(state))); }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) { markChanged(state); }\n      } else if (isMap(state.base)) {\n        if (hasMapChanges(state)) { markChanged(state); }\n      } else if (isSet(state.base)) {\n        if (hasSetChanges(state)) { markChanged(state); }\n      } else if (hasObjectChanges(state)) {\n        markChanged(state);\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") { return; }\n  var state = object[DRAFT_STATE];\n  if (!state) { return; }\n  var base = state.base,\n      draft = state.draft,\n      assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }\n    } else {\n      for (var i = base.length; i < draft.length; i++) { assigned[i] = true; }\n    }\n\n    for (var i = 0; i < draft.length; i++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i] === undefined) { markChangesRecursively(draft[i]); }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base,\n      draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state_1 = value && value[DRAFT_STATE];\n\n        if (state_1 ? state_1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) { return true; } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction hasMapChanges(state) {\n  var base = state.base,\n      draft = state.draft;\n  if (base.size !== draft.size) { return true; } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : value !== base.get(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction hasSetChanges(state) {\n  var base = state.base,\n      draft = state.draft;\n  if (base.size !== draft.size) { return true; } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : !base.has(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    willFinalize: willFinalize,\n    createProxy: createProxy\n});\n\nvar _a$1, _b;\n\nfunction willFinalize$1() {}\n/**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\n\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  }; // the traps must target something, a bit like the 'real' base.\n  // but also, we need to be able to determine from the target what the relevant state is\n  // (to avoid creating traps per instance to capture the state in closure,\n  // and to avoid creating weird hidden properties as well)\n  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\n  var target = state;\n  var traps = objectTraps;\n\n  if (Array.isArray(base)) {\n    target = [state];\n    traps = arrayTraps;\n  } // Map drafts must support object keys, so we use Map objects to track changes.\n  else if (isMap(base)) {\n      traps = mapTraps$1;\n      state.drafts = new Map();\n      state.assigned = new Map();\n    } // Set drafts use a Map object to track which of its values are drafted.\n    // And we don't need the \"assigned\" property, because Set objects have no keys.\n    else if (isSet(base)) {\n        traps = setTraps$1;\n        state.drafts = new Map();\n      }\n\n  var _a = Proxy.revocable(target, traps),\n      revoke = _a.revoke,\n      proxy = _a.proxy;\n\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\n/**\r\n * Object drafts\r\n */\n\nvar objectTraps = {\n  get: function (state, prop) {\n    if (prop === DRAFT_STATE) { return state; }\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n\n    var value = latest$2(state)[prop];\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek$1(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).\n\n      drafts = state.copy;\n    }\n\n    return drafts[prop] = createProxy$1(value, state);\n  },\n  has: function (state, prop) {\n    return prop in latest$2(state);\n  },\n  ownKeys: function (state) {\n    return Reflect.ownKeys(latest$2(state));\n  },\n  set: function (state, prop, value) {\n    if (!state.modified) {\n      var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n      if (isUnchanged) { return true; }\n      markChanged$1(state);\n    }\n\n    state.assigned[prop] = true;\n    state.copy[prop] = value;\n    return true;\n  },\n  deleteProperty: function (state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      markChanged$1(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    }\n\n    if (state.copy) { delete state.copy[prop]; }\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function (state, prop) {\n    var owner = latest$2(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n    }\n\n    return desc;\n  },\n  defineProperty: function () {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n  getPrototypeOf: function (state) {\n    return Object.getPrototypeOf(state.base);\n  },\n  setPrototypeOf: function () {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n};\n/**\r\n * Array drafts\r\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n}; // Used by Map and Set drafts\n\n\nvar reflectTraps = makeReflectTraps([\"ownKeys\", \"has\", \"set\", \"deleteProperty\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"preventExtensions\", \"isExtensible\", \"getPrototypeOf\"]);\n/**\r\n * Map drafts\r\n */\n\nvar mapTraps$1 = makeTrapsForGetters((_a$1 = {}, _a$1[DRAFT_STATE] = function (state) {\n  return state;\n}, _a$1.size = function (state) {\n  return latest$2(state).size;\n}, _a$1.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, _a$1.set = function (state) {\n  return function (key, value) {\n    var values = latest$2(state);\n\n    if (!values.has(key) || values.get(key) !== value) {\n      markChanged$1(state); // @ts-ignore\n\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n\n    return state.draft;\n  };\n}, _a$1[\"delete\"] = function (state) {\n  return function (key) {\n    if (latest$2(state).has(key)) {\n      markChanged$1(state); // @ts-ignore\n\n      state.assigned.set(key, false);\n      return state.copy[\"delete\"](key);\n    }\n\n    return false;\n  };\n}, _a$1.clear = function (state) {\n  return function () {\n    markChanged$1(state);\n    state.assigned = new Map();\n    each(latest$2(state).keys(), function (_, key) {\n      // @ts-ignore\n      state.assigned.set(key, false);\n    });\n    return state.copy.clear();\n  };\n}, // @ts-ignore\n_a$1.forEach = function (state, _, receiver) {\n  return function (cb, thisArg) {\n    return latest$2(state).forEach(function (_, key, map) {\n      var value = receiver.get(key);\n      cb.call(thisArg, value, key, map);\n    });\n  };\n}, _a$1.get = function (state) {\n  return function (key) {\n    var drafts = state.modified ? state.copy : state.drafts; // @ts-ignore TODO: ...or fix by using different ES6Draft types (but better just unify to maps)\n\n    if (drafts.has(key)) {\n      // @ts-ignore\n      var value_1 = drafts.get(key);\n      if (isDraft(value_1) || !isDraftable(value_1)) { return value_1; }\n      var draft_1 = createProxy$1(value_1, state); // @ts-ignore\n\n      drafts.set(key, draft_1);\n      return draft_1;\n    }\n\n    var value = latest$2(state).get(key);\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    var draft = createProxy$1(value, state); //@ts-ignore\n\n    drafts.set(key, draft);\n    return draft;\n  };\n}, _a$1.keys = function (state) {\n  return function () {\n    return latest$2(state).keys();\n  };\n}, //@ts-ignore\n_a$1.values = iterateMapValues, //@ts-ignore\n_a$1.entries = iterateMapValues, _a$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateMapValues, _a$1));\nvar iterateSetValues$1 = makeIterateSetValues(createProxy$1);\n/**\r\n * Set drafts\r\n */\n\nvar setTraps$1 = makeTrapsForGetters((_b = {}, //@ts-ignore\n_b[DRAFT_STATE] = function (state) {\n  return state;\n}, _b.size = function (state) {\n  return latest$2(state).size;\n}, _b.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, _b.add = function (state) {\n  return function (value) {\n    if (!latest$2(state).has(value)) {\n      markChanged$1(state); //@ts-ignore\n\n      state.copy.add(value);\n    }\n\n    return state.draft;\n  };\n}, _b[\"delete\"] = function (state) {\n  return function (value) {\n    markChanged$1(state); //@ts-ignore\n\n    return state.copy[\"delete\"](value);\n  };\n}, _b.clear = function (state) {\n  return function () {\n    markChanged$1(state); //@ts-ignore\n\n    return state.copy.clear();\n  };\n}, _b.forEach = function (state) {\n  return function (cb, thisArg) {\n    var iterator = iterateSetValues$1(state)();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  };\n}, _b.keys = iterateSetValues$1, _b.values = iterateSetValues$1, _b.entries = iterateSetValues$1, _b[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateSetValues$1, _b));\n/**\r\n * Helpers\r\n */\n// Retrieve the latest values of the draft.\n\nfunction latest$2(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest$2(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    var base = state.base,\n        drafts = state.drafts,\n        parent = state.parent;\n    var copy = shallowCopy(base);\n\n    if (isSet(base)) {\n      // Note: The `drafts` property is preserved for Set objects, since\n      // we need to keep track of which values are drafted.\n      assignSet(copy, drafts);\n    } else {\n      // Merge nested drafts into the copy.\n      if (isMap(base)) { assignMap(copy, drafts); }else { assign(copy, drafts); }\n      state.drafts = null;\n    }\n\n    state.copy = copy;\n\n    if (parent) {\n      markChanged$1(parent);\n    }\n  }\n}\n/** Create traps that all use the `Reflect` API on the `latest(state)` */\n\n\nfunction makeReflectTraps(names) {\n  return names.reduce(function (traps, name) {\n    // @ts-ignore\n    traps[name] = function (state) {\n      var arguments$1 = arguments;\n\n      var args = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments$1[_i];\n      }\n\n      return Reflect[name].apply(Reflect, __spreadArrays([latest$2(state)], args));\n    };\n\n    return traps;\n  }, {});\n}\n\nfunction makeTrapsForGetters(getters) {\n  return assign({}, reflectTraps, {\n    get: function (state, prop, receiver) {\n      return getters.hasOwnProperty(prop) ? getters[prop](state, prop, receiver) : Reflect.get(state, prop, receiver);\n    },\n    setPrototypeOf: function (state) {\n      throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n    }\n  });\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    willFinalize: willFinalize$1,\n    createProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  var generatePatchesFn = Array.isArray(state.base) ? generateArrayPatches : isSet(state.base) ? generateSetPatches : generatePatchesFromAssigned;\n  generatePatchesFn(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var _a, _b;\n\n  var base = state.base,\n      copy = state.copy,\n      assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    _a = [copy, base], base = _a[0], copy = _a[1];\n    _b = [inversePatches, patches], patches = _b[0], inversePatches = _b[1];\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i = end + delta - 1; i >= end; --i) {\n    var path = basePath.concat([i]);\n    patches[replaceCount + i - end] = {\n      op: \"add\",\n      path: path,\n      value: copy[i]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") { return; }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy;\n  var i = 0;\n  base.forEach(function (value) {\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  });\n  i = 0;\n  copy.forEach(function (value) {\n    if (!base.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  });\n}\n\nfunction applyPatches(draft, patches) {\n  patches.forEach(function (patch) {\n    var path = patch.path,\n        op = patch.op;\n    if (!path.length) { throw new Error(\"Illegal state\"); }\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n      if (!base || typeof base !== \"object\") { throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); } // prettier-ignore\n    }\n\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        if (isMap(base)) {\n          base.set(key, value);\n        } else if (isSet(base)) {\n          throw new Error('Sets cannot have \"replace\" patches.');\n        } else {\n          // if value is an object, then it's assigned by reference\n          // in the following add or remove ops, the value field inside the patch will also be modifyed\n          // so we use value from the cloned patch\n          base[key] = value;\n        }\n\n        break;\n\n      case \"add\":\n        if (isSet(base)) {\n          base[\"delete\"](patch.value);\n        }\n\n        Array.isArray(base) ? base.splice(key, 0, value) : isMap(base) ? base.set(key, value) : isSet(base) ? base.add(value) : base[key] = value;\n        break;\n\n      case \"remove\":\n        Array.isArray(base) ? base.splice(key, 1) : isMap(base) ? base[\"delete\"](key) : isSet(base) ? base[\"delete\"](patch.value) : delete base[key];\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  });\n  return draft;\n}\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\n\nvar Immer =\n/** @class */\nfunction () {\n  function Immer(config) {\n    this.useProxies = false;\n    this.autoFreeze = false;\n    assign(this, configDefaults, config);\n    this.setUseProxies(this.useProxies);\n    this.produce = this.produce.bind(this);\n    this.produceWithPatches = this.produceWithPatches.bind(this);\n  }\n  /**\r\n   * The `produce` function takes a value and a \"recipe function\" (whose\r\n   * return value often depends on the base state). The recipe function is\r\n   * free to mutate its first argument however it wants. All mutations are\r\n   * only ever applied to a __copy__ of the base state.\r\n   *\r\n   * Pass only a function to create a \"curried producer\" which relieves you\r\n   * from passing the recipe function every time.\r\n   *\r\n   * Only plain objects and arrays are made mutable. All other objects are\r\n   * considered uncopyable.\r\n   *\r\n   * Note: This function is __bound__ to its `Immer` instance.\r\n   *\r\n   * @param {any} base - the initial state\r\n   * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n   * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n   * @returns {any} a new state, or the initial state if nothing was modified\r\n   */\n\n\n  Immer.prototype.produce = function (base, recipe, patchListener) {\n    var _this = this; // curried invocation\n\n\n    if (typeof base === \"function\" && typeof recipe !== \"function\") {\n      var defaultBase_1 = recipe;\n      recipe = base;\n      var self_1 = this;\n      return function curriedProduce(base) {\n        var arguments$1 = arguments;\n\n        var _this = this;\n\n        if (base === void 0) {\n          base = defaultBase_1;\n        }\n\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments$1[_i];\n        }\n\n        return self_1.produce(base, function (draft) {\n          return recipe.call.apply(recipe, __spreadArrays([_this, draft], args));\n        }); // prettier-ignore\n      };\n    } // prettier-ignore\n\n\n    {\n      if (typeof recipe !== \"function\") {\n        throw new Error(\"The first or second argument to `produce` must be a function\");\n      }\n\n      if (patchListener !== undefined && typeof patchListener !== \"function\") {\n        throw new Error(\"The third argument to `produce` must be a function or undefined\");\n      }\n    }\n    var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n    if (isDraftable(base)) {\n      var scope_1 = ImmerScope.enter();\n      var proxy = this.createProxy(base);\n      var hasError = true;\n\n      try {\n        result = recipe(proxy);\n        hasError = false;\n      } finally {\n        // finally instead of catch + rethrow better preserves original stack\n        if (hasError) { scope_1.revoke(); }else { scope_1.leave(); }\n      }\n\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then(function (result) {\n          scope_1.usePatches(patchListener);\n          return _this.processResult(result, scope_1);\n        }, function (error) {\n          scope_1.revoke();\n          throw error;\n        });\n      }\n\n      scope_1.usePatches(patchListener);\n      return this.processResult(result, scope_1);\n    } else {\n      result = recipe(base);\n      if (result === NOTHING) { return undefined; }\n      if (result === undefined) { result = base; }\n      this.maybeFreeze(result, true);\n      return result;\n    }\n  };\n\n  Immer.prototype.produceWithPatches = function (arg1, arg2, arg3) {\n    var _this = this;\n\n    if (typeof arg1 === \"function\") {\n      return function (state) {\n        var arguments$1 = arguments;\n\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments$1[_i];\n        }\n\n        return _this.produceWithPatches(state, function (draft) {\n          return arg1.apply(void 0, __spreadArrays([draft], args));\n        });\n      };\n    } // non-curried form\n\n\n    if (arg3) { throw new Error(\"A patch listener cannot be passed to produceWithPatches\"); }\n    var patches, inversePatches;\n    var nextState = this.produce(arg1, arg2, function (p, ip) {\n      patches = p;\n      inversePatches = ip;\n    });\n    return [nextState, patches, inversePatches];\n  };\n\n  Immer.prototype.createDraft = function (base) {\n    if (!isDraftable(base)) {\n      throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n    }\n\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    proxy[DRAFT_STATE].isManual = true;\n    scope.leave();\n    return proxy;\n  };\n\n  Immer.prototype.finishDraft = function (draft, patchListener) {\n    var state = draft && draft[DRAFT_STATE];\n\n    if (!state || !state.isManual) {\n      throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n    }\n\n    if (state.finalized) {\n      throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n    }\n\n    var scope = state.scope;\n    scope.usePatches(patchListener);\n    return this.processResult(undefined, scope);\n  };\n  /**\r\n   * Pass true to automatically freeze all copies created by Immer.\r\n   *\r\n   * By default, auto-freezing is disabled in production.\r\n   */\n\n\n  Immer.prototype.setAutoFreeze = function (value) {\n    this.autoFreeze = value;\n  };\n  /**\r\n   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n   * always faster than using ES5 proxies.\r\n   *\r\n   * By default, feature detection is used, so calling this is rarely necessary.\r\n   */\n\n\n  Immer.prototype.setUseProxies = function (value) {\n    this.useProxies = value;\n    assign(this, value ? modernProxy : legacyProxy);\n  };\n\n  Immer.prototype.applyPatches = function (base, patches) {\n    // If a patch replaces the entire state, take that replacement as base\n    // before applying patches\n    var i;\n\n    for (i = patches.length - 1; i >= 0; i--) {\n      var patch = patches[i];\n\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n\n    if (isDraft(base)) {\n      // N.B: never hits if some patch a replacement, patches are never drafts\n      return applyPatches(base, patches);\n    } // Otherwise, produce a copy of the base state.\n\n\n    return this.produce(base, function (draft) {\n      return applyPatches(draft, patches.slice(i + 1));\n    });\n  };\n  /** @internal */\n\n\n  Immer.prototype.processResult = function (result, scope) {\n    var baseDraft = scope.drafts[0];\n    var isReplaced = result !== undefined && result !== baseDraft;\n    this.willFinalize(scope, result, isReplaced);\n\n    if (isReplaced) {\n      if (baseDraft[DRAFT_STATE].modified) {\n        scope.revoke();\n        throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n      }\n\n      if (isDraftable(result)) {\n        // Finalize the result in case it contains (or is) a subset of the draft.\n        result = this.finalize(result, null, scope);\n        this.maybeFreeze(result);\n      }\n\n      if (scope.patches) {\n        scope.patches.push({\n          op: \"replace\",\n          path: [],\n          value: result\n        });\n        scope.inversePatches.push({\n          op: \"replace\",\n          path: [],\n          value: baseDraft[DRAFT_STATE].base\n        });\n      }\n    } else {\n      // Finalize the base draft.\n      result = this.finalize(baseDraft, [], scope);\n    }\n\n    scope.revoke();\n\n    if (scope.patches) {\n      scope.patchListener(scope.patches, scope.inversePatches);\n    }\n\n    return result !== NOTHING ? result : undefined;\n  };\n  /**\r\n   * @internal\r\n   * Finalize a draft, returning either the unmodified base state or a modified\r\n   * copy of the base state.\r\n   */\n\n\n  Immer.prototype.finalize = function (draft, path, scope) {\n    var _this = this;\n\n    var state = draft[DRAFT_STATE];\n\n    if (!state) {\n      if (Object.isFrozen(draft)) { return draft; }\n      return this.finalizeTree(draft, null, scope);\n    } // Never finalize drafts owned by another scope.\n\n\n    if (state.scope !== scope) {\n      return draft;\n    }\n\n    if (!state.modified) {\n      this.maybeFreeze(state.base, true);\n      return state.base;\n    }\n\n    if (!state.finalized) {\n      state.finalized = true;\n      this.finalizeTree(state.draft, path, scope); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n      if (this.onDelete && !isSet(state.base)) {\n        // The `assigned` object is unreliable with ES5 drafts.\n        if (this.useProxies) {\n          var assigned = state.assigned;\n          each(assigned, function (prop, exists) {\n            var _a, _b;\n\n            if (!exists) { (_b = (_a = _this).onDelete) === null || _b === void 0 ? void 0 : _b.call(_a, state, prop); }\n          });\n        } else {\n          // TODO: Figure it out for Maps and Sets if we need to support ES5\n          var base = state.base,\n              copy_1 = state.copy;\n          each(base, function (prop) {\n            var _a, _b;\n\n            if (!has(copy_1, prop)) { (_b = (_a = _this).onDelete) === null || _b === void 0 ? void 0 : _b.call(_a, state, prop); }\n          });\n        }\n      }\n\n      if (this.onCopy) {\n        this.onCopy(state);\n      } // At this point, all descendants of `state.copy` have been finalized,\n      // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n      if (this.autoFreeze && scope.canAutoFreeze) {\n        freeze(state.copy, false);\n      }\n\n      if (path && scope.patches) {\n        generatePatches(state, path, scope.patches, scope.inversePatches);\n      }\n    }\n\n    return state.copy;\n  };\n  /**\r\n   * @internal\r\n   * Finalize all drafts in the given state tree.\r\n   */\n\n\n  Immer.prototype.finalizeTree = function (root, rootPath, scope) {\n    var _this = this;\n\n    var state = root[DRAFT_STATE];\n\n    if (state) {\n      if (!this.useProxies) {\n        // Create the final copy, with added keys and without deleted keys.\n        state.copy = shallowCopy(state.draft, true);\n      }\n\n      root = state.copy;\n    }\n\n    var needPatches = !!rootPath && !!scope.patches;\n\n    var finalizeProperty = function (prop, value, parent) {\n      if (value === parent) {\n        throw Error(\"Immer forbids circular references\");\n      } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n      var isDraftProp = !!state && parent === root;\n      var isSetMember = isSet(parent);\n\n      if (isDraft(value)) {\n        var path = isDraftProp && needPatches && !isSetMember && // Set objects are atomic since they have no keys.\n        !has(state.assigned, prop) // Skip deep patches for assigned keys.\n        ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n        value = _this.finalize(value, path, scope);\n        replace(parent, prop, value); // Drafts from another scope must prevent auto-freezing.\n\n        if (isDraft(value)) {\n          scope.canAutoFreeze = false;\n        } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n        if (isDraftProp && value === get(state.base, prop)) { return; }\n      } // Unchanged draft properties are ignored.\n      else if (isDraftProp && is(value, get(state.base, prop))) {\n          return;\n        } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n        else if (isDraftable(value) && !Object.isFrozen(value)) {\n            each(value, finalizeProperty);\n\n            _this.maybeFreeze(value);\n          }\n\n      if (isDraftProp && _this.onAssign && !isSetMember) {\n        _this.onAssign(state, prop, value);\n      }\n    };\n\n    each(root, finalizeProperty);\n    return root;\n  };\n\n  Immer.prototype.maybeFreeze = function (value, deep) {\n    if (deep === void 0) {\n      deep = false;\n    }\n\n    if (this.autoFreeze && !isDraft(value)) {\n      freeze(value, deep);\n    }\n  };\n\n  return Immer;\n}();\n\nfunction replace(parent, prop, value) {\n  if (isMap(parent)) {\n    parent.set(prop, value);\n  } else if (isSet(parent)) {\n    // In this case, the `prop` is actually a draft.\n    parent[\"delete\"](prop);\n    parent.add(value);\n  } else if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n    // Preserve non-enumerable properties.\n    parent[prop] = value;\n  } else {\n    Object.defineProperty(parent, prop, {\n      value: value,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nvar immer = new Immer();\n/**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\n\nvar produce = immer.produce;\n/**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * By default, auto-freezing is disabled in production.\r\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };\n//# sourceMappingURL=immer.module.js.map\n","/*! https://mths.be/esrever v0.2.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar regexSymbolWithCombiningMarks = /([\\0-\\u02FF\\u0370-\\u1AAF\\u1B00-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uE000-\\uFE1F\\uFE30-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])([\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]+)/g;\n\tvar regexSurrogatePair = /([\\uD800-\\uDBFF])([\\uDC00-\\uDFFF])/g;\n\n\tvar reverse = function(string) {\n\t\t// Step 1: deal with combining marks and astral symbols (surrogate pairs)\n\t\tstring = string\n\t\t\t// Swap symbols with their combining marks so the combining marks go first\n\t\t\t.replace(regexSymbolWithCombiningMarks, function($0, $1, $2) {\n\t\t\t\t// Reverse the combining marks so they will end up in the same order\n\t\t\t\t// later on (after another round of reversing)\n\t\t\t\treturn reverse($2) + $1;\n\t\t\t})\n\t\t\t// Swap high and low surrogates so the low surrogates go first\n\t\t\t.replace(regexSurrogatePair, '$2$1');\n\t\t// Step 2: reverse the code units in the string\n\t\tvar result = '';\n\t\tvar index = string.length;\n\t\twhile (index--) {\n\t\t\tresult += string.charAt(index);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar esrever = {\n\t\t'version': '0.2.0',\n\t\t'reverse': reverse\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn esrever;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = esrever;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in esrever) {\n\t\t\t\tesrever.hasOwnProperty(key) && (freeExports[key] = esrever[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.esrever = esrever;\n\t}\n\n}(this));\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n"],"sourceRoot":""}